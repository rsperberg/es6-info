
<!DOCTYPE html>

<!-- saved from url=(0059)https://ponyfoo.com/articles/a-brief-history-of-es6-tooling -->

<html lang="en" itemscope="" itemtype="http://schema.org/Blog" class="ly-teasers ly-custom-headings">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>ES6 in Depth</title>
    <meta charset="utf-8" />
    <!-- https://mathiasbynens.be/notes/touch-icons#sizes-->
    <link rel="icon" sizes="192x192" href="https://ponyfoo.com/touch-icon-192x192.png" />
    <link rel="apple-touch-icon-precomposed" sizes="180x180" href="https://ponyfoo.com/apple-touch-icon-180x180-precomposed.png" />
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="https://ponyfoo.com/apple-touch-icon-152x152-precomposed.png" />
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://ponyfoo.com/apple-touch-icon-144x144-precomposed.png" />
    <link rel="apple-touch-icon-precomposed" sizes="120x120" href="https://ponyfoo.com/apple-touch-icon-120x120-precomposed.png" />
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="https://ponyfoo.com/apple-touch-icon-114x114-precomposed.png" />
    <link rel="apple-touch-icon-precomposed" sizes="76x76" href="https://ponyfoo.com/apple-touch-icon-76x76-precomposed.png" />
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="https://ponyfoo.com/apple-touch-icon-72x72-precomposed.png" />
    <link rel="apple-touch-icon-precomposed" href="https://ponyfoo.com/apple-touch-icon-precomposed.png" />
    <link rel="alternate" type="application/rss+xml" href="https://ponyfoo.com/articles/feed" />
    <link rel="search" type="application/opensearchdescription+xml" title="Pony Foo" href="https://ponyfoo.com/opensearch.xml" />
    <link rel="manifest" href="https://ponyfoo.com/manifest.json" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" itemprop="creator" content="Nicolas Bevacqua &lt;hello@ponyfoo.com&gt;" />
    <meta name="keywords" content="es6,history-lesson,traceur,babel,es6-in-depth" />
    <meta name="description" property="og:description" itemprop="description" content="I wrote a few articles about React and ES6 these last few days, and today I wanted to add a bit more of context as to why I seem to be super into ES6 all of sudden. I’ve …" />
    <meta property="og:site_name" content="Pony Foo" />
    <meta name="twitter:title" itemprop="name" property="og:title" content="ES6 in Depth" />
    <meta name="twitter:description" content="I wrote a few articles about React and ES6 these last few days, and today I wanted to add a bit more of context as to why I seem to be super into ES6 all of sudden. I’ve …" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@ponyfoo" />
    <meta name="twitter:creator" content="@nzgb" />
    <meta property="og:image" itemprop="images" content="https://i.imgur.com/DlNQvKS.png" />
    <meta property="og:image" content="https://i.imgur.com/SiBLQvN.png" />
    <meta property="og:image" content="https://ponyfoo.com/img/ponyfoo.png" />
    <meta name="twitter:image:src" content="https://i.imgur.com/DlNQvKS.png" />
    <style>
        .at-header, .at-teaser, .md-code-block { width: 1000px;}
        .go-logo-container {  width: 1000px;}
        p, li { font-size: 13pt !important; line-height: 30px; }
        pre { font-family: Share-Tech,monospace; font-size: 13pt;}
        strong, b { font-family: Share-Bold; font-weight: normal;}
        hr.style8 {
            border-top: 1px solid #8c8b8b;
            border-bottom: 1px solid #fff;
        } /*  from http://codepen.io/ibrahimjabbari/pen/ozinB  */
        hr.style8:after {
            content: '';
            display: block;
            margin-top: 2px;
            border-top: 1px solid #8c8b8b;
            border-bottom: 1px solid #fff;
        }
        img {
           border:1px solid #989898 !important;
        }
        img.ponyfoo {
           border:0px solid #fff !important;
        }
        img.uparrow {
           width:9px;
           height:10px;
           border:0px solid #fff !important;
        }
        h1 span.md-heading, h2 span.md-heading, h3 span.md-heading { font-family: Share-Bold; font-weight: 700}
    </style>
    <script>~function(e){var l=e.createElement("link"),t=e.getElementsByTagName("head")[0];l.rel="stylesheet",l.href="/css/all.41e187e0.css",l.media="only x",t.appendChild(l),setTimeout(function(){l.media="all"})}(document);
    </script>
    <!--  link rel="stylesheet" href="./01_A Brief History of ES6 Tooling_files/all.41e187e0.css" media="all" /  -->
    <!--  link rel="stylesheet" href="./01_A Brief History of ES6 Tooling_files/css" media="all" /  -->
    <link rel="stylesheet" href="./auxi/es6-in-depth.css" media="all" />

    <style type="text/css">
    </style>
    </head>
<body id="body-top">
<header class="ly-header vw-title">
<h1 class="go-logo-container">
<span class="go-anchor gg-container">



</span>
<span class="go-text-wrapper"> <img src="./auxi/ponyfoo.png" class="ponyfoo" alt="Pony Foo"/></span>
</h1>
<nav class="hn-navigation"></nav>
</header>

<main class="ly-main">
<header class="at-header">
<h1 itemprop="headline" class="dc-title" id="a-brief-history-of-es6-tooling">ES6 in Depth
</h1>
</header>
<section class="at-teaser">
<div class="at-teaser-markdown md-markdown">

<p>The following <a href="https://ponyfoo.com/articles/tagged/es6-in-depth" title="link to ponyfoo.com articles on es6">25 articles</a> diving into ES6 (aka ES 2015) were written by the Argentinian JavaScript consultant <a href="https://bevacqua.io/" title="link to Nicolas Bevacqua page at bevacqua.io">Nicolas Bevacqua</a> and published at his <a href="https://ponyfoo.com/" title="link to ponyfoo.com">Pony Foo</a> blog from late August through October, 2015.</p>
</div>
</section>

<section class="at-introduction">
<p><span>The contents distributed here are licensed by Nicolas Bevacqua under a </span><a href="https://creativecommons.org/licenses/by-nc/2.5/" target="_blank" class="ly-license">Creative Commons Attribution-NonCommercial 2.5 License</a><span>.</span> Minor editorial changes have been made, as have various formatting changes, including syntax highlighting additions.</p>
</section>

<section>
<blockquote>
<div id="top">
<p><em>Click to jump directly to the article.</em></p>
<ol style="list-style: decimal inside; -webkit-padding-start: 20px;">
<div style="-moz-column-width: 26em; -webkit-column-width: 26em; column-width: 26em;">
<li>
  <p style="font-family: Share-Bold"><a style="color:black; text-decoration:none;" href="#a-brief-history-of-es6-tooling" title="Jump to 'A Brief History of ES6 Tooling' ">A Brief History of ES6 Tooling</a></p>
</li>
<li>
  <p style="font-family: Share-Bold"><a style="color:black; text-decoration:none;" href="#es6-destructuring-in-depth" title="Jump to 'ES6 JavaScript Destructuring in Depth' ">ES6 JavaScript Destructuring in Depth</a></p>
</li>
<li>
  <p style="font-family: Share-Bold"><a style="color:black; text-decoration:none;" href="#es6-template-strings-in-depth" title="Jump to 'ES6 Template Literals in Depth' ">ES6 Template Literals in Depth</a></p>
</li>
<li>
  <p style="font-family: Share-Bold"><a style="color:black; text-decoration:none;" href="#es6-arrow-functions-in-depth" title="Jump to 'ES6 Arrow Functions in Depth' ">ES6 Arrow Functions in Depth</a></p>
</li>
<li>
  <p style="font-family: Share-Bold"><a style="color:black; text-decoration:none;" href="#es6-spread-and-butter-in-depth" title="Jump to 'ES6 Spread and Butter in Depth' ">ES6 Spread and Butter in Depth</a></p>
</li>
<li>
  <p style="font-family: Share-Bold"><a style="color:black; text-decoration:none;" href="#es6-object-literal-features-in-depth" title="Jump to 'ES6 Object Literal Features in Depth' ">ES6 Object Literal Features in Depth</a></p>
</li>
<li>
  <p style="font-family: Share-Bold"><a style="color:black; text-decoration:none;" href="#es6-classes-in-depth" title="Jump to 'ES6 Classes in Depth' ">ES6 Classes in Depth</a></p>
</li>
<li>
  <p style="font-family: Share-Bold"><a style="color:black; text-decoration:none;" href="#es6-let-const-and-temporal-dead-zone-in-depth" title="Jump to 'ES6 Let, Const and the Temporal Dead Zone (TDZ) in Depth' ">ES6 Let, Const and the ‘Temporal Dead Zone’ in Depth</a></p>
</li>
<li>
  <p style="font-family: Share-Bold"><a style="color:black; text-decoration:none;" href="#es6-iterators-in-depth" title="Jump to 'ES6 Iterators in Depth' ">ES6 Iterators in Depth</a></p>
</li>
<li>
  <p style="font-family: Share-Bold"><a style="color:black; text-decoration:none;" href="#es6-generators-in-depth" title="Jump to 'ES6 Generators in Depth' ">ES6 Generators in Depth</a></p>
</li>
<li>
  <p style="font-family: Share-Bold"><a style="color:black; text-decoration:none;" href="#es6-symbols-in-depth" title="Jump to 'ES6 Symbols in Depth' ">ES6 Symbols in Depth</a></p>
</li>
<li>
  <p style="font-family: Share-Bold"><a style="color:black; text-decoration:none;" href="#es6-maps-in-depth" title="Jump to 'ES6 Maps in Depth' ">ES6 Maps in Depth</a></p>
</li>
<li>
  <p style="font-family: Share-Bold"><a style="color:black; text-decoration:none;" href="#es6-weakmaps-sets-and-weaksets-in-depth" title="Jump to 'ES6 WeakMaps, Sets and WeakSets in Depth' ">ES6 WeakMaps, Sets and WeakSets in Depth</a></p>
</li>
<li>
  <p style="font-family: Share-Bold"><a style="color:black; text-decoration:none;" href="#es6-proxies-in-depth" title="Jump to 'ES6 Proxies in Depth' ">ES6 Proxies in Depth</a></p>
</li>
<li>
  <p style="font-family: Share-Bold"><a style="color:black; text-decoration:none;" href="#es6-proxy-traps-in-depth" title="Jump to 'ES6 Proxy Traps in Depth' ">ES6 Proxy Traps in Depth</a></p>
</li>
<li>
  <p style="font-family: Share-Bold"><a style="color:black; text-decoration:none;" href="#more-es6-proxy-traps-in-depth" title="Jump to 'More ES6 Proxy Traps in Depth' ">More ES6 Proxy Traps in Depth</a></p>
</li>
<li>
  <p style="font-family: Share-Bold"><a style="color:black; text-decoration:none;" href="#es6-reflection-in-depth" title="Jump to 'ES6 Reflection in Depth' ">ES6 Reflection in Depth</a></p>
</li>
<li>
  <p style="font-family: Share-Bold"><a style="color:black; text-decoration:none;" href="#es6-number-improvements-in-depth" title="Jump to 'ES6 Number Improvements in Depth' ">ES6 Number Improvements in Depth</a></p>
</li>
<li>
  <p style="font-family: Share-Bold"><a style="color:black; text-decoration:none;" href="#es6-math-additions-in-depth" title="Jump to 'ES6 Math Additions in Depth' ">ES6 Math Additions in Depth</a></p>
</li>
<li>
  <p style="font-family: Share-Bold"><a style="color:black; text-decoration:none;" href="#es6-array-extensions-in-depth" title="Jump to 'ES6 Array Extensions in Depth' ">ES6 Array Extensions in Depth</a></p>
</li>
<li>
  <p style="font-family: Share-Bold"><a style="color:black; text-decoration:none;" href="#es6-object-changes-in-depth" title="Jump to 'ES6 Object Changes in Depth' ">ES6 Object Changes in Depth</a></p>
</li>
<li>
  <p style="font-family: Share-Bold"><a style="color:black; text-decoration:none;" href="#es6-strings-and-unicode-in-depth" title="Jump to 'ES6 Strings (and Unicode, ❤) in Depth' ">ES6 Strings (and Unicode, ❤) in Depth</a></p>
</li>
<li>
  <p style="font-family: Share-Bold"><a style="color:black; text-decoration:none;" href="#es6-modules-in-depth" title="Jump to 'ES6 Modules in Depth' ">ES6 Modules in Depth</a></p>
</li>
<li>
  <p style="font-family: Share-Bold"><a style="color:black; text-decoration:none;" href="#es6-promises-in-depth" title="Jump to 'ES6 Promises in Depth' ">ES6 Promises in Depth</a></p>
</li>
<li>
  <p style="font-family: Share-Bold"><a style="color:black; text-decoration:none;" href="#es6-overview" title="Jump to 'ES6 Overview in 350 Bullet Points' ">ES6 Overview in 350 Bullet Points</a></p>
</li>
<li>
  <p style="font-family: Share-Bold"><a style="color:black; text-decoration:none;" href="#es6-about-the-author" title="Jump to 'About the Author' ">About the Author, Nicolas Bevacqua</a></p>
</li>
</div>
</ol>
</div>
</blockquote>
</section>
</main>


<main class="ly-main">
<header class="at-header">
<h1 itemprop="headline" class="dc-title" id="a-brief-history-of-es6-tooling">A Brief History of ES6 Tooling
</h1>
</header>
<section class="at-teaser">
<div class="at-teaser-markdown md-markdown">

<p>I wrote a few articles about React and ES6 these last few days, and today I wanted to add a bit more of context as to why I seem to be super into ES6 all of sudden. I’ve had an interest in ES6 for a long time, but we weren’t always prepared to write code in ES6. In this post I wanted to briefly touch on the history of ES6 tooling and why I believe that today we’re in a much better place to adopt ES6 than where we were half a year ago.</p>
</div>
</section>
<section class="at-container de-host">
<div class="de-column">
<article itemscope="itemscope" itemtype="http://schema.org/BlogPosting" class="at-article ly-section">
<meta itemprop="dateCreated" content="2015-08-25T20:04:25+00:00" />
<meta itemprop="datePublished" content="2015-08-26T14:00:01+00:00" />
<meta itemprop="dateModified" content="2015-10-11T04:06:36+00:00" />
<meta itemprop="keywords" content="es6,history-lesson,traceur,babel,es6-in-depth" />
<section itemprop="articleBody" class="at-corpus">
<section itemprop="about" class="md-markdown at-introduction">
    <p>For the most part, we have Browserify, Babel and the spec being finalized to thank for. But we didn’t always have these tools and they weren’t born as mature as they are today.</p>
    <p> <a href="http://babeljs.io/">
    <img src="./auxi/babel.png" alt="Babel JavaScript Compiler"></a></p>
</section>
<section class="md-markdown at-body">

<p>Before <strong>JavaScript-to-JavaScript </strong> transpilers became a<em> (serious)</em> thing, there were modules that would add specific bits of ES6 functionality to your apps. There were things like <a href="https://github.com/TooTallNate/gnode" aria-label="TooTallNate/gnode on GitHub"> <code class="md-code md-code-inline">gnode</code></a>, which allows you to use generators in <code class="md-code md-code-inline">node</code>  by interpreting your code during runtime<em>(or turning on the Harmony flag for generators in <code class="md-code md-code-inline">node &gt;= 0.11.x</code> )</em></p>
    <blockquote>
    <p><em>Trivia question: how many different names has ES6 accrued over the years?</em></p>
    </blockquote>

<p>Then we also started to see libraries that implemented ES6 module loading, such as<a href="https://github.com/ModuleLoader/es6-module-loader" aria-label="ModuleLoader/es6-module-loader on GitHub"> <code class="md-code md-code-inline">es6-module-loader</code> </a>. These libraries helped advance the spec by giving developers something to chew on as implementations started cropping up. Of course, you could always use CoffeeScript or TypeScript back then which had implemented language features equivalent to those in ES6.</p>

<p>I didn’t care for the syntax in CoffeeScript, nor the fact that it would’ve effectively reduced my ability to <a href="http://bevacqua.io/opensource" aria-label="I contribute on many open-source modules">contribute to open-source</a>, so that one was out. TypeScript would’ve been okay but it has many features on top of what’s coming with ES6, and<em>where possible</em> I try to learn things that will be <strong>useful to me for a long time </strong>. That being said, both of these languages contributed to the shaping of ES6, so we have them to thank for that. There’s also the fact that for a long time, they were as close as you could get to trying a language with anything resembling the features in ES6.</p>

<p>Eventually, transpilers made an appearance. The first one was <a href="https://github.com/google/traceur-compiler" aria-label="google/traceur-compiler on GitHub">Traceur</a>, and it came out around a time where the spec wasn’t locked down yet. It was constantly changing so it wasn’t a very good idea to try and use it for more than a few minutes to toy around with the syntax. I got frustrated very quickly while writing <a href="https://github.com/buildfirst/buildfirst/tree/master/ch05/17_harmony-traceur" aria-label="&#39;Harmony through Traceur, using Grunt&#39; code sample for JavaScript Application Design">example code</a> for my <a href="http://bevacquia.io/buildfirst" aria-label="JavaScript Application Design">application design book</a>. Around the same time, <a href="https://www.npmjs.com/package/6to5" aria-label="6to5 on npm">6to5</a> started making waves and there was also <a href="https://github.com/esnext/esnext" aria-label="esnext/esnext on GitHub"> <code class="md-code md-code-inline">esnext</code> </a>, but <code class="md-code md-code-inline">esnext</code>  never implemented ES6 modules. Earlier this year <a href="http://babeljs.io/blog/2015/01/12/6to5-esnext/" aria-label="6to5 + esnext">those projects merged</a> into what we know as <a href="http://babeljs.io/" aria-label="Babel JavaScript Compiler">Babel</a> today.</p>
<blockquote>

<p><em>Come June, <a href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf" aria-label="ECMA-262 6th Edition was standarized on June 2015">the spec was finalized</a>.</em></p>
</blockquote>

<p> <a href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf" aria-label="ECMA-262 6th Edition was standarized on June 2015">
<img alt="ECMAScript 2015 Spec" title="Screen Shot 2015-08-25 at 17.37.57.png" class="js-only" src="./auxi/ecma.png"></a></p>

<p>Locking down the language features was crucial for adoption. It meant that compilers could now finally implement something and<em>not have stale syntax</em> within the next month. The spec being finalized and Babel becoming the de-facto <em>JavaScript-to-JavaScript</em> build tool got me interested in ES6 once again, so I started experimenting with them again.</p>

<p>We now have the ability to mix Browserify and Babel using <code class="md-code md-code-inline">babelify</code> . We can use <code class="md-code md-code-inline">babel-node</code>  on the server during development — <em>and compile to ES5 for production because performance reasons</em>. We can use Webpack if we’re into <a href="http://glenmaddern.com/articles/css-modules" aria-label="CSS Modules article by Glen Maddern">CSS Modules</a>, and there’s a bunch of ES6 features ready for us to use.<em>We need to be careful not to overplay our hand, though.</em> With this much going on, it’s going to be hard trying to keep up while maintaining a high quality codebase that doesn’t get every single new feature and shiny toy crammed into it just because we can.</p>
    <blockquote>

        <p>There’s plenty of room in front-end tooling for feature creep, unfortunately, but <strong>we need to battle against that </strong> now.</p>

        <p>Tomorrow I’ll be publishing an article about the parts of the future of JavaScript I’m most excited about and the concerns I have about mindlessly adopting ES6 features.</p>
    </blockquote>
</section>
</section>

</article>




</div>
<p><a href="#top" class="top"><img src="./auxi/glyphicons-214-up-arrow.png" alt="up-arrow" class="uparrow" /> <b>Back to top</b></a></p>
</section>
</main>
<!--  tooling ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->
<!--  ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->









<!--   destructuring ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->


<main class="ly-main"><header class="at-header">



<h1 itemprop="headline" class="dc-title" id="es6-destructuring-in-depth">ES6 JavaScript Destructuring in Depth</h1></header>
<section class="at-teaser"><div class="at-teaser-markdown md-markdown">

<p>I’ve briefly mentioned a few ES6 features <em>(and how to <a href="https://ponyfoo.com/articles/universal-react-babel#setting-up-babel">get started with Babel</a>)</em> in the React article series I’ve been writing about, and now I want to <strong>focus on the language features</strong> themselves. I’ve read a <em>ton</em> about ES6 and ES7 and it’s about time we started discussing ES6 and ES7 features here in Pony Foo.</p></div></section>
<section class="at-container de-host"><div class="de-column">
    <article itemscope="itemscope" itemtype="http://schema.org/BlogPosting" class="at-article ly-section">
<meta itemprop="dateCreated" content="2015-08-25T16:54:21-04:00"/>
<meta itemprop="datePublished" content="2015-08-27T07:48:01-04:00"/>
<meta itemprop="dateModified" content="2015-10-11T00:06:36-04:00"/>
<meta itemprop="keywords" content="es6,destructuring,es6-in-depth"/>
<section itemprop="articleBody" class="at-corpus">
<section itemprop="about" class="md-markdown at-introduction">
    <p>This article <strong>warns about going overboard</strong> with ES6 language features. Then we’ll start off the series by discussing about Destructuring in ES6, and when it’s most useful, as well as some of its gotchas and caveats.</p>

    <h2 id="a-word-of-caution" class=""><span class="md-heading">A word of caution</span></h2>

    <p>When uncertain, chances are <strong>you probably should default to ES5 and older syntax instead of adopting ES6 just because you can</strong>. By this I don’t mean that using ES6 syntax is a bad idea — quite the opposite, see I’m writing an article about ES6! My concern lies with the fact that when we adopt ES6 features we must do it because <strong>they’ll absolutely improve our code quality</strong>, and not just because of the <em>“cool factor”</em> — whatever that may be.</p>

    <p>The approach I’ve been taking thus far is to write things in <em>plain ES5</em>, and then adding ES6 sugar on top where it’d genuinely improve my code. I presume over time I’ll be able to more quickly identify scenarios where a ES6 feature may be worth using over ES5, but when getting started it might be a good idea <em>not</em> to go overboard too soon. Instead, carefully analyze what would fit your code best first, and <strong>be mindful of adopting ES6</strong>.</p><blockquote>

<p>This way, you’ll <strong>learn to use</strong> the new features in your favor, rather than just <em>learning the syntax</em>.</p></blockquote>

<p>Onto the cool stuff now!</p>
</section>
<section class="md-markdown at-body">
    <h2 id="destructuring"><span class="md-heading">Destructuring</span></h2>

    <p>This is easily one of the features I’ve been using the most. It’s also one of the simplest. It binds properties to as many variables as you need and it works with both Arrays and Objects.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">foo</span> <span class="op">=</span> { bar: <span class="str">'pony'</span>, baz: <span class="num">3</span> }
<span class="kw">var</span> { <span class="var">bar</span>, <span class="var">baz</span> } <span class="op">=</span> <span class="var">foo</span>
<span class="kw4">console.log</span>(<span class="var">bar</span>)
<span class="com">// &lt;- 'pony'</span>
<span class="kw4">console.log</span>(<span class="var">baz</span>)
<span class="com">// &lt;- 3</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>It makes it very quick to pull out a specific property from an object. You’re also allowed to map properties into aliases as well.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">foo</span> <span class="op">=</span> { bar: <span class="str">'pony'</span>, baz: <span class="num">3</span> }
<span class="kw">var</span> { bar: a, baz: b } <span class="op">=</span> <span class="var">foo</span>
<span class="kw4">console.log</span>(a)
<span class="com">// &lt;- 'pony'</span>
<span class="kw4">console.log</span>(b)
<span class="com">// &lt;- 3</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>You can also pull properties as deep as you want, and you could also alias those deep bindings.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">foo</span> <span class="op">=</span> { bar: { deep: <span class="str">'pony'</span>, dangerouslySetInnerHTML: <span class="str">'lol'</span> } }
<span class="kw">var</span> {bar: { deep, dangerouslySetInnerHTML: sure }} <span class="op">=</span> <span class="var">foo</span>
<span class="kw4">console.log</span>(deep)
<span class="com">// &lt;- 'pony'</span>
<span class="kw4">console.log</span>(sure)
<span class="com">// &lt;- 'lol'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>By default, properties that aren’t found will be <code class="md-code md-code-inline">undefined</code>, just like when accessing properties on an object with the dot or bracket notation.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> {foo} <span class="op">=</span> {bar: <span class="str">'baz'</span>}
<span class="kw4">console.log</span>(foo)
<span class="com">// &lt;- undefined</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>If you’re trying to access a deeply nested property of a parent that doesn’t exist, then you’ll get an exception, though.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> {foo:{bar}} <span class="op">=</span> {baz: <span class="str">'ouch'</span>}
<span class="com">// &lt;- Exception</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>That makes a lot of sense, if you think of destructuring as sugar for ES5 like the code below.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">_temp</span> <span class="op">=</span> { baz: <span class="str">'ouch'</span> }
<span class="kw">var</span> <span class="var">bar</span> <span class="op">=</span> <span class="var">_temp</span>.foo.bar
<span class="com">// &lt;- Exception</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>A cool property of destructuring is that it allows you to swap variables without the need for the infamous <code class="md-code md-code-inline">aux</code> variable.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">es5</span> <span class="params">()</span> </span>{
  <span class="kw">var</span> <span class="var">left</span> <span class="op">=</span> <span class="num">10</span>
  <span class="kw">var</span> <span class="var">right</span> <span class="op">=</span> <span class="num">20</span>
  <span class="kw">var</span> <span class="var">aux</span>
  <span class="kw">if</span> (<span class="var">right</span> <span class="op">&gt;</span> <span class="var">left</span>) {
    <span class="var">aux</span> <span class="op">=</span> <span class="var">right</span>
    <span class="var">right</span> <span class="op">=</span> <span class="var">left</span>
    <span class="var">left</span> <span class="op">=</span> <span class="var">aux</span>
  }
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->



<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">es6</span> <span class="params">()</span> </span>{
  <span class="kw">var</span> <span class="var">left</span> <span class="op">=</span> <span class="num">10</span>
  <span class="kw">var</span> <span class="var">right</span> <span class="op">=</span> <span class="num">20</span>
  <span class="kw">if</span> (<span class="var">right</span> <span class="op">&gt;</span> <span class="var">left</span>) {
    <mark class="md-mark md-code-mark">[<span class="var">left</span>, <span class="var">right</span>] <span class="op">=</span> [<span class="var">right</span>, <span class="var">left</span>]</mark>
  }
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Another convenient aspect of destructuring is the ability to pull keys using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names" aria-label="Computed Property Names — MDN">computed property names</a>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">key</span> <span class="op">=</span> <span class="str">'such_dynamic'</span>
<span class="kw">var</span> { <mark class="md-mark md-code-mark">[key]</mark>: foo } <span class="op">=</span> { such_dynamic: <span class="str">'bar'</span> }
<span class="kw4">console.log</span>(foo)
<span class="com">// &lt;- 'bar'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>In ES5, that’d take an extra statement and variable allocation on your behalf.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">key</span> <span class="op">=</span> <span class="str">'such_dynamic'</span>
<span class="kw">var</span> <span class="var">baz</span> <span class="op">=</span> { such_dynamic: <span class="str">'bar'</span> }
<span class="kw">var</span> <span class="var">foo</span> <span class="op">=</span> <span class="var">baz</span>[<span class="var">key</span>]
<span class="kw4">console.log</span>(<span class="var">foo</span>)
<span class="com">// &lt;- 'bar'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>You can also define default values, for the case where the pulled property evaluates to <code class="md-code md-code-inline">undefined</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> {<span class="var">foo</span>=<span class="num">3</span>} <span class="op">=</span> { foo: <span class="num">2</span> }
<span class="kw4">console.log</span>(<span class="var">foo</span>)
<span class="com">// &lt;- 2</span>
<span class="kw">var</span> {<span class="var">foo</span>=<span class="num">3</span>} <span class="op">=</span> { foo: <span class="literal">undefined</span> }
<span class="kw4">console.log</span>(<span class="var">foo</span>)
<span class="com">// &lt;- 3</span>
<span class="kw">var</span> {<span class="var">foo</span>=<span class="num">3</span>} <span class="op">=</span> { bar: <span class="num">2</span> }
<span class="kw4">console.log</span>(<span class="var">foo</span>)
<span class="com">// &lt;- 3</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Destructuring works for Arrays as well, as we mentioned earlier. Note how I’m <strong>using square brackets</strong> in the destructuring side of the declaration now.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> [<span class="var">a</span>] <span class="op">=</span> [<span class="num">10</span>]
<span class="kw4">console.log</span>(<span class="var">a</span>)
<span class="com">// &lt;- 10</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Here, again, we can use the default values and follow the same rules.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> [<span class="var">a</span>] <span class="op">=</span> []
<span class="kw4">console.log</span>(<span class="var">a</span>)
<span class="com">// &lt;- undefined</span>
<span class="kw">var</span> [<span class="var">b</span>=<span class="num">10</span>] <span class="op">=</span> [<span class="literal">undefined</span>]
<span class="kw4">console.log</span>(<span class="var">b</span>)
<span class="com">// &lt;- 10</span>
<span class="kw">var</span> [<span class="var">c</span>=<span class="num">10</span>] <span class="op">=</span> []
<span class="kw4">console.log</span>(<span class="var">c</span>)
<span class="com">// &lt;- 10</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>When it comes to Arrays you can conveniently skip over elements that you don’t care about.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> [,,<span class="var">a</span>,<span class="var">b</span>] <span class="op">=</span> [<span class="num">1</span>,<span class="num">2</span>,<span class="num">3</span>,<span class="num">4</span>,<span class="num">5</span>]
<span class="kw4">console.log</span>(<span class="var">a</span>)
<span class="com">// &lt;- 3</span>
<span class="kw4">console.log</span>(<span class="var">b</span>)
<span class="com">// &lt;- 4</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>You can also use destructuring in a <code class="md-code md-code-inline">function</code>‘s parameter list.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">function</span> <span class="fn">greet</span> ({ age, name:greeting=<span class="str">'she'</span> }) {
  <span class="kw4">console.log</span>(<mark class="md-mark md-code-mark"><span class="str">`${greeting} is ${age} years old.`</span></mark>)
}
<span class="fn">greet</span>({ name: <span class="str">'nico'</span>, age: <span class="num">27</span> })
<span class="com">// &lt;- 'nico is 27 years old'</span>
<span class="fn">greet</span>({ age: <span class="num">24</span> })
<span class="com">// &lt;- 'she is 24 years old'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>That’s roughly <strong>how</strong> you can use destructuring. What is destructuring <strong>good</strong> for?</p>



<h2 id="use-cases-for-destructuring"><span class="md-heading">Use Cases for Destructuring</span></h2>

<p>There are many situations where destructuring comes in handy. Here’s some of the most common ones. Whenever you have a method that returns an object, destructuring makes it much terser to interact with.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">getCoords</span> <span class="params">()</span> </span>{
  <span class="kw3">return</span> {
    x: <span class="num">10</span>,
    y: <span class="num">22</span>
  }
}
<span class="kw">var</span> {<span class="var">x</span>, <span class="var">y</span>} <span class="op">=</span> <span class="fn">getCoords</span>()
<span class="kw4">console.log</span>(<span class="var">x</span>)
<span class="com">// &lt;- 10</span>
<span class="kw4">console.log</span>(<span class="var">y</span>)
<span class="com">// &lt;- 22</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>A similar use case but in the opposite direction is being able to define default options when you have a method with a bunch of options that need default values. This is particularly interesting as an alternative to named parameters in other languages like Python and C#.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">random</span> <span class="params">({ min<span class="op">=</span><span class="num">1</span>, max<span class="op">=</span><span class="num">300</span> })</span> </span>{
  <span class="kw3">return</span> <span class="cls">Math</span>.<span class="built_in">floor</span>(<span class="cls">Math</span>.<span class="built_in">random</span>() <span class="op">*</span> (<span class="param">max</span> <span class="op">-</span> <span class="param">min</span>)) <span class="op">+</span> <span class="param">min</span>
}
<span class="kw4">console.log</span>(<span class="fn">random</span>({}))
<span class="com">// &lt;- 174</span>
<span class="kw4">console.log</span>(<span class="fn">random</span>({<span class="param">max</: <span class="num">24</span>}))
<span class="com">// &lt;- 18</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>If you wanted to make the options object <em>entirely optional</em> you could change the syntax to the following.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">random</span> <span class="params">({ min<span class="op">=</span><span class="num">1</span>, max<span class="op">=</span><span class="num">300</span> }<mark class="md-mark md-code-mark"> <span class="op">=</span> {}</mark>)</span> </span>{
  <span class="kw3">return</span> <span class="cls">Math</span>.<span class="built_in">floor</span>(<span class="cls">Math</span>.<span class="built_in">random</span>() <span class="op">*</span> (<span class="param">max</span> <span class="op">-</span> <span class="param">min</span>)) <span class="op">+</span> <span class="param">min</span>
}
<span class="kw4">console.log</span>(<span class="fn">random</span>())
<span class="com">// &lt;- 133</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>A great fit for destructuring are things like regular expressions, where you would just love to name parameters without having to resort to index numbers. Here’s an example parsing a URL with a random <code class="md-code md-code-inline">RegExp</code> <a href="http://stackoverflow.com/a/27755/389745" aria-label="Getting parts of a URL on StackOverflow">I got on StackOverflow</a>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">getUrlParts</span> <span class="params">(url)</span> </span>{
  <span class="kw">var</span> <span class="var">magic</span> <span class="op">=</span> <span class="md-code-regexp">/^(https?):\/\/(ponyfoo\.com)(\/articles\/([a-z0-9-]+))$/</span>
  <span class="kw3">return</span> <span class="var">magic</span>.<span class="built_in">exec</span>(<span class="param">url</span>)
}
<span class="kw">var</span> <span class="var">parts</span> <span class="op">=</span> <span class="fn">getUrlParts</span>(<span class="str">'http://ponyfoo.com/articles/es6-destructuring-in-depth'</span>)
<span class="kw">var</span> [,<span class="var">protocol</span>,<span class="var">host</span>,<span class="var">pathname</span>,<span class="var">slug</span>] <span class="op">=</span> <span class="var">parts</span>
<span class="kw4">console.log</span>(<span class="var">protocol</span>)
<span class="com">// &lt;- 'http'</span>
<span class="kw4">console.log</span>(<span class="var">host</span>)
<span class="com">// &lt;- 'ponyfoo.com'</span>
<span class="kw4">console.log</span>(<span class="var">pathname</span>)
<span class="com">// &lt;- '/articles/es6-destructuring-in-depth'</span>
<span class="kw4">console.log</span>(<span class="var">slug</span>)
<span class="com">// &lt;- 'es6-destructuring-in-depth'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->




<h3 id="special-case-import-statements"><span class="md-heading">Special Case: <code class="md-code md-code-inline">import</code> Statements</span></h3>

<p>Even though <code class="md-code md-code-inline">import</code> statements don’t follow destructuring rules, they behave a bit similarly. This is probably the <em>“destructuring-like”</em> use case I find myself using the most, even though it’s not actually destructuring. Whenever you’re writing module <code class="md-code md-code-inline">import</code> statements, you can pull just what you need from a module’s public API. An example using <a href="https://github.com/bevacqua/contra" aria-label="bevacqua/contra on GitHub"><code class="md-code md-code-inline">contra</code></a>:</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">import</span> {series, concurrent, map } <span class="kw">from</span> <span class="str">'contra'</span>
series(tasks, done)
concurrent(tasks, done)
map(items, mapper, done)
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Note that, however, <code class="md-code md-code-inline">import</code> statements have a different syntax. When compared against destructuring, none of the following <code class="md-code md-code-inline">import</code> statements will work.</p>

<ul>
  <li>Use defaults values such as <code class="md-code md-code-inline">import {series = noop} from 'contra'</code></li>

<li>“Deep” destructuring style like <code class="md-code md-code-inline">import {map: { series }} from 'contra'</code></li>

<li>Aliasing syntax <code class="md-code md-code-inline">import {map: mapAsync} from 'contra'</code></li></ul>

<p>The main reason for these limitations is that the <code class="md-code md-code-inline">import</code> statement brings in a <em>binding</em>, and not a reference or a value. This is an important differentiation that we’ll explore more in depth in a future article about ES6 modules.</p>

<blockquote>

<p>I’ll keep posting about ES6 &amp; ES7 features every day, so make sure to subscribe if you want to know more!</p></blockquote>

<p><sub>* How about we visit string interpolation tomorrow?</sub><br>
<sub>** We’ll leave arrow functions for Monday!</sub></p>

</section>
</section>

</article>
</div>
<p><a href="#top" class="top"><img src="./auxi/glyphicons-214-up-arrow.png" alt="up-arrow" class="uparrow" /> <b>Back to top</b></a></p></section>
</main>

<!--  destructuring ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->
<!--  ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->









<!--  Template Literals ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->
<main class="ly-main">
<header class="at-header">
<h1 itemprop="headline" class="dc-title" id="es6-template-strings-in-depth">ES6 Template Literals in Depth</h1>
</header>

<section class="at-teaser"><div class="at-teaser-markdown md-markdown">

<p>Yesterday we covered <a href="#es6-destructuring-in-depth">ES6 destructuring in depth</a>, as well as some of its most common use cases. Today we’ll be moving to <strong>template literals</strong>. What they are, and how we can use them and what good they’re for.</p></div></section>

<section class="at-container de-host"><div class="de-column"><article itemscope="itemscope" itemtype="http://schema.org/BlogPosting" class="at-article ly-section">
<meta itemprop="dateCreated" content="2015-08-26T20:10:57+00:00" />
<meta itemprop="datePublished" content="2015-08-28T11:24:01+00:00" />
<meta itemprop="dateModified" content="2015-10-13T14:24:26+00:00" />
<meta itemprop="keywords" content="es6,template-literals,es6-in-depth" />

<section itemprop="articleBody" class="at-corpus">

<section itemprop="about" class="md-markdown at-introduction">

<p>Template literals are a new feature in ES6 to make working with strings and string templates easier. You wrap your text in <code class="md-code md-code-inline">`backticks`</code> and you’ll get the features described below.</p><ul>
  <li>You can interpolate variables in them</li>
  <li>You can actually interpolate using <em>any kind of expression</em>, not just variables</li>
  <li>They can be <strong>multi-line</strong>. <em>Finally!</em></li>
  <li>You can construct <em>raw templates</em> that don’t interpret backslashes</li></ul>

<p>In addition, you can also define <em>a method</em> that will decide what to make of the template, instead of using the default templating behavior. There are some interesting use cases for this one.</p><blockquote>

<p>Let’s dig into template literals and see what we can come up with.</p></blockquote></section>

<section class="md-markdown at-body">



<h2 id="using-template-literals"><span class="md-heading">Using Template Literals</span></h2>

<p>We’ve already covered the basic <em><code class="md-code md-code-inline">`I'm just a string`</code></em>. One aspect of template literals that may be worth mentioning is that you’re now able to declare strings with both <code class="md-code md-code-inline">'</code> and <code class="md-code md-code-inline">"</code> quotation marks in them without having to escape anything.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">text</span> <span class="op">=</span> <span class="str">`I'm "amazed" that we have so many quotation marks to choose from!`</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>That was neat, but surely there’s more useful stuff we can apply template literals to. How about some <em>actual interpolation</em>? You can use the <code class="md-code md-code-inline">${expression}</code> notation for that.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">host</span> <span class="op">=</span> <span class="str">'ponyfoo.com'</span>
<span class="kw">var</span> <span class="var">text</span> <span class="op">=</span> <span class="str">`this blog lives at <mark class="md-mark md-code-mark"><span class="tmp-lit">${</span><span class="var">host</span><span class="tmp-lit">}</span></mark>`</span>
<span class="kw4">console.log</span>(<span class="var">text</span>)
<span class="com">// &lt;- 'this blog lives at ponyfoo.com'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>I’ve already mentioned you can have any kind of expressions you want in there. Think of whatever expressions you put in there as defining a variable before the template runs, and then concatenating that value with the rest of the string. That means that variables you use, methods you call, and so on, should all be available to the current scope.</p>

<p>The following expressions would all work just as well. It’ll be up to us to decide how much logic we cram into the interpolation expressions.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">text</span> <span class="op">=</span> <span class="str">`this blog lives at <span class="tmp-lit">${</span><span class="str">'ponyfoo.com'</span><span class="tmp-lit">}</span>`</span>
<span class="kw4">console.log</span>(<span class="var">text</span>)
<span class="com">// &lt;- 'this blog lives at ponyfoo.com'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->



<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">today</span> <span class="op">=</span> <span class="kw">new</span> <span class="date">Date</span>()
<span class="kw">var</span> <span class="var">text</span> <span class="op">=</span> <span class="str">`the time and date is <span class="tmp-lit">${</span><span class="var">today</span>.toLocaleString()<span class="tmp-lit">}</span>`</span>
<span class="kw4">console.log</span>(<span class="var">text</span>)
<span class="com">// &lt;- 'the time and date is 8/26/2015, 3:15:20 PM'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->



<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">import</span> moment <span class="kw">from</span> <span class="str">'moment'</span>
<span class="kw">var</span> <span class="var">today</span> <span class="op">=</span> <span class="kw">new</span> <span class="date">Date</span>()
<span class="kw">var</span> <span class="var">text</span> <span class="op">=</span> <span class="str">`today is the <span class="tmp-lit">${</span>moment(<span class="var">today</span>).format(<span class="str">'Do [of] MMMM'</span>)<span class="tmp-lit">}</span>`</span>
<span class="kw4">console.log</span>(<span class="var">text</span>)
<span class="com">// &lt;- 'today is the 26th of August'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->



<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">text</span> <span class="op">=</span> <span class="str">`such <span class="tmp-lit">${</span>Infinity/<span class="num">0</span><span class="tmp-lit">}</span>, very uncertain`</span>
<span class="kw4">console.log</span>(<span class="var">text</span>)
<span class="com">// &lt;- 'such Infinity, very uncertain'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Multi-line strings mean that you no longer have to use methods like these anymore.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">text</span> <span class="op">=</span> (
  <span class="str">'foo\n'</span> +
  <span class="str">'bar\n'</span> +
  <span class="str">'baz'</span>
)
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->



<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">text</span> <span class="op">=</span> [
  <span class="str">'foo'</span>,
  <span class="str">'bar'</span>,
  <span class="str">'baz'</span>
].<span class="built_in">join</span>(<span class="str">'\n'</span>)
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Instead, you can now just use backticks! Note that spacing matters, so you might still want to use parenthesis in order to keep the first line of text away from the variable declaration.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">text</span> <span class="op">=</span> (
<span class="str">`foo
bar
baz`</span>)
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Multi-line strings really shine when you have, <em>for instance</em>, a chunk of HTML you want to interpolate some variables to. Much like with <a href="#react-jsx-and-es6-the-weird-parts" aria-label="React, JSX and ES6: The Weird Parts on Pony Foo">JSX</a>, you’re perfectly able to use an expression to iterate over a collection and <code class="md-code md-code-inline">return</code> yet another template literal to declare list items. This makes it a breeze to declare sub-components in your templates. Note also how I’m <a href="#es6-destructuring-in-depth" aria-label="ES6 JavaScript Destructuring in Depth">using destructuring</a> to avoid having to prefix every expression of mine with <code class="md-code md-code-inline">article.</code>, I like to think of it as <em>“a <code class="md-code md-code-inline">with</code> block, but not as insane”</em>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">article</span> <span class="op">=</span> {
  title: <span class="str">'Hello Template Literals'</span>,
  teaser: <span class="str">'String interpolation is awesome. Here are some features'</span>,
  body: <span class="str">'Lots and lots of sanitized HTML'</span>,
  tags: [<span class="str">'es6'</span>, <span class="str">'template-literals'</span>, <span class="str">'es6-in-depth'</span>]
}
<span class="kw">var</span> {<span class="var">title</span>,<span class="var">teaser</span>,<span class="var">body</span>,<span class="var">tags</span>} <span class="op">=</span> <span class="var">article</span>
<span class="kw">var</span> <span class="var">html</span> <span class="op">=</span> `<span class="md-code-tag">&lt;<span class="tag-name">article</span>&gt;</span>
  <span><span class="md-code-tag">&lt;<span class="tag-name">header</span>&gt;</span>
    <span class="md-code-tag">&lt;<span class="tag-name">h1</span>&gt;</span><span class="tmp-lit">${</span><span class="var">title</span><span class="tmp-lit">}</span><span class="md-code-tag">&lt;/<span class="tag-name">h1</span>&gt;</span>
  <span class="md-code-tag">&lt;/<span class="tag-name">header</span>&gt;</span>
  <span class="md-code-tag">&lt;<span class="tag-name">section</span>&gt;</span>
    <span class="md-code-tag">&lt;<span class="tag-name">div</span>&gt;</span><span class="tmp-lit">${</span><span class="var">teaser</span><span class="tmp-lit">}</span><span class="md-code-tag">&lt;/<span class="tag-name">div</span>&gt;</span>
    <span class="md-code-tag">&lt;<span class="tag-name">div</span>&gt;</span><span class="tmp-lit">${</span><span class="var">body</span><span class="tmp-lit">}</span><span class="md-code-tag">&lt;/<span class="tag-name">div</span>&gt;</span>
  <span class="md-code-tag">&lt;/<span class="tag-name">section</span>&gt;</span>
  <span class="md-code-tag">&lt;<span class="tag-name">footer</span>&gt;</span>
    <span class="md-code-tag">&lt;<span class="tag-name">ul</span>&gt;</span>
      <mark class="md-mark md-code-mark"><span class="tmp-lit">${</span><span class="var">tags</span>.<span class="kw">map</span>(tag <span class="op">=&gt;</span> `<span class="md-code-tag">&lt;<span class="tag-name">li</span>&gt;</span><span class="tmp-lit">${</span>tag<span class="tmp-lit">}</span><span class="md-code-tag">&lt;/<span class="tag-name">li</span>&gt;</span>`).<span class="built_in">join</span>(<span class="str">'\n      '</span>)<span class="tmp-lit">}</span></mark>
    <span class="md-code-tag">&lt;/<span class="tag-name">ul</span>&gt;</span>
  <span class="md-code-tag">&lt;/<span class="tag-name">footer</span>&gt;</span>
<span class="md-code-tag">&lt;/<span class="tag-name">article</span>&gt;</span>`
</span></code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The above will produce output as shown below. Note how the spacing trick was enough to properly indent the <code class="md-code md-code-inline">&lt;li&gt;</code> tags.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-xml"><span class="md-code-tag">&lt;<span class="tag-name">article</span>&gt;</span>
  <span class="md-code-tag">&lt;<span class="tag-name">header</span>&gt;</span>
    <span class="md-code-tag">&lt;<span class="tag-name">h1</span>&gt;</span>Hello Template Literals<span class="md-code-tag">&lt;/<span class="tag-name">h1</span>&gt;</span>
  <span class="md-code-tag">&lt;/<span class="tag-name">header</span>&gt;</span>
  <span class="md-code-tag">&lt;<span class="tag-name">section</span>&gt;</span>
    <span class="md-code-tag">&lt;<span class="tag-name">div</span>&gt;</span>String interpolation is awesome. Here are some features<span class="md-code-tag">&lt;/<span class="tag-name">div</span>&gt;</span>
    <span class="md-code-tag">&lt;<span class="tag-name">div</span>&gt;</span>Lots and lots of sanitized HTML<span class="md-code-tag">&lt;/<span class="tag-name">div</span>&gt;</span>
  <span class="md-code-tag">&lt;/<span class="tag-name">section</span>&gt;</span>
  <span class="md-code-tag">&lt;<span class="tag-name">footer</span>&gt;</span>
    <span class="md-code-tag">&lt;<span class="tag-name">ul</span>&gt;</span>
      <span class="md-code-tag">&lt;<span class="tag-name">li</span>&gt;</span>es6<span class="md-code-tag">&lt;/<span class="tag-name">li</span>&gt;</span>
      <span class="md-code-tag">&lt;<span class="tag-name">li</span>&gt;</span>template-literals<span class="md-code-tag">&lt;/<span class="tag-name">li</span>&gt;</span>
      <span class="md-code-tag">&lt;<span class="tag-name">li</span>&gt;</span>es6-in-depth<span class="md-code-tag">&lt;/<span class="tag-name">li</span>&gt;</span>
    <span class="md-code-tag">&lt;/<span class="tag-name">ul</span>&gt;</span>
  <span class="md-code-tag">&lt;/<span class="tag-name">footer</span>&gt;</span>
<span class="md-code-tag">&lt;/<span class="tag-name">article</span>&gt;</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Raw templates are the same in essence, you just have to prepend your template literal with <code class="md-code md-code-inline">String.raw</code>. This can be very convenient in some use cases.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">text</span> <span class="op">=</span> <span class="kw">String.<span class="built_in">raw</span></span><span class="str">`The "\n" newline won't result in a new line.
It'll be escaped.`</span>
<span class="kw4">console.log</span>(<span class="var">text</span>)
<span class="com">// The "\n" newline won't result in a new line.
// It'll be escaped.</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>You might’ve noticed that <code class="md-code md-code-inline">String.raw</code> seems to be a special part of the template literal syntax, and you’d be right! The method you choose will be used to parse the template. Template literal methods — called <em>“tagged templates”</em> — receive an array containing a list of the static parts of the template, as well as each expression on their own variables.</p>

<p>For instance a template literal like <code class="md-code md-code-inline">`hello ${name}. I am ${emotion}!`</code> will pass arguments to the <em>“tagged template”</em> in a function call like the one below.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">fn([<span class="str">'hello '</span>, <span class="str">'. I am'</span>, <span class="str">'!'</span>], <span class="str">'nico'</span>, <span class="str">'confused'</span>)
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>You might be confused by the seeming oddity in which the arguments are laid out, but they start to make sense when you think of it this way: for every item in the template array, there’s an expression result after it.</p>



<h2 id="demystifying-tagged-templates"><span class="md-heading">Demystifying Tagged Templates</span></h2>

<p>I wrote an example <code class="md-code md-code-inline">normal</code> method below, and it works <em>exactly like the default behavior</em>. This might help you better understand what happens under the hood for template literals.</p><blockquote>

<p>If you don’t know what <code class="md-code md-code-inline">.reduce</code> does, refer to <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce" aria-label="Array.prototype.reduce() — MDN">MDN</a> or my <a href="#fun-with-native-arrays#computing-with-reduce-reduceright" aria-label="Computing with .reduce, .reduceRight on Pony Foo">“Fun with Native Arrays”</a> article. Reduce is always useful when you’re trying to map a collection of values into a single value that can be computed from the collection.</p></blockquote>

<p>In this case we can reduce the <code class="md-code md-code-inline">template</code> starting from <code class="md-code md-code-inline">template[0]</code> and then reducing all other parts by adding the preceding <code class="md-code md-code-inline">expression</code> and the subsequent <code class="md-code md-code-inline">part</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">normal</span> <span class="params">(template, <mark class="md-mark md-code-mark"><span class="op">...</span>expressions</mark>)</span> </span>{
  <span class="kw3">return</span> <span class="param">template</span>.<span class="built_in">reduce</span>((accumulator, part, i) <span class="op">=&gt;</span> {
    <span class="kw3">return</span> accumulator <span class="op">+</span> <span class="param">expressions</span>[i <span class="op">-</span> <span class="num">1</span>] <span class="op">+</span> part
  })
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The <code class="md-code md-code-inline">...expressions</code> syntax is new in ES6 as well. It’s called the <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/rest_parameters" aria-label="Rest parameters in ES6 — MDN"><em>“rest parameters syntax”</em></a>, and it’ll basically place all the arguments passed to <code class="md-code md-code-inline">normal</code> that come after <code class="md-code md-code-inline">template</code> into a single array. You can try the tagged template as seen below, and you’ll notice you get the same output as if you omitted <code class="md-code md-code-inline">normal</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">name</span> <span class="op">=</span> <span class="str">'nico'</span>
<span class="kw">var</span> <span class="var">outfit</span> <span class="op">=</span> <span class="str">'leather jacket'</span>
<span class="kw">var</span> <span class="var">text</span> <span class="op">=</span> <mark class="md-mark md-code-mark"><span class="fn">normal</span></mark><span class="str">`hello <span class="tmp-lit">${</span><span class="var">name</span><span class="tmp-lit">}</span>, you look lovely today in that <span class="tmp-lit">${</span><span class="var">outfit</span><span class="tmp-lit">}</span>`</span>
<span class="kw4">console.log</span>(<span class="var">text</span>)
<span class="com">// &lt;- 'hello nico, you look lovely today in that leather jacket'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Now that we’ve figured out how tagged templates work, what can we do with them? Well, whatever we want. One possible use case might be to make user input uppercase, turning our greeting into something that sounds more satirical — <em>I read the result out loud in my head with Gob’s voice from Arrested Development, now I’m laughing alone. I’ve made a huge mistake</em>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">upperExpr</span> <span class="params">(template, <span class="op">...</span>expressions)</span> </span>{
  <span class="kw3">return</span> <span class="param">template</span>.<span class="built_in">reduce</span>((accumulator, part, i) <span class="op">=&gt;</span> {
    <span class="kw3">return</span> accumulator <span class="op">+</span> <span class="param">expressions</span>[i <span class="op">-</span> <span class="num">1</span>].<span class="built_in">toUpperCase</span>() <span class="op">+</span> part
  })
}
<span class="kw">var</span> <span class="var">name</span> <span class="op">=</span> <span class="str">'nico'</span>
<span class="kw">var</span> <span class="var">outfit</span> <span class="op">=</span> <span class="str">'leather jacket'</span>
<span class="kw">var</span> <span class="var">text</span> <span class="op">=</span> <mark class="md-mark md-code-mark"><span class="fn">upperExpr</span></mark><span class="str">`hello <span class="tmp-lit">${</span><span class="var">name</span><span class="tmp-lit">}</span>, you look lovely today in that <span class="tmp-lit">${</span><span class="var">outfit</span><span class="tmp-lit">}</span>`</span>
<span class="kw4">console.log</span>(<span class="var">text</span>)
<span class="com">// &lt;- 'hello NICO, you look lovely today in that LEATHER JACKET'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>There are obviously much more useful use cases for tagged templates than laughing at yourself. In fact, you could go crazy with tagged templates. A decidedly useful use case would be to sanitize user input in your templates automatically. Given a template where all expressions are considered user-input, we could use <a href="https://github.com/bevacqua/insane" aria-label="bevacqua/insane on GitHub"><code class="md-code md-code-inline">insane</code></a> to sanitize them out of HTML tags we dislike.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">import</span> insane <span class="kw">from</span> <span class="str">'insane'</span>
<span class="kw">function</span> <span class="fn">sanitize</span> <span class="params">(template, <span class="op">...</span>expressions)</span> {
  <span class="kw3">return</span> <span class="param">template</span>.<span class="built_in">reduce</span>((accumulator, part, i) <span class="op">=&gt;</span> {
    <span class="kw3">return</span> accumulator <span class="op">+</span> <mark class="md-mark md-code-mark">insane</mark>(<span class="param">expressions</span>[i <span class="op">-</span> 1]) <span class="op">+</span> part
  })
}
<span class="kw">var</span> <span class="var">comment</span> <span class="op">=</span> <span class="str">'haha xss is so easy <mark class="md-mark md-code-mark">&lt;iframe src="http://evil.corp"&gt;&lt;/iframe&gt;</mark>'</span>
<span class="kw">var</span> <span class="var">html</span> <span class="op">=</span> <mark class="md-mark md-code-mark"><span class="fn">sanitize</span></mark><span class="str">`&lt;div&gt;<span class="tmp-lit">${</span><span class="var">comment</span><span class="tmp-lit">}</span>&lt;/div&gt;`</span>
<span class="kw4">console.log</span>(<span class="var">html</span>)
<span class="com">// &lt;- '&lt;div&gt;haha xss is so easy &lt;/div&gt;'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p><em>Not so easy now!</em></p><blockquote>

<p>I can definitely see a future where the only strings I use in JavaScript begin and finish with a backtick.</p></blockquote></section></section>



</article>



</div>
<p><a href="#top" class="top"><img src="./auxi/glyphicons-214-up-arrow.png" alt="up-arrow" class="uparrow" /> <b>Back to top</b></a></p></section>
</main>

<!--  Template Literals ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->
<!--  ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->









<!--  Arrow Functions ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->
<main class="ly-main">
<header class="at-header">



<h1 itemprop="headline" class="dc-title" id="es6-arrow-functions-in-depth">ES6 Arrow Functions in Depth</h1></header>

<section class="at-teaser"><div class="at-teaser-markdown md-markdown">

<p>The daily saga of es6-in-depth articles continues. Today we’ll be discussing Arrow Functions. In previous articles we’ve covered <a href="#es6-destructuring-in-depth">destructuring</a> and <a href="#es6-template-strings-in-depth">template literals</a>. I strive to cover <em>all the things</em> when it comes to the ES6 feature-set — and eventually we’ll move onto ES7. I find that writing about these features makes it way easier for them to become <strong>engraved in my skull</strong> as well.</p></div></section>

<section class="at-container de-host"><div class="de-column">

<article itemscope="itemscope" itemtype="http://schema.org/BlogPosting" class="at-article ly-section">
<meta itemprop="dateCreated" content="2015-08-26T22:02:55+00:00" />
<meta itemprop="datePublished" content="2015-08-31T11:42:01+00:00" />
<meta itemprop="dateModified" content="2015-10-11T04:06:36+00:00" />
<meta itemprop="keywords" content="es6,arrow-functions,es6-in-depth" />

<section itemprop="articleBody" class="at-corpus">

<section itemprop="about" class="md-markdown at-introduction">

<p>Since you’re reading these articles, I suggest you <a href="#universal-react-babel#setting-up-babel">set up Babel and <code class="md-code md-code-inline">babel-node</code></a>, and follow along by copying the self-contained examples into a file. You can then run them using <code class="md-code md-code-inline">babel-node yourfile</code> in the terminal. Running these examples on your own and maybe tweaking them a little bit <strong>will help you better internalize these new features</strong> — even if you’re just adding <code class="md-code md-code-inline">console.log</code> statements to figure out what’s going on.</p><blockquote>

<p>Now onto the topic of the day.</p></blockquote>

<p>We’ve already gone over <em>arrow functions</em> a little in previous articles, using them in passing without a lot of explaining going on. This article will focus mainly in arrow functions and keep the rest of ES6 in the back burner. I think that’s the best way to write about ES6 — making a single feature “stand out” in each article, and gradually adding the others and interconnecting the different concepts so that we can understand <em>how they interact together</em>. I’ve observed <strong>a lot of synergy</strong> in ES6 features, which is <em>awesome</em>. It’s still important to make a gradual dive into ES6 syntax and features and not jump into the water as it’s warming up, because otherwise you’ll have a bad time adjusting to the new temperature — that was probably a bad analogy, moving on.</p></section>

<section class="md-markdown at-body">



<h2 id="using-arrow-functions-in-javascript"><span class="md-heading">Using Arrow Functions in JavaScript</span></h2>

<p>Arrow functions are available to many other modern languages and was one of the features I sorely missed a few years ago when I moved from C# to JavaScript. Fortunately, they’re now part of ES6 and thus available to us in JavaScript. The syntax is quite expressive. We already had anonymous functions, but sometimes it’s nice to have a terse alternative.</p>

<p>Here’s what the syntax looks like if we have a single argument and just want to return the results for an expression.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>].<span class="kw">map</span>(num <span class="op">=&gt;</span> num <span class="op">*</span> <span class="num">2</span>)
<span class="com">// &lt;- [2, 4, 6]</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The ES5 equivalent would be as below.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>].<span class="kw">map</span>(<span class="md-code-function"><span class="kw">function</span> <span class="params">(num)</span> </span>{ <span class="kw3">return</span> <span class="param">num</span> <span class="op">*</span> <span class="num">2</span> })
<span class="com">// &lt;- [2, 4, 6]</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>If we need to declare more arguments <em>(or no arguments)</em>, we’ll have to use parenthesis.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>].<span class="kw">map</span>((num, index) <span class="op">=&gt;</span> num <span class="op">*</span> <span class="num">2</span> <span class="op">+</span> index)
<span class="com">// &lt;- [2, 5, 8, 11]</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>You might want to have some other statements and not just an expression to return. In this case you’ll have to use bracket notation.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>].<span class="kw">map</span>(num <span class="op">=&gt;</span> {
  <span class="kw">var</span> <span class="var">multiplier</span> <span class="op">=</span> <span class="num">2</span> <span class="op">+</span> num
  <span class="kw3">return</span> num <span class="op">*</span> <span class="var">multiplier</span>
})
<span class="com">// &lt;- [3, 8, 15, 24]</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>You could also add more arguments with the parenthesis syntax here.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>].<span class="kw">map</span>((num, index) <span class="op">=&gt;</span> {
  <span class="kw">var</span> <span class="var">multiplier</span> <span class="op">=</span> <span class="num">2</span> <span class="op">+</span> index
  <span class="kw3">return</span> num <span class="op">*</span> <span class="var">multiplier</span>
})
<span class="com">// &lt;- [2, 6, 12, 20]</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>At that point, however, chances are you’d be better off using a named function declaration for a number of reasons.</p><ul>
  <li><code class="md-code md-code-inline">(num, index) =&gt;</code> is only marginally shorter than <code class="md-code md-code-inline">function (num, index)</code></li>
  <li>The <code class="md-code md-code-inline">function</code> form allows you to name the method, improving code quality</li>
  <li>When a function has multiple arguments and multiple statements, I’d say it’s improbable that six extra characters will make a difference</li>
  <li>However, naming the method might add just enough context into the equation that those six extra characters (plus method name) become really worthwhile</li></ul>

<p>Moving on, if we need to return an object literal, we’ll have to wrap the expression in parenthesis. That way the object literal won’t be interpreted as a statement block (which would result in a silent error or worse, a <strong>syntax error</strong> because <code class="md-code md-code-inline">number: n</code> isn’t a valid expression in the example below. The first example interprets <code class="md-code md-code-inline">number</code> as a label and then figures out we have an <code class="md-code md-code-inline">n</code> expression. Since we’re in a block and not returning anything, the mapped values will be <code class="md-code md-code-inline">undefined</code>. In the second case, after the label and the <code class="md-code md-code-inline">n</code> expression, <code class="md-code md-code-inline">, something: 'else'</code> makes no sense to the compiler, and a <code class="md-code md-code-inline">SyntaxError</code> is thrown.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>].<span class="kw">map</span>(n <span class="op">=&gt;</span> { number: n })
<span class="com">// [undefined, undefined, undefined]</span>
[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>].<span class="kw">map</span>(n <span class="op">=&gt;</span> { number: n, something: <span class="str">'else'</span> })
<span class="com">// &lt;- SyntaxError</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->



<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>].<span class="kw">map</span>(n <span class="op">=&gt;</span> ({ number: n }))
<span class="com">// &lt;- [{ number: 1 }, { number: 2 }, { number: 3 }]</span>
[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>].<span class="kw">map</span>(n <span class="op">=&gt;</span> ({ number: n, something: <span class="str">'else'</span> }))
<span class="com">/* &lt;- [
  { number: 1, something: 'else' },
  { number: 2, something: 'else' },
  { number: 3, something: 'else' }]
*/</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>A cool aspect of arrow functions in ES6 is that they’re bound to their lexical scope. That means that you can say goodbye to <code class="md-code md-code-inline">var self = this</code> and similar hacks <em>— such as using <code class="md-code md-code-inline">.bind(this)</code> –</em> to preserve the context from within deeply nested methods.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">Timer</span> <span class="params">()</span> </span>{
  <span class="kw3">this</span>.<span class="built_in">seconds</span> <span class="op">=</span> <span class="num">0</span>
  <span class="built_in">setInterval</span>(() <span class="op">=&gt;</span> <span class="kw3">this</span>.<span class="built_in">seconds</span><span class="operator">++</span>, <span class="num">1000</span>)
}
<span class="kw">var</span> <span class="var">timer</span> <span class="op">=</span> <span class="kw">new</span> <span class="fn">Timer</span>()
<span class="built_in">setTimeout</span>(() <span class="op">=&gt;</span> <span class="kw4">console.log</span>(<span class="var">timer</span>.<span class="built_in">seconds</span>), <span class="num">3100</span>)
<span class="com">// &lt;- 3</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Keep in mind that the lexical <code class="md-code md-code-inline">this</code> binding in ES6 arrow functions means that <code class="md-code md-code-inline">.call</code> and <code class="md-code md-code-inline">.apply</code> won’t be able to change the context. Usually however, that’s more of a feature than a bug.</p>



<h2 id="conclusions"><span class="md-heading">Conclusions</span></h2>

<p>Arrow functions are neat when it comes to defining anonymous functions that should probably be <em>lexically bound anyways</em>, and they can definitely make your code more terse in some situations.</p>

<p>There’s no reason why you should be turning all of your function declarations into arrow functions unless their arguments and expression body are descriptive enough. I’m a big proponent of named function declarations, because they improve readability of the codebase without the need for comments — which means I’ll have <em>“a hard time”</em> adopting arrow functions in most situations.</p>

<p>That being said, I think arrow functions are particularly useful in most functional programming situations such as when using <code class="md-code md-code-inline">.map</code>, <code class="md-code md-code-inline">.filter</code>, or <code class="md-code md-code-inline">.reduce</code> on collections. Similarly, arrow functions will be really useful in asynchronous flows since those typically have a bunch of callbacks that just do argument balancing, a situation where arrow functions really shine.</p></section></section>
</article>

</div>
<p><a href="#top" class="top"><img src="./auxi/glyphicons-214-up-arrow.png" alt="up-arrow" class="uparrow" /> <b>Back to top</b></a></p>
</section></main>
<!--  Arrow Functions ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->
<!--  ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->









<!--  Spread ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->

<main class="ly-main">
<header class="at-header">



<h1 itemprop="headline" class="dc-title" id="es6-spread-and-butter-in-depth">ES6 Spread and Butter in Depth</h1></header>

<section class="at-teaser"><div class="at-teaser-markdown md-markdown">

<p>Welcome to yet another installment of ES6 in Depth on Pony Foo. Previous ones covered <a href="#es6-destructuring-in-depth">destructuring</a>, <a href="#es6-template-strings-in-depth">template literals</a>, and most recently, <a href="#es6-arrow-functions-in-depth">arrow functions</a>. Today we’ll cover a few more features coming in ES6. Those features are <em>rest parameters, the spread operator, and default parameters.</em></p></div></section>

<section class="at-container de-host"><div class="de-column">

<article itemscope="itemscope" itemtype="http://schema.org/BlogPosting" class="at-article ly-section">
<meta itemprop="dateCreated" content="2015-08-26T22:47:57+00:00" />
<meta itemprop="datePublished" content="2015-09-01T11:06:01+00:00" />
<meta itemprop="dateModified" content="2015-10-11T04:06:36+00:00" />
<meta itemprop="keywords" content="es6,spread,rest,es6-in-depth" />

<section itemprop="articleBody" class="at-corpus">

<section itemprop="about" class="md-markdown at-introduction">

<p>We’ve already covered some of this when we talked <a href="#es6-destructuring-in-depth">about destructuring</a>, which supports default values as a nod to the <strong>synergy in ES6 features</strong> I’ve <a href="#es6-arrow-functions-in-depth">mentioned yesterday</a>. This article might end up being a tad shorter than the rest because there’s not so much to say about these rather simple features. However, and like I’ve mentioned in the first article of the ES6 in Depth series, the simplest features are usually <a href="#es6-destructuring-in-depth#destructuring">the most useful</a> as well. Let’s get on with it!</p></section>

<section class="md-markdown at-body">



<h2 id="rest-parameters"><span class="md-heading">Rest parameters</span></h2>

<p>You know how sometimes there’s a ton of arguments and you end up having to use the <code class="md-code md-code-inline">arguments</code> magic variable to work with them? Consider the following method that joins any arguments passed to it as a string.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">concat</span> <span class="params">()</span> </span>{
  <span class="kw3">return</span> <span class="kw">Array</span>.<span class="built_in">prototype.slice.call</span>(<span class="params">arguments</span>).<span class="built_in">join</span>(<span class="str">' '</span>)
}
<span class="kw">var</span> <span class="var">result</span> <span class="op">=</span> <span class="fn">concat</span>(<span class="str">'this'</span>, <span class="str">'was'</span>, <span class="str">'no'</span>, <span class="str">'fun'</span>)
<span class="kw4">console.log</span>(<span class="var">result</span>)
<span class="com">// &lt;- 'this was no fun'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The rest parameters syntax enables you to pull a real <code class="md-code md-code-inline">Array</code> out of the <code class="md-code md-code-inline">function</code>‘s arguments by adding a parameter name prefixed by <code class="md-code md-code-inline">...</code>. Definitely simpler, the fact that it’s a real <code class="md-code md-code-inline">Array</code> is also very convenient, and I for one am glad not to have to resort to <code class="md-code md-code-inline">arguments</code> anymore.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">concat</span> <span class="params">(<span class="op">...</span>words)</span> </span>{
  <span class="kw3">return</span> <span class="param">words</span>.<span class="built_in">join</span>(<span class="str">' '</span>)
}
<span class="kw">var</span> <span class="var">result</span> <span class="op">=</span> <span class="fn">concat</span>(<span class="str">'this'</span>, <span class="str">'is'</span>, <span class="str">'okay'</span>)
<span class="kw4">console.log</span>(<span class="var">result</span>)
<span class="com">// &lt;- 'this is okay'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>When you have more parameters in your <code class="md-code md-code-inline">function</code> it works slightly different. Whenever I declare a method that has a rest parameter, I like to think of its behavior as follows.</p><ul>
  <li>Rest parameter gets all the <code class="md-code md-code-inline">arguments</code> passed to the function call</li>
  <li>Each time a parameter is added on the left, it’s as if its value is assigned by calling <code class="md-code md-code-inline">rest.shift()</code></li>
  <li>Note that you can’t actually place parameters to the right: rest parameters can only be the last argument</li></ul>

<p>It’s easier to visualize how that would behave than try to put it into words, so let’s do that. The method below computes the <code class="md-code md-code-inline">sum</code> for all <code class="md-code md-code-inline">arguments</code> except the first one, which is then used as a <code class="md-code md-code-inline">multiplier</code> for the <code class="md-code md-code-inline">sum</code>. In case you don’t recall, <code class="md-code md-code-inline">.shift()</code> returns the first value in an array, and also removes it from the collection, which makes it a useful mnemonic device in my opinion.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">sum</span> <span class="params">()</span> </span>{
  <span class="kw">var</span> <span class="var">numbers</span> <span class="op">=</span> <span class="kw">Array</span>.<span class="built_in">prototype.slice.call</span>(<span class="params">arguments</span>) <span class="com">// numbers gets all arguments</span>
  <mark class="md-mark md-code-mark"><span class="kw">var</span> <span class="var">multiplier</span> <span class="op">=</span> <span class="var">numbers</span>.<span class="built_in">shift</span>()</mark>
  <mark class="md-mark md-code-mark"><span class="kw">var</span> <span class="var">base</span> <span class="op">=</span> <span class="var">numbers</span>.<span class="built_in">shift</span>()</mark>
  <span class="kw">var</span> <span class="var">sum</span> <span class="op">=</span> <span class="var">numbers</span>.<span class="built_in">reduce</span>((accumulator, num) <span class="arrow-func">=&gt;</span> accumulator <span class="op">+</span> num, base)
  <span class="kw3">return</span> <span class="var">multiplier</span> <span class="op">*</span> <span class="var">sum</span>
}
<span class="kw">var</span> <span class="var">total</span> <span class="op">=</span> <span class="fn">sum</span>(<span class="num">2</span>, <span class="num">6</span>, <span class="num">10</span>, <span class="num">8</span>, <span class="num">9</span>)
<span class="kw4">console.log</span>(<span class="var">total</span>)
<span class="com">// &lt;- 66</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Here’s how that method would look if we were to use the rest parameter to pluck the numbers. Note how we don’t need to use <code class="md-code md-code-inline">arguments</code> nor do any shifting anymore. This is great because it vastly reduces the complexity in our method — which now can focus on its functionality itself and not so much on rebalancing <code class="md-code md-code-inline">arguments</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">sum</span> <span class="params">(multiplier, base, <mark class="md-mark md-code-mark"><span class="op">...</span>numbers</mark>)</span> </span>{
  <span class="kw">var</span> <span class="var">sum</span> <span class="op">=</span> <span class="param">numbers</span>.<span class="built_in">reduce</span>((accumulator, num) <span class="op">=&gt;</span> accumulator <span class="op">+</span> num, <span class="param">base</span>)
  <span class="kw3">return</span> <span class="param">multiplier</span> <span class="op">*</span> <span class="var">sum</span>
}
<span class="kw">var</span> <span class="var">total</span> <span class="op">=</span> <span class="fn">sum</span>(<span class="num">2</span>, <span class="num">6</span>, <span class="num">10</span>, <span class="num">8</span>, <span class="num">9</span>)
<span class="kw4">console.log</span>(<span class="var"><span class="var">total</span></span>)
<span class="com">// &lt;- 66</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<h2 id="spread-operator"><span class="md-heading">Spread Operator</span></h2>

<p>Typically you invoke a function by passing arguments into it.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw4">console.log</span>(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>)
<span class="com">// &lt;- '1 2 3'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Sometimes however you have those arguments in a list and just don’t want to access every index just for a method call <em>— or you just can’t because the array is formed dynamically –</em> so you use <code class="md-code md-code-inline">.apply</code>. This feels kind of awkward because <code class="md-code md-code-inline">.apply</code> also takes a context for <code class="md-code md-code-inline">this</code>, which feels out of place when it’s not relevant and you have to reiterate the host object <em>(or use <code class="md-code md-code-inline">null</code>)</em>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw4">console.log</span>.<span class="built_in">apply</span>(<span class="built_in">console</span>, [<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>])
<span class="com">// &lt;- '1 2 3'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The spread operator can be used as <em>a butter knife</em> alternative over using <code class="md-code md-code-inline">.apply</code>. There is no need for a context either. You just append three dots <code class="md-code md-code-inline">...</code> to the array, just like with the rest parameter.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw4">console.log</span>(<mark class="md-mark md-code-mark"><span class="op">...</span></mark>[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>])
<span class="com">// &lt;- '1 2 3'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>As we’ll investigate more in-depth next Monday, in the article about iterators in ES6, a nice perk of the spread operator is that it can be used on anything that’s an <em>iterable</em>. This encompasses even things like the results of <code class="md-code md-code-inline">document.querySelectorAll('div')</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="op">...</span><span class="kw">document</span>.querySelectorAll(<span class="str">'div'</span>)]
<span class="com">// &lt;- [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Another nice aspect of the <em>butter knife operator</em> is that you can <strong>mix and match</strong> regular arguments with it, and they’ll be spread over the function call exactly how you’d expect them to. This, too, can be <em>very very useful</em> when you have a lot of argument rebalancing going on in your ES5 code.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw4">console.log</span>(<span class="num">1</span>, <span class="op">...</span>[<span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>], <span class="num">5</span>) <span class="com">// becomes `console.log(1, 2, 3, 4, 5)`</span>
<span class="com">// &lt;- '1 2 3 4 5'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Time for a real-world example. In Express applications, I sometimes use the method below to allow <a href="https://github.com/expressjs/morgan" aria-label="expressjs/morgan on GitHub"><code class="md-code md-code-inline">morgan</code></a> <em>(the request logger in Express)</em> to stream its messages through <a href="https://github.com/winstonjs/winston" aria-label="winstonjs/winston on GitHub"><code class="md-code md-code-inline">winston</code></a>, a general purpose multi-transport logger. I remove the trailing line breaks from the <code class="md-code md-code-inline">message</code> because <code class="md-code md-code-inline">winston</code> already takes care of those. I also place some metadata about the currently executing process like the host and the process <code class="md-code md-code-inline">pid</code> into the arguments list, and then I <code class="md-code md-code-inline">.apply</code> everything on the <code class="md-code md-code-inline">winston</code> logging mechanism. If you take a close look at the code, the only line of code that’s actually doing anything is the one I’ve highlighted; the rest is just playing around with <code class="md-code md-code-inline">arguments</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">createWriteStream</span> <span class="params">(level)</span> </span>{
  <span class="kw3">return</span> {
    write: <span class="md-code-function"><span class="kw">function</span> <span class="params">()</span> </span>{
      <span class="kw">var</span> <span class="var">bits</span> <span class="op">=</span> <span class="kw">Array</span>.<span class="built_in">prototype.slice.call</span>(<span class="params">arguments</span>)
      <span class="kw">var</span> <span class="var">message</span> <span class="op">=</span> <span class="var">bits</span>.<span class="built_in">shift</span>().<span class="built_in">replace</span>(<span class="md-code-regexp">/\n+$/</span>, <span class="str">''</span>) <span class="com">// remove trailing breaks</span>
      <span class="var">bits</span>.<span class="built_in">unshift</span>(<span class="var">message</span>)
      <span class="var">bits</span>.<span class="built_in">push</span>({ hostname: os.hostname(), pid: process.pid })
      <mark class="md-mark md-code-mark">winston[<span class="param">level</span>].<span class="built_in">apply</span>(winston, <span class="var">bits</span>)</mark>
    }
  }
}
app.use(morgan(<span class="str">':status :method :url'</span>, {
  stream: <span class="fn">createWriteStream</span>(<span class="str">'debug'</span>)
}))
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>We can thoroughly simplify the solution with ES6. First, we can use the rest parameter instead of relying on <code class="md-code md-code-inline">arguments</code>. The rest parameter already gives us a true array, so there’s no casting involved either. We can grab the <code class="md-code md-code-inline">message</code> directly as the first parameter, and we can then apply everything on <code class="md-code md-code-inline">winston[level]</code> directly by combining normal arguments with the rest of the <code class="md-code md-code-inline">...bits</code> and pieces. The code below is <strong>in much better shape</strong>, as now every piece of it is actually relevant to what we’re trying to accomplish, which is call <code class="md-code md-code-inline">winston[level]</code> with a few <em>modified arguments</em>. The piece of code we had earlier, in contrast, spent most time manipulating the arguments, and the focus quickly dissipated into <strong>a battle of wits against JavaScript itself</strong> — <em>the method stopped being about the code we were trying to write.</em></p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">createWriteStream</span> <span class="params">(level)</span> </span>{
  <span class="kw3">return</span> {
    write: <span class="md-code-function"><span class="kw">function</span> <span class="params">(message, <mark class="md-mark md-code-mark"><span class="op">...</span>bits</mark>)</span> </span>{
      winston[level](<span class="param">message</span>.<span class="built_in">replace</span>(<span class="md-code-regexp">/\n+$/</span>, <span class="str">''</span>), <mark class="md-mark md-code-mark"><span class="op">...</span><span class="param">bits</span></mark>, {
        hostname: os.hostname(), pid: process.pid
      })
    }
  }
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>We could further <em>simplify the method by pulling</em> the process metadata out, since that won’t change for the lifespan of the process. We could’ve done that in the ES5 code too, though.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">proc</span> <span class="op">=</span> { hostname: os.hostname(), pid: process.pid }
<span class="md-code-function"><span class="kw">function</span> <span class="fn">createWriteStream</span> <span class="params">(level)</span> </span>{
  <span class="kw3">return</span> {
    write: <span class="md-code-function"><span class="kw">function</span> <span class="params">(message, <span class="op">...</span>bits)</span> </span>{
      winston[<span class="param">level</span>](<span class="param">message</span>.<span class="built_in">replace</span>(<span class="md-code-regexp">/\n+$/</span>, <span class="str">''</span>), <span class="op">...</span><span class="param">bits</span>, <span class="var">proc</span>)
    }
  }
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Another thing we could do to shorten that piece of code might be to use <a href="#es6-arrow-functions-in-depth" aria-label="ES6 Arrow Functions in Depth">an arrow function</a>. In this case however, it <strong>would only complicate matters</strong>. You’d have to shorten <code class="md-code md-code-inline">message</code> to <code class="md-code md-code-inline">msg</code> so that it fits in a single line, and the call to <code class="md-code md-code-inline">winston[level]</code> with the rest and spread operators in there makes it <strong>an incredibly complicated sight</strong> to anyone who <em>hasn’t</em> spent the last 15 minutes thinking about the method <em>— be it a team mate or yourself the week after you wrote this function.</em></p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">proc</span> <span class="op">=</span> { hostname: os.hostname(), pid: process.pid }
<span class="md-code-function"><span class="kw">function</span> <span class="fn">createWriteStream</span> <span class="params">(level)</span> </span>{
  <span class="kw3">return</span> {
    write: <span class="params">(msg, <span class="op">...</span>bits)</span> <span class="op">=&gt;</span> winston[<span class="param">level</span>](<span class="param">msg</span>.<span class="built_in">replace</span>(<span class="md-code-regexp">/\n+$/</span>, <span class="str">''</span>), <span class="op">...</span><span class="param">bits</span>, <span class="var">proc</span>)
  }
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>It would be wiser to just keep our earlier version. While it’s <em>quite self-evident</em> in this case that an arrow function only <strong>piles onto the complexity</strong>, in other cases it might not be so. It’s up to you to decide, and you need to be able to distinguish between using ES6 features because they genuinely improve your codebase and its maintainability, or <strong>whether you’re actually decreasing maintainability</strong> by translating things into ES6 just for the sake of doing so.</p>

<p>Some other useful uses are detailed below. You can obviously use the spread operator when creating a new array, but you can also use <a href="#es6-destructuring-in-depth" aria-label="ES6 JavaScript Destructuring in Depth">while destructuring</a>, in which case it works sort of like <code class="md-code md-code-inline">...rest</code> did, and a use case that’s not going to come up often but is still worth mentioning is that you can use spread to pseudo-<code class="md-code md-code-inline">.apply</code> when using the <code class="md-code md-code-inline">new</code> operator as well.</p><table><thead><tr><th>Use Case</th><th>ES5</th><th>ES6</th></tr></thead><tbody><tr><td>Concatenation</td><td><code class="md-code md-code-inline">[1, 2].concat(more)</code></td><td><code class="md-code md-code-inline">[1, 2, ...more]</code></td></tr><tr><td>Push onto list</td><td><code class="md-code md-code-inline">list.push.apply(list, [3, 4])</code></td><td><code class="md-code md-code-inline">list.push(...[3, 4])</code></td></tr><tr><td>Destructuring</td><td><code class="md-code md-code-inline">a = list[0], rest = list.slice(1)</code></td><td><code class="md-code md-code-inline">[a, ...rest] = list</code></td></tr><tr><td><code class="md-code md-code-inline">new</code> + <code class="md-code md-code-inline">apply</code></td><td><a href="http://stackoverflow.com/a/8843181/389745" aria-label="This is insanely unreadable. Avoid."><code class="md-code md-code-inline">new (Date.bind.apply(Date, [null,2015,31,8]))</code></a></td><td><code class="md-code md-code-inline">new Date(...[2015,31,8])</code></td></tr></tbody></table>



<h2 id="default-operator"><span class="md-heading">Default Operator</span></h2>

<p>The default operator is something we’ve covered in <a href="#es6-destructuring-in-depth" aria-label="ES6 JavaScript Destructuring in Depth">the destructuring article</a>, but only tangentially. Just like you can use default values during destructuring, you can define a default value for any parameter in a function, as shown below.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">sum</span> <span class="params">(left<span class="op">=</span><span class="num">1</span>, right<span class="op">=</span><span class="num">2</span>)</span> </span>{
  <span class="kw3">return</span> <span class="param">left</span> <span class="op">+</span> <span class="param">right</span>
}
<span class="kw4">console.log</span>(<span class="fn">sum</span>())
<span class="com">// &lt;- 3</span>
<span class="kw4">console.log</span>(<span class="fn">sum</span>(<span class="num">2</span>))
<span class="com">// &lt;- 4</span>
<span class="kw4">console.log</span>(<span class="fn">sum</span>(<span class="num">1</span>, <span class="num">0</span>))
<span class="com">// &lt;- 1</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Consider the code that initializes options in <a href="https://github.com/bevacqua/dragula/blob/f5f4c569780b0db160269e978eaf69dc36e421bb/dragula.js#L27-L37" aria-label="Option initialization in dragula on GitHub"><code class="md-code md-code-inline">dragula</code></a>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">dragula</span> <span class="params">(options)</span> </span>{
  <span class="kw">var</span> <span class="var">o</span> <span class="op">=</span> <span class="param">options</span> <span class="operator">||</span> {};
  <span class="kw">if</span> (<span class="var">o</span>.moves <span class="op">===</span> <span class="kw">void</span> <span class="num">0</span>) { <span class="var">o</span>.moves <span class="op">=</span> always; }
  <span class="kw">if</span> (<span class="var">o</span>.accepts <span class="op">===</span> <span class="kw">void</span> <span class="num">0</span>) { <span class="var">o</span>.accepts <span class="op">=</span> always; }
  <span class="kw">if</span> (<span class="var">o</span>.invalid <span class="op">===</span> <span class="kw">void</span> <span class="num">0</span>) { <span class="var">o</span>.invalid <span class="op">=</span> invalidTarget; }
  <span class="kw">if</span> (<span class="var">o</span>.containers <span class="op">===</span> <span class="kw">void</span> <span class="num">0</span>) { <span class="var">o</span>.containers <span class="op">=</span> initialContainers || []; }
  <span class="kw">if</span> (<span class="var">o</span>.isContainer <span class="op">===</span> <span class="kw">void</span> <span class="num">0</span>) { <span class="var">o</span>.isContainer <span class="op">=</span> never; }
  <span class="kw">if</span> (<span class="var">o</span>.copy <span class="op">===</span> <span class="kw">void</span> <span class="num">0</span>) { <span class="var">o</span>.copy <span class="op">=</span> <span class="md-code-boolean">false</span>; }
  <span class="kw">if</span> (<span class="var">o</span>.revertOnSpill <span class="op">===</span> <span class="kw">void</span> <span class="num">0</span>) { <span class="var">o</span>.revertOnSpill <span class="op">=</span> <span class="md-code-boolean">false</span>; }
  <span class="kw">if</span> (<span class="var">o</span>.removeOnSpill <span class="op">===</span> <span class="kw">void</span> <span class="num">0</span>) { <span class="var">o</span>.removeOnSpill <span class="op">=</span> <span class="md-code-boolean">false</span>; }
  <span class="kw">if</span> (<span class="var">o</span>.direction <span class="op">===</span> <span class="kw">void</span> <span class="num">0</span>) { <span class="var">o</span>.direction <span class="op">=</span> <span class="str">'vertical'</span>; }
  <span class="kw">if</span> (<span class="var">o</span>.mirrorContainer <span class="op">===</span> <span class="kw">void</span> <span class="num">0</span>) { <span class="var">o</span>.mirrorContainer <span class="op">=</span> body; }
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->
<blockquote>

<p>Do you think it would be useful to switch to default parameters under ES6 syntax? How would you do that?</p></blockquote></section></section>


</article>



</div>
<p><a href="#top" class="top"><img src="./auxi/glyphicons-214-up-arrow.png" alt="up-arrow" class="uparrow" /> <b>Back to top</b></a></p>
</section></main>

<!--  spread ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->
<!--  ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->









<!--  object-literals ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->

<main class="ly-main">
<header class="at-header">



<h1 itemprop="headline" class="dc-title" id="es6-object-literal-features-in-depth">ES6 Object Literal Features in Depth</h1></header>

<section class="at-teaser"><div class="at-teaser-markdown md-markdown">

<p>Once again, this is ES6 in Depth. If you haven’t set foot on this series before, you might want to learn about <a href="#es6-destructuring-in-depth">destructuring</a>, <a href="#es6-template-strings-in-depth">template literals</a>, <a href="#es6-arrow-functions-in-depth">arrow functions</a>, or the <a href="#es6-spread-and-butter-in-depth">spread operator and rest parameters</a>. Today’s special is <em>object literals in ES6.</em> <strong>“Sure, I can use those today”</strong>, you say — object literals date all the way back to ES3. This article is about new features coming in ES6 for object literals.</p></div></section>

<section class="at-container de-host"><div class="de-column">

<article itemscope="itemscope" itemtype="http://schema.org/BlogPosting" class="at-article ly-section">
<meta itemprop="dateCreated" content="2015-08-27T06:33:28+00:00" />
<meta itemprop="datePublished" content="2015-09-02T11:12:01+00:00" />
<meta itemprop="dateModified" content="2015-10-11T04:06:36+00:00" />
<meta itemprop="keywords" content="es6,object-literals,es6-in-depth" />

<section itemprop="articleBody" class="at-corpus">

<section itemprop="about" class="md-markdown at-introduction">

<p>As I did in previous articles on the series, I would love to point out that you should probably <a href="#universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That’ll make it so much easier for you to internalize the concepts discussed in the series. If you aren’t the <em>“install things on my computer”</em> kind of human, you might prefer to hop on <a href="http://codepen.io/">CodePen</a> and then click on the gear icon for JavaScript — <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em></p>

<p>Onto the new stuff!</p></section>

<section class="md-markdown at-body">



<h2 id="property-value-shorthands"><span class="md-heading">Property Value Shorthands</span></h2>

<p>Whenever you find yourself assigning a property value that matches a property name, you can omit the property value, it’s implicit in ES6.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">foo</span> <span class="op">=</span> <span class="str">'bar'</span>
<span class="kw">var</span> <span class="var">baz</span> <span class="op">=</span> { <span class="var">foo</span> }
<span class="kw4">console.log</span>(<span class="var">baz</span>.foo)
<span class="com">// &lt;- 'bar'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>In the snippet shown below I re-implemented part of <code class="md-code md-code-inline">localStorage</code> in memory as a polyfill. It displays a pattern that I’ve followed countless times <a href="https://github.com/bevacqua/local-storage/blob/b9725b0fc77faabc737ba7c6ee57d343afa95102/stub.js#L3-L32" aria-label="See bevacqua/local-storage on GitHub">in my code</a>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">ms</span> <span class="op">=</span> {}

<span class="md-code-function"><span class="kw">function</span> <span class="fn">getItem</span> <span class="params">(key)</span> </span>{
  <span class="kw3">return</span> <span class="param">key</span> <span class="kw">in</span> <span class="var">ms</span> <span class="op">?</span> <span class="var">ms</span>[<span class="param">key</span>] <span class="op">:</span> <span class="md-code-null">null</span>
}

<span class="md-code-function"><span class="kw">function</span> <span class="fn">setItem</span> <span class="params">(key, value)</span> </span>{
  <span class="var">ms</span>[<span class="param">key</span>] <span class="op">=</span> <span class="param">value</span>
}

<span class="md-code-function"><span class="kw">function</span> <span class="fn">clear</span> <span class="params">()</span> </span>{
  <span class="var">ms</span> <span class="op">=</span> {}
}

<mark class="md-mark md-code-mark"><span class="built_in">module.exports</span> <span class="op">=</span> {
  getItem: <span class="fn">getItem</span>,
  setItem: <span class="fn">setItem</span>,
  clear: <span class="fn">clear</span>
}</mark>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The reasons why <em>— most often —</em> I don’t place functions directly on an object definition are <em>several.</em></p><ul>
  <li>Less indentation needed</li>
  <li>Public API stands out</li>
  <li>Harder to tightly couple methods</li>
  <li>Easier to reason about</li></ul>

<p>With ES6, we can throw another bullet into that list, and that’s that the export can be even easier using <em>property value shorthands</em>. You can omit the property value if it matches the property name. The <code class="md-code md-code-inline">module.exports</code> from the code above thus becomes:</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="built_in">module.exports</span> <span class="op">=</span> { getItem, setItem, clear }
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>So good!</p>



<h2 id="computed-property-names"><span class="md-heading">Computed Property Names</span></h2>

<p>We already covered computed property names briefly in the <a href="#es6-destructuring-in-depth" aria-label="ES6 JavaScript Destructuring in Depth">destructuring article</a>. This was a very common thing to do for me:</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">foo</span> <span class="op">=</span> <span class="str">'bar'</span>
<span class="kw">var</span> <span class="var">baz</span> <span class="op">=</span> {}
<span class="var">baz</span>[<span class="var">foo</span>] <span class="op">=</span> <span class="str">'ponyfoo'</span>
<span class="kw4">console.log</span>(<span class="var">baz</span>)
<span class="com">// &lt;- { bar: 'ponyfoo' }</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Computed property names allow you to write an <em>expression</em> wrapped in square brackets instead of the regular property name. Whatever the expression evaluates to will become the property name.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">foo</span> <span class="op">=</span> <span class="str">'bar'</span>
<span class="kw">var</span> <span class="var">baz</span> <span class="op">=</span> { [foo]: <span class="str">'ponyfoo'</span> }
<span class="kw4">console.log</span>(<span class="var">baz</span>)
<span class="com">// &lt;- { bar: 'ponyfoo' }</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>One limitation of computed property names is that you won’t be able to use the shorthand expression with it. I presume this is because shorthand expression is meant to be simple, compile-time sugar.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">foo</span> <span class="op">=</span> <span class="str">'bar'</span>
<span class="kw">var</span> <span class="var">bar</span> <span class="op">=</span> <span class="str">'ponyfoo'</span>
<span class="kw">var</span> <span class="var">baz</span> <span class="op">=</span> { [foo] }
<span class="kw4">console.log</span>(<span class="var">baz</span>)
<span class="com">// &lt;- SyntaxError</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>That being said, I believe this to be the most common use case. Here our code is simpler because we don’t have to spend three steps in allocating a <code class="md-code md-code-inline">foo</code> variable, assigning to <code class="md-code md-code-inline">foo[type]</code>, and returning <code class="md-code md-code-inline">foo</code>. Instead we can do all three in a single statement.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">getModel</span> <span class="params">(type)</span> </span>{
  <span class="kw3">return</span> {
    [<span class="param">type</span>]: {
      message: <span class="str">'hello, this is doge'</span>,
      date: <span class="kw">new</span> <span class="date">Date</span>()
    }
  }
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Neat. What else?</p>



<h2 id="method-definitions"><span class="md-heading">Method Definitions</span></h2>

<p>Typically in ES5 you declare methods on an object like so:</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">foo</span> <span class="op">=</span> {
  bar: <span class="md-code-function"><span class="kw">function</span> <span class="params">(baz)</span> </span>{
  }
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>While getters and setters have a syntax like this, where there’s no need for the <code class="md-code md-code-inline">function</code> keyword. It’s just inferred from context.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">cart</span> <span class="op">=</span> {
  _wheels: <span class="num">4</span>,
  <span class="built_in">get</span> <span class="fn">wheels</span> () {
    <span class="kw3">return</span> <span class="kw3">this</span>._wheels
  },
  <span class="built_in">set</span> <span class="fn">wheels</span> (<span class="param">value</span>) {
    <span class="kw">if</span> (<span class="param">value</span> <span class="op">&lt;</span> <span class="kw3">this</span>._wheels) {
      <span class="kw">throw</span> <span class="kw">new</span> <span class="md-code-error">Error</span>(<span class="str">'hey, come back here!'</span>)
    }
    <span class="kw3">this</span>._wheels <span class="op">=</span> <span class="param">value</span>
  }
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Starting in ES6, you can declare regular methods with a similar syntax, only difference is it’s not prefixed by <code class="md-code md-code-inline">get</code> or <code class="md-code md-code-inline">set</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">cart</span> <span class="op">=</span> {
  _wheels: <span class="num">4</span>,
  <!--  span class="built_in">get </span  --><span class="fn">wheels</span> () {
    <span class="kw">return this</span>._wheels
  },
  <!--  span class="built_in">set </span  --><span class="fn">wheels</span> (<span class="param">value</span>) {
    <span class="kw">if</span> (value <span class="op">&lt;</span> <span class="kw3">this</span>._wheels) {
      <span class="kw">throw new</span> <span class="md-code-error">Error</span>(<span class="str">'hey, come back here!'</span>)
    }
    <span class="kw3">this</span>._wheels <span class="op">=</span> value
  },
  <mark class="md-mark md-code-mark">dismantle () {
    <span class="kw3">this</span>._wheels <span class="op">=</span> <span class="num">0</span>
    <span class="built_in">console.warn</span>(<span class="str">`you're all going to pay for this!`</span>)
  }</mark>
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>I think it’s nice that methods converged together with getters and setter. I for one don’t use this syntax a lot because I like to name my functions and decouple them from their host objects as I explained in the <a href="#property-value-shorthands">shorthand</a> section. However, it’s still useful in some situations and definitely useful when declaring <em>“classes”</em> — if you’re into that sort of thing.</p></section></section>
</article>
</div>
<p><a href="#top" class="top"><img src="./auxi/glyphicons-214-up-arrow.png" alt="up-arrow" class="uparrow" /> <b>Back to top</b></a></p>
</section></main>

<!--  object literals ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->
<!--  ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->









<!--  classes ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->

<main class="ly-main">
<header class="at-header">



<h1 itemprop="headline" class="dc-title" id="es6-classes-in-depth">ES6 Classes in Depth</h1></header>

<section class="at-teaser"><div class="at-teaser-markdown md-markdown">

<p>Welcome to ES6 in Depth. Are you new here? You might want to learn about <a href="#es6-destructuring-in-depth">destructuring</a>, <a href="#es6-template-strings-in-depth">template literals</a>, <a href="#es6-arrow-functions-in-depth">arrow functions</a>, the <a href="#es6-spread-and-butter-in-depth">spread operator and rest parameters</a>, or <a href="#es6-object-literal-features-in-depth">object literal features in ES6</a>. Today is going to be about <em>“classes”</em> in ES6.</p></div></section>

<section class="at-container de-host"><div class="de-column">

<article itemscope="itemscope" itemtype="http://schema.org/BlogPosting" class="at-article ly-section">
<meta itemprop="dateCreated" content="2015-08-28T00:32:15+00:00" />
<meta itemprop="datePublished" content="2015-09-03T12:36:01+00:00" />
<meta itemprop="dateModified" content="2015-10-11T04:06:36+00:00" />
<meta itemprop="keywords" content="es6,classes,es6-in-depth" />

<section itemprop="articleBody" class="at-corpus">

<section itemprop="about" class="md-markdown at-introduction"><blockquote>

<p>As I did in previous articles on the series, I would love to point out that you should probably <a href="#universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That’ll make it so much easier for you to <strong>internalize the concepts</strong> discussed in the series. If you aren’t the <em>“install things on my computer”</em> kind of human, you might prefer to hop on <a href="http://codepen.io/">CodePen</a> and then click on the gear icon for JavaScript — <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em></p></blockquote>

<p>Onwards!</p></section>

<section class="md-markdown at-body">



<h2 id="what-do-you-mean-1-classes-in-javascript"><span class="md-heading"><a href="https://www.youtube.com/watch?v=fCEo2wfudqk" aria-label="Peace Sells - Megadeth">What do you mean</a> — classes in JavaScript?</span></h2>

<p>JavaScript is a prototype-based language, so what are ES6 classes really? They’re syntactic sugar on top of prototypical inheritance — a device to make the language more inviting to programmers coming from other paradigms who might not be all that familiar with prototype chains. Many features in ES6 <em>(such as <a href="#es6-destructuring-in-depth" aria-label="ES6 JavaScript Destructuring in Depth">destructuring</a>)</em> are, in fact, syntactic sugar — and classes are no exception. I like to clarify this because it makes it much easier to understand the underlying technology behind ES6 classes. There is no huge restructuring of the language, they just made it easier for people used to classes to leverage prototypal inheritance.</p><blockquote>

<p>While I may dislike the term <em>“classes”</em> for this particular feature, I have to say that the syntax is in fact much easier to work with than regular prototypal inheritance syntax in ES5, and that’s a win for everyone — regardless of them being called classes or not.</p></blockquote>

<p>Now that that’s out of the way, I’ll assume you understand prototypal inheritance — just because you’re reading a blog about JavaScript. Here’s how you would describe a <code class="md-code md-code-inline">Car</code> that can be instantiated, fueled up, and move.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">Car</span> <span class="params">()</span> </span>{
  <span class="kw3">this</span>.fuel <span class="op">=</span> <span class="num">0</span>;
  <span class="kw3">this</span>.distance <span class="op">=</span> <span class="num">0</span>;
}

<span class="fn">Car</span>.<span class="built_in">prototype</span>.move <span class="op">=</span> <span class="md-code-function"><span class="kw">function</span> <span class="params">()</span> </span>{
  <span class="kw">if</span> (<span class="kw3">this</span>.fuel <span class="op">&lt;</span> <span class="num">1</span>) {
    <span class="kw">throw</span> <span class="kw">new</span> <span class="built_in">RangeError</span>(<span class="str">'Fuel tank is depleted'</span>)
  }
  <span class="kw3">this</span>.fuel<span class="op">--</span>
  <span class="kw3">this</span>.distance <span class="op">+=</span> <span class="num">2</span>
}

<span class="fn">Car</span>.<span class="built_in">prototype</span>.addFuel <span class="op">=</span> <span class="md-code-function"><span class="kw">function</span> <span class="params">()</span> </span>{
  <span class="kw">if</span> (<span class="kw3">this</span>.fuel <span class="op">&gt;=</span> <span class="num">60</span>) {
    <span class="kw">throw</span> <span class="kw">new</span> <span class="built_in">RangeError</span>(<span class="str">'Fuel tank is full'</span>)
  }
  <span class="kw3">this</span>.fuel<span class="op">++</span>
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>To move the car, you could use the following piece of code.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">car</span> <span class="op">=</span> <span class="kw">new</span> <span class="fn">Car</span>()
<span class="var">car</span>.addFuel()
<span class="var">car</span>.move()
<span class="var">car</span>.move()
<span class="com">// &lt;- RangeError: 'Fuel tank is depleted'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Neat. What about with ES6 classes? The syntax is very similar to declaring an object, except we precede it with <code class="md-code md-code-inline">class Name</code>, where <code class="md-code md-code-inline">Name</code> is the name for our class. Here we are leveraging the <a href="#es6-object-literal-features-in-depth#method-signatures" aria-label="ES6 Object Literal Features in Depth">method signature notation</a> we covered yesterday to declare the methods using a shorter syntax. The <code class="md-code md-code-inline">constructor</code> is just like the constructor method in ES5, so you can use that to initialize any variables your instances may have.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">class</span> <span class="cls">Car</span> {
  <span class="kw">constructor</span> () {
    <span class="kw3">this</span>.fuel <span class="op">=</span> <span class="num">0</span>
    <span class="kw3">this</span>.distance <span class="op">=</span> <span class="num">0</span>
  }
  move () {
    <span class="kw">if</span> (<span class="kw3">this</span>.fuel <span class="op">&lt;</span> <span class="num">1</span>) {
      <span class="kw">throw</span> <span class="kw">new</span> <span class="built_in">RangeError</span>(<span class="str">'Fuel tank is depleted'</span>)
    }
    <span class="kw3">this</span>.fuel<span class="op">--</span>
    <span class="kw3">this</span>.distance <span class="op">+=</span> <span class="num">2</span>
  }
  addFuel () {
    <span class="kw">if</span> (<span class="kw3">this</span>.fuel <span class="op">&gt;=</span> <span class="num">60</span>) {
      <span class="kw">throw</span> <span class="kw">new</span> <span class="built_in">RangeError</span>(<span class="str">'Fuel tank is full'</span>)
    }
    <span class="kw3">this</span>.fuel<span class="op">++</span>
  }
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>In case you haven’t noticed, and for some obscure reason that escapes me, <strong>commas are invalid</strong> in-between properties or methods in a class, as opposed to object literals where commas are <em>(still)</em> mandatory. That discrepancy is bound to cause headaches to people trying to decide whether they want a plain object literal or a class instead, but the code <em>does</em> look sort of cleaner without the commas here.</p>

<p>Many times <em>“classes”</em> have static methods. Think of your friend the <code class="md-code md-code-inline">Array</code> for example. Arrays have instance methods like <code class="md-code md-code-inline">.filter</code>, <code class="md-code md-code-inline">.reduce</code>, and <code class="md-code md-code-inline">.map</code>. The <code class="md-code md-code-inline">Array</code> <em>“class”</em> itself has static methods as well, like <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray" aria-label="Array.isArray() - MDN"><code class="md-code md-code-inline">Array.isArray</code></a>. In ES5 code, it’s pretty easy to add these kind of methods to our <code class="md-code md-code-inline">Car</code> <em>“class”</em>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">Car</span> <span class="params">()</span> </span>{
  <span class="kw3">this</span>.topSpeed <span class="op">=</span> <span class="kw">Math</span>.<span class="built_in">random</span>()
}
<span class="fn">Car</span>.isFaster <span class="op">=</span> <span class="md-code-function"><span class="kw">function</span> <span class="params">(left, right)</span> </span>{
  <span class="kw3">return</span> <span class="param">left</span>.topSpeed <span class="op">&gt;</span> <span class="param">right</span>.topSpeed
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>In ES6 <code class="md-code md-code-inline">class</code> notation, we can use precede our method with <code class="md-code md-code-inline">static</code>, following a similar syntax as that of <code class="md-code md-code-inline">get</code> and <code class="md-code md-code-inline">set</code>. Again, just sugar on top of ES5, as it’s quite trivial to transpile this down into ES5 notation.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">class</span> <span class="cls">Car</span> {
  <span class="kw">constructor</span> () {
    <span class="kw3">this</span>.topSpeed <span class="op">=</span> <span class="cls">Math</span>.<span class="built_in">random</span>()
  }
  <span class="kw3">static</span> isFaster <span class="params">(left, right)</span> {
    <span class="kw3">return</span> <span class="param">left</span>.topSpeed <span class="op">&gt;</span> <span class="param">right</span>.topSpeed
  }
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>One sweet aspect of ES6 <code class="md-code md-code-inline">class</code> sugar is that you also get an <code class="md-code md-code-inline">extends</code> keyword that enables you to easily <em>“inherit”</em> from other <em>“classes”</em>. We all know Tesla cars move further while using the same amount of fuel, thus the code below shows how <code class="md-code md-code-inline">Tesla extends Car</code> and “overrides” (a concept you might be familiar with if you’ve ever <a href="https://msdn.microsoft.com/en-us/library/aa645768(v=vs.71).aspx" aria-label="Overriding methods in C# - MSDN">played around with C#</a>) the <code class="md-code md-code-inline">move</code> method to cover a larger distance.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">class</span> <span class="cls">Tesla</span> <span class="kw">extends</span> <span class="cls">Car</span> {
  move () {
    <span class="kw3">super</span>.move()
    <span class="kw3">this</span>.distance <span class="op">+=</span> <span class="num">4</span>
  }
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The special <code class="md-code md-code-inline">super</code> keyword identifies the <code class="md-code md-code-inline">Car</code> class we’ve inherited from — and since we’re speaking about C#, it’s akin to <a href="https://msdn.microsoft.com/en-us/library/hfw7t1ce.aspx" aria-label="The base keyword ok MSDN"><code class="md-code md-code-inline">base</code></a>. It’s <em>raison d’être</em> is that most of the time we <em>override</em> a method by re-implementing it in the inheriting class, — <code class="md-code md-code-inline">Tesla</code> in our example — we’re supposed to call the method on the base class as well. This way we don’t have to copy logic over to the inheriting class whenever we re-implement a method. That’d be particularly lousy since whenever a base class changes we’d have to paste their logic into every inheriting class, turning our codebase into a maintainability nightmare.</p>

<p>If you now did the following, you’ll notice the Tesla car moves two places because of <code class="md-code md-code-inline">base.move()</code>, which is what every regular car does as well, and it moves an additional four places because <code class="md-code md-code-inline">Tesla</code> is just that good.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">car</span> <span class="op">=</span> <span class="kw">new</span> <span class="cls">Tesla</span>()
<span class="var">car</span>.addFuel()
<span class="var">car</span>.move()
<span class="kw4">console.log</span>(<span class="var">car</span>.distance)
<span class="com">// &lt;- 6</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The most common thing you’ll have to override is the <code class="md-code md-code-inline">constructor</code> method. Here you can just call <code class="md-code md-code-inline">super()</code>, passing any arguments that the base class needs. Tesla cars are twice as fast, so we just call the base <code class="md-code md-code-inline">Car</code> constructor with twice the advertised <code class="md-code md-code-inline">speed</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">class</span> <span class="cls">Car</span> {
  <span class="kw">constructor</span> (speed) {
    <span class="kw3">this</span>.speed <span class="op">=</span> speed
  }
}
<span class="kw">class</span> <span class="cls">Tesla</span> <span class="kw">extends</span> <span class="cls">Car</span> {
  <span class="kw">constructor</span> (speed) {
    <span class="kw3">super</span>(speed <span class="op">*</span> <span class="num">2</span>)
  }
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Tomorrow, we’ll go over the syntax for <code class="md-code md-code-inline">let</code>, <code class="md-code md-code-inline">const</code>, and <code class="md-code md-code-inline">for ... of ...</code>. Until then!</p></section></section>

</article>
</div>
<p><a href="#top" class="top"><img src="./auxi/glyphicons-214-up-arrow.png" alt="up-arrow" class="uparrow" /> <b>Back to top</b></a></p>
</section></main>

<!--  classes ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->
<!--  ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->









<!--  let const ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->

<main class="ly-main">
<header class="at-header">



<h1 itemprop="headline" class="dc-title" id="es6-let-const-and-temporal-dead-zone-in-depth">ES6 Let, Const and the ‘Temporal Dead Zone’ (TDZ) in Depth</h1></header>

<section class="at-teaser"><div class="at-teaser-markdown md-markdown">

<p>This is yet another edition of ES6 in Depth. First time here? Welcome! So far we covered <a href="#es6-destructuring-in-depth">destructuring</a>, <a href="#es6-template-strings-in-depth">template literals</a>, <a href="#es6-arrow-functions-in-depth">arrow functions</a>, the <a href="#es6-spread-and-butter-in-depth">spread operator and rest parameters</a>, <a href="#es6-object-literal-features-in-depth">object literal features in ES6</a>, and last but not least: <a href="#es6-classes-in-depth">what <em>“classes”</em> really mean in ES6</a>. Today is going to be about an assortment of simple language features coming our way in ES6 — <code class="md-code md-code-inline">let</code>, <code class="md-code md-code-inline">const</code>, and the scary-sounding <em>“Temporal Dead Zone”</em>.</p></div></section>

<section class="at-container de-host"><div class="de-column">

<article itemscope="itemscope" itemtype="http://schema.org/BlogPosting" class="at-article ly-section">
<meta itemprop="dateCreated" content="2015-08-28T21:59:12+00:00" />
<meta itemprop="datePublished" content="2015-09-04T12:18:01+00:00" />
<meta itemprop="dateModified" content="2015-10-17T17:26:44+00:00" />
<meta itemprop="keywords" content="es6,let,const,temporal-dead-zone,es6-in-depth" />

<section itemprop="articleBody" class="at-corpus">

<section itemprop="about" class="md-markdown at-introduction"><blockquote>

<p>As I did in previous articles on the series, I would love to point out that you should probably <a href="#universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That’ll make it so much easier for you to <strong>internalize the concepts</strong> discussed in the series. If you aren’t the <em>“install things on my computer”</em> kind of human, you might prefer to hop on <a href="http://codepen.io/">CodePen</a> and then click on the gear icon for JavaScript — <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em> Another alternative that’s also quite useful is to use Babel’s <a href="http://babeljs.io/repl/">online REPL</a> <em>— it’ll show you compiled ES5 code to the right of your ES6 code for quick comparison.</em></p></blockquote>

<p><em>Shall we?</em></p></section>

<section class="md-markdown at-body">



<h2 id="let-statement"><span class="md-heading">Let Statement</span></h2>

<p>The <code class="md-code md-code-inline">let</code> statement is one of the most well-known features in ES6, which is partly why I grouped it together with a few other new features. It works like a <code class="md-code md-code-inline">var</code> statement, but it has different scoping rules. JavaScript has always had a complicated ruleset when it came to scoping, driving many programmers crazy when they were first trying to figure out how variables work in JavaScript.</p>

<p>Eventually, you discover this thing called <a href="#javascript-variable-hoisting" aria-label="JavaScript Variable Hoisting on Pony Foo">hoisting</a>, and things start making a bit more sense to you. Hoisting means that variables get pulled from anywhere they were declared in user code to the top of their scope. For example, see the code below.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">areTheyAwesome</span> <span class="params">(name)</span> </span>{
  <span class="kw">if</span> (<span class="param">name</span> <span class="op">===</span> <span class="str">'nico'</span>) {
    <span class="kw">var</span> <span class="var">awesome</span> <span class="op">=</span> <span class="md-code-boolean">true</span>
  }
  <span class="kw3">return</span> <span class="var">awesome</span>
}
<span class="fn">areTheyAwesome</span>(<span class="str">'nico'</span>)
<span class="com">// &lt;- true</span>
<span class="fn">areTheyAwesome</span>(<span class="str">'christian heilmann'</span>)
<span class="com">// &lt;- undefined</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The reason why this doesn’t implode into oblivion is, as we know, that <code class="md-code md-code-inline">var</code> is function-scoped. That coupled with hoisting means that what we’re really expressing is something like the piece of code below.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">areTheyAwesome</span> <span class="params">(name)</span> </span>{
  <span class="kw">var</span> <span class="var">awesome</span>
  <span class="kw">if</span> (<span class="params">name</span> <span class="op">===</span> <span class="str">'nico'</span>) {
    <span class="var">awesome</span> <span class="op">=</span> <span class="md-code-boolean">true</span>
  }
  <span class="kw3">return</span> <span class="var">awesome</span>
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Whether we like it or not (or we’re just used to it — I know I am), this is plainly more confusing than having block-scoped variables would be. Block scoping works on the bracket level, rather than the function level.</p>

<p>Instead of having to declare a new <code class="md-code md-code-inline">function</code> if we want a deeper scoping level, block scoping allows you to just leverage existing code branches like those in <code class="md-code md-code-inline">if</code>, <code class="md-code md-code-inline">for</code>, or <code class="md-code md-code-inline">while</code> statements; you could also create new <code class="md-code md-code-inline">{}</code> blocks arbitrarily. As you may or may not know, the JavaScript language allows us to create an indiscriminate number of blocks, just because we want to.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">{{{{{<span class="kw">var</span> <span class="var">insane</span> <span class="op">=</span> <span class="str">'yes, you are'</span>}}}}}
<span class="kw4">console.log</span>(<span class="var">insane</span>)
<span class="com">// &lt;- 'yes, you are'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>With <code class="md-code md-code-inline">var</code>, though, one could still access the variable from outside those many, many, many blocks, and not get an error. Sometimes it can be very useful to get errors in these situations. Particularly if one or more of these is true.</p><ul>
  <li>Accessing the inner variable breaks some sort of encapsulation principle in our code</li>
  <li>The inner variable doesn’t belong in the outer scope at all</li>
  <li>The block in question has many siblings that would also want to use the same variable name</li>
  <li>One of the parent blocks already has a variable with the name we need, but it’s still appropriate to use in the inner block</li></ul>



<h2 id="so-how-does-this-let-thing-work"><span class="md-heading">So how does this <code class="md-code md-code-inline">let</code> thing work?</span></h2><blockquote>

<p>The <code class="md-code md-code-inline">let</code> statement is an alternative to <code class="md-code md-code-inline">var</code>. It follows block scoping rules instead of the default function scoping rules. This means you <strong>don’t need entire functions</strong> to get a new scope — <em>a simple <code class="md-code md-code-inline">{}</code> block will do!</em></p></blockquote>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">let</span> <span class="var">outer</span> <span class="op">=</span> <span class="str">'I am so eccentric!'</span>
{
  <span class="kw">let</span> <span class="var">inner</span> <span class="op">=</span> <span class="str">'I play with neighbors in my block and the sewers'</span>
  {
    <span class="kw">let</span> <span class="var">innermost</span> <span class="op">=</span> <span class="str">'I only play with neighbors in my block'</span>
  }
  <span class="com">// accessing innermost here would throw</span>
}
<span class="com">// accessing inner here would throw</span>
<span class="com">// accessing innermost here would throw</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Here is where things got interesting. As I wrote this example I thought, <em>"Well, but if we now declare a function inside a block and access it from outside that block, things will <strong>surely go awry</strong>"</em>. Based on my existing knowledge of ES5 I fully expected the following snippet of code to work, and it does in fact <em>work in ES5</em> but it’s <a href="http://www.2ality.com/2015/02/es6-scoping.html" aria-label="Variables and scoping in ECMAScript 6, see section 7">broken in ES6</a>. That would’ve been a problem because it’d make super easy to expose block-scoped properties through functions that become hoisted outside of the block. I didn’t expect this to <code class="md-code md-code-inline">throw</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">{
  <span class="kw">let</span> <span class="var">_nested</span> <span class="op">=</span> <span class="str">'secret'</span>
  <span class="md-code-function"><span class="kw">function</span> <span class="fn">nested</span> <span class="params">()</span> </span>{
    <span class="kw3">return</span> <span class="var">_nested</span>
  }
}
<span class="kw4">console.log</span>(nested())
<span class="com">// nested is not defined</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>As it turns out, this wasn’t a bug in Babel, but in fact a <em>(much welcome)</em> change in ES6 language semantics.</p><blockquote class="twitter-tweet">

<p><a href="https://twitter.com/nzgb">@nzgb</a> <a href="https://twitter.com/rauschma">@rauschma</a> <a href="https://twitter.com/sebmck">@sebmck</a> AFAIR, this is correct — ES6 finally specified functions in blocks to behave as block-scoped.</p>— Ingvar Stepanyan (@RReverser) <a href="https://twitter.com/RReverser/status/637349812485099520">August 28, 2015</a></blockquote>

<p>Note that you can still expose nested <code class="md-code md-code-inline">let</code> things to outer scopes simply by assigning them to a variable that has more access. I wouldn’t recommend you do this however, as there probably are cleaner ways to write code in these situations — such as <strong>not using <code class="md-code md-code-inline">let</code> when you don’t want block scoping</strong>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">nested</span>
{
  <span class="kw">let</span> <span class="var">_nested</span> <span class="op">=</span> <span class="str">'secret'</span>
  <span class="var">nested</span> <span class="op">=</span> <span class="md-code-function"><span class="kw">function</span> <span class="params">()</span> </span>{
    <span class="kw3">return</span> <span class="var">_nested</span>
  }
}
<span class="kw4">console.log</span>(<span class="var">nested</span>())
<span class="com">// &lt;- 'secret'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>In conclusion, block scoping can be quite useful in new codebases. Some people will tell you to drop <code class="md-code md-code-inline">var</code> forever and just use <code class="md-code md-code-inline">let</code> everywhere. Some will tell you to never use <code class="md-code md-code-inline">let</code> because that’s not the <em>One True Way of JavaScript</em>. My position might change over time, but this is it — for the time being:</p><blockquote>

<p>I plan on using <code class="md-code md-code-inline">var</code> most of the time, and <code class="md-code md-code-inline">let</code> in those situations where I would’ve otherwise hoisted a variable to the top of the scope for no reason, when they actually belonged inside a conditional or iterator code branch.</p></blockquote>



<h2 id="the-temporal-dead-zone-and-the-deathly-hallows"><span class="md-heading">The <em>Temporal Dead Zone</em> and the Deathly Hallows</span></h2>

<p>One last thing of note about <code class="md-code md-code-inline">let</code> is a mystical concept called the <a href="http://jsrocks.org/2015/01/temporal-dead-zone-tdz-demystified/" aria-label="Temporal Dead Zone (TDZ) Demystified">“Temporal Dead Zone” <em>(TDZ)</em></a> <em>— ooh… so scary, I know.</em></p>

<p><img alt="screen capture of desolate urban landscape in game" class="js-only" src="auxi/temporal_dead_zone.jpg"></p>

<p>In so many words: if you have code such as the following, it’ll throw.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">there <span class="op">=</span> <span class="str">'far away'</span>
<span class="com">// &lt;- ReferenceError: there is not defined</span>
<span class="kw">let</span> <span class="var">there</span> <span class="op">=</span> <span class="str">'dragons'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>If your code tries to access <code class="md-code md-code-inline">there</code> in any way before the <code class="md-code md-code-inline">let there</code> statement is reached, the program will throw. Declaring a method that references <code class="md-code md-code-inline">there</code> before it’s defined is okay, as long as the method doesn’t get executed while <code class="md-code md-code-inline">there</code> is in the TDZ, and <code class="md-code md-code-inline">there</code> will be in the TDZ for as long as the <code class="md-code md-code-inline">let there</code> statement isn’t reached <em>(while the scope has been entered)</em>. This snippet won’t throw because <code class="md-code md-code-inline">return there</code> isn’t executed until after <code class="md-code md-code-inline">there</code> leaves the TDZ.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">readThere</span> <span class="params">()</span> </span>{
  <span class="kw3">return</span> <span class="var">there</span>
}
<span class="kw">let</span> <span class="var">there</span> <span class="op">=</span> <span class="str">'dragons'</span>
<span class="kw4">console.log</span>(<span class="fn">readThere</span>())
<span class="com">// &lt;- 'dragons'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>But this snippet will, because access to <code class="md-code md-code-inline">there</code> occurs <em>before leaving the TDZ for <code class="md-code md-code-inline">there</code></em>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">readThere</span> <span class="params">()</span> </span>{
  <span class="kw3">return</span> there
}
<span class="kw4">console.log</span>(<span class="fn">readThere</span>())
<span class="com">// ReferenceError: there is not defined</span>
<span class="kw">let</span> <span class="var">there</span> <span class="op">=</span> <span class="str">'dragons'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Note that the semantics for these examples doesn’t change when <code class="md-code md-code-inline">there</code> isn’t actually assigned a value when initially declared. The snippet below still throws, as it still tries to access <code class="md-code md-code-inline">there</code> before leaving the TDZ.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">readThere</span> <span class="params">()</span> </span>{
  <span class="kw3">return</span> there
}
<span class="kw4">console.log</span>(<span class="fn">readThere</span>())
<span class="com">// ReferenceError: there is not defined</span>
<span class="kw">let</span> <span class="var">there</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>This snippet still works because it still leaves the TDZ before accessing <code class="md-code md-code-inline">there</code> in any way.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">readThere</span> <span class="params">()</span> </span>{
  <span class="kw3">return</span> <span class="var">there</span>
}
<span class="kw">let</span> <span class="var">there</span>
<span class="kw4">console.log</span>(<span class="fn">readThere</span>())
<span class="com">// &lt;- undefined</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The only tricky part is to remember that <em>(when it comes to the TDZ)</em> functions work sort of like blackboxes until they’re actually executed for the first time, so it’s okay to place <code class="md-code md-code-inline">there</code> inside functions that don’t get executed until we leave the TDZ.</p><blockquote>

<p>The whole point of the TDZ is to make it easier to catch errors where accessing a variable before it’s declared in user code leads to unexpected behavior. This happened a lot with ES5 due both to hoisting and poor coding conventions. In ES6 it’s easier to avoid. Keep in mind that hoisting still applies for <code class="md-code md-code-inline">let</code> as well — this just means that the variables will be created when we enter the scope, and the TDZ will be born, but they will be inaccessible until code execution hits the place where the variable was actually declared, at which point we leave the TDZ and are cleared to use the variable.</p></blockquote>



<h2 id="const-statement"><span class="md-heading">Const Statement</span></h2>

<p>Phew. I wrote more than I ever wanted to write about <code class="md-code md-code-inline">let</code>. Fortunately for both of us, <code class="md-code md-code-inline">const</code> is quite similar to <code class="md-code md-code-inline">let</code>.</p><ul>
  <li><code class="md-code md-code-inline">const</code> is also <em>block-scoped</em></li>
  <li><code class="md-code md-code-inline">const</code> also enjoys the marvels of <em>TDZ semantics</em></li></ul>

<p>There’s also a couple of major differences.</p><ul>
  <li><code class="md-code md-code-inline">const</code> variables must be declared using an initializer</li>
  <li><code class="md-code md-code-inline">const</code> variables can only be assigned to once, in said initializer</li>
  <li><code class="md-code md-code-inline">const</code> variables <strong>don’t</strong> make the assigned value immutable</li>
  <li>Assigning to <code class="md-code md-code-inline">const</code> will fail silently</li>
  <li>Redeclaration of a variable by the same name <em>will</em> throw</li></ul>

<p>Let’s go to some examples. First, this snippet shows how it follows block-scoping rules just like <code class="md-code md-code-inline">let</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">const</span> <span class="md-code-const">cool</span> <span class="op">=</span> <span class="str">'ponyfoo'</span>
{
  <span class="kw">const</span> <span class="md-code-const">cool</span> <span class="op">=</span> <span class="str">'dragons'</span>
  <span class="kw4">console.log</span>(<span class="md-code-const">cool</span>)
  <span class="com">// &lt;- 'dragons'</span>
}
<span class="kw4">console.log</span>(<span class="md-code-const">cool</span>)
<span class="com">// &lt;- 'ponyfoo'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Once a <code class="md-code md-code-inline">const</code> is declared, you can’t change the reference or literal that’s assigned to it.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">const</span> <span class="md-code-const">cool</span> <span class="op">=</span> { people: [<span class="str">'you'</span>, <span class="str">'me'</span>, <span class="str">'tesla'</span>, <span class="str">'musk'</span>] }
<span class="md-code-const">cool</span> <span class="op">=</span> {}
<span class="com">// &lt;- "cool" is read-only</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>You can however, change the reference itself. It does not become immutable. You’d have to use <a href="https://i.imgur.com/79mp6As.jpg"><code class="md-code md-code-inline">Object.freeze</code></a> to make the value itself immutable.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">const</span> <span class="md-code-const">cool</span> <span class="op">=</span> { people: [<span class="str">'you'</span>, <span class="str">'me'</span>, <span class="str">'tesla'</span>, <span class="str">'musk'</span>] }
<span class="md-code-const">cool</span>.people.<span class="built_in">push</span>(<span class="str">'berners-lee'</span>)
<span class="kw4">console.log</span>(<span class="md-code-const">cool</span>)
<span class="com">// &lt;- { people: ['you', 'me', 'tesla', 'musk', 'berners-lee'] }</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>You can also make other references to the <code class="md-code md-code-inline">const</code> that <em>can</em>, in fact, change.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">const</span> <span class="md-code-const">cool</span> <span class="op">=</span> { people: [<span class="str">'you'</span>, <span class="str">'me'</span>, <span class="str">'tesla'</span>, <span class="str">'musk'</span>] }
<span class="kw">var</span> <span class="md-code-const">uncool</span> <span class="op">=</span> <span class="md-code-const">cool</span>
<span class="md-code-const">uncool</span> <span class="op">=</span> { people: [<span class="str">'edison'</span>] } <span class="com">// so uncool he's all alone</span>
<span class="kw4">console.log</span>(<span class="md-code-const">uncool</span>)
<span class="com">// &lt;- { people: ['edison'] }</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>I think <code class="md-code md-code-inline">const</code> is great because it allows us to mark things that we really need to preserve as such. Imagine the following piece of code, which does come up in some situations <em>— sorry about the extremely contrived example.</em></p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">code</span> <span class="params">(groceries)</span> </span>{
  <span class="kw3">return</span> {<span class="fn">eat</span>}
  <span class="md-code-function"><span class="kw">function</span> <span class="fn">eat</span> <span class="params">()</span> </span>{
    <span class="kw">if</span> (<span class="param">groceries</span>.<span class="built_in">length</span> <span class="op">===</span> <span class="num">0</span>) {
      <span class="kw">throw</span> <span class="kw">new</span> <span class="md-code-error">Error</span>(<span class="str">'All out. Please buy more groceries to feed the code.'</span>)
    }
    <span class="kw3">return</span> <span class="param">groceries</span>.<span class="built_in">shift</span>()
  }
}
<span class="kw">var</span> <span class="var">groceries</span> <span class="op">=</span> [<span class="str">'carrot'</span>, <span class="str">'lemon'</span>, <span class="str">'potato'</span>, <span class="str">'turducken'</span>]
<span class="kw">var</span> <span class="var">eater</span> <span class="op">=</span> code(<span class="var">groceries</span>)
<span class="kw4">console.log</span>(<span class="var">eater</span>.<span class="fn">eat</span>())
<span class="com">// &lt;- 'carrot'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>I sometimes come across code where someone is trying to add more <code class="md-code md-code-inline">groceries</code> to the list, and they figure that doing the following would <em>just work</em>. In many cases this does work. However, if we’re passing a reference to groceries to something else, the re-assignment wouldn’t be carried away to that other place, and hard to debug issues would ensue.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="com">// a few hundred lines of code later...</span>
<span class="var">groceries</span> <span class="op">=</span> [<span class="str">'heart of palm'</span>, <span class="str">'tomato'</span>, <span class="str">'corned beef'</span>]
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>If <code class="md-code md-code-inline">groceries</code> were a constant in the piece of code above, this re-assignment would’ve been far easier to detect. Yay, ES6! I can definitely see myself using <code class="md-code md-code-inline">const</code> a lot in the future, but I haven’t quite internalized it yet.</p><blockquote>

<p>I guess more coding is in order!</p></blockquote></section></section>

</article>

</div>
<p><a href="#top" class="top"><img src="./auxi/glyphicons-214-up-arrow.png" alt="up-arrow" class="uparrow" /> <b>Back to top</b></a></p>
</section></main>

<!--  let const ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->
<!--  ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->









<!--  iterators ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->

<main class="ly-main">
<header class="at-header">



<h1 itemprop="headline" class="dc-title" id="es6-iterators-in-depth">ES6 Iterators in Depth</h1></header>

<section class="at-teaser"><div class="at-teaser-markdown md-markdown">

<p>This is yet another edition of ES6 in Depth. First time here? Welcome! So far we covered <a href="#es6-destructuring-in-depth">destructuring</a>, <a href="#es6-template-strings-in-depth">template literals</a>, <a href="#es6-arrow-functions-in-depth">arrow functions</a>, the <a href="#es6-spread-and-butter-in-depth">spread operator and rest parameters</a>, improvements coming to <a href="#es6-object-literal-features-in-depth">object literals</a>, the new <a href="#es6-classes-in-depth"><em>classes</em></a> sugar on top of prototypes, and an article on <a href="#es6-let-const-and-temporal-dead-zone-in-depth"><code class="md-code md-code-inline">let</code>, <code class="md-code md-code-inline">const</code>, and the <em>“Temporal Dead Zone”</em></a>. The soup of the day is: <strong>Iterators</strong>.</p></div></section>

<section class="at-container de-host"><div class="de-column">

<article itemscope="itemscope" itemtype="http://schema.org/BlogPosting" class="at-article ly-section">
<meta itemprop="dateCreated" content="2015-08-31T15:48:16+00:00" />
<meta itemprop="datePublished" content="2015-09-07T11:06:01+00:00" />
<meta itemprop="dateModified" content="2015-10-11T04:06:37+00:00" />
<meta itemprop="keywords" content="es6,iterators,symbols,es6-in-depth" />

<section itemprop="articleBody" class="at-corpus">

<section itemprop="about" class="md-markdown at-introduction"><blockquote>

<p>As I did in previous articles on the series, I would love to point out that you should probably <a href="#universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That’ll make it so much easier for you to <strong>internalize the concepts</strong> discussed in the series. If you aren’t the <em>“install things on my computer”</em> kind of human, you might prefer to hop on <a href="http://codepen.io/">CodePen</a> and then click on the gear icon for JavaScript — <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em> Another alternative that’s also quite useful is to use Babel’s <a href="http://babeljs.io/repl/">online REPL</a> <em>— it’ll show you compiled ES5 code to the right of your ES6 code for quick comparison.</em></p></blockquote>

<p>Before getting into it, let me <a href="https://www.patreon.com/bevacqua"><em>shamelessly ask for your support</em></a> if you’re enjoying my ES6 in Depth series. Your contributions will go towards helping me keep up with the schedule, server bills, keeping me fed, and maintaining <strong>Pony Foo</strong> as a veritable source of JavaScript goodies.</p>

<p>Thanks for listening to that, and without further ado … <em>shall we?</em></p></section>

<section class="md-markdown at-body">



<h2 id="iterator-protocol-and-iterable-protocol"><span class="md-heading">Iterator Protocol and Iterable Protocol</span></h2><blockquote>

<p><em>There’s a lot of new, intertwined terminology here. Please bear with me as I get some of these explanations out of the way!</em></p></blockquote>

<p>JavaScript gets two new protocols in ES6, <em>Iterators</em> and <em>Iterables</em>. In plain terms, you can think of protocols as <em>conventions</em>. As long as you follow a determined convention in the language, you get a side-effect. The <em>iterable</em> protocol allows you to define the behavior when JavaScript objects are being iterated. Under the hood, deep in the world of JavaScript interpreters and language specification <em>keyboard-smashers</em>, we have the <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Iteration_protocols" aria-label="Iteration Protocols on MDN"><code class="md-code md-code-inline">@@iterator</code></a> method. This method underlies the <em>iterable</em> protocol and, in the real world, you can assign to it using something called “the <em>well-known</em> <code class="md-code md-code-inline">Symbol.iterator</code> Symbol”.</p>

<p>We’ll get back to <a href="#es6-symbols-in-depth" aria-label="ES6 Symbols in Depth">what Symbols are</a> <em>later in the series</em>. Before losing focus, you should know that the <code class="md-code md-code-inline">@@iterator</code> method is called <strong>once, whenever an object needs to be iterated</strong>. For example, at the beginning of a <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/for...of" aria-label="for..of is on MDN"><code class="md-code md-code-inline">for..of</code></a> loop <em>(which we’ll also get back to in a few minutes)</em>, the <code class="md-code md-code-inline">@@iterator</code> will be asked for an <em>iterator</em>. The returned <em>iterator</em> will be used to obtain values out of the object.</p>

<p>Let’s use the snippet of code found below as a crutch to understand the concepts behind iteration. The first thing you’ll notice is that I’m making my object an iterable by assigning to its mystical <code class="md-code md-code-inline">@@iterator</code> property through the <code class="md-code md-code-inline">Symbol.iterator</code> property. I can’t use the symbol as a property name directly. Instead, I have to wrap in square brackets, meaning it’s a computed property name that evaluates to the <code class="md-code md-code-inline">Symbol.iterator</code> <em>expression</em> — as you might recall from the <a href="#es6-object-literal-features-in-depth" aria-label="ES6 Object Literal Features in Depth">article on object literals</a>. The object returned by the method assigned to the <code class="md-code md-code-inline">[Symbol.iterator]</code> property must adhere to the <em>iterator</em> protocol. The <em>iterator</em> protocol defines how to get values out of an object, and we must return an <code class="md-code md-code-inline">@@iterator</code> that adheres to <em>iterator</em> protocol. The protocol indicates we must have an object with a <code class="md-code md-code-inline">next</code> method. The <code class="md-code md-code-inline">next</code> method takes no arguments and it should return an object with these two properties.</p><ul>
  <li><code class="md-code md-code-inline">done</code> signals that the sequence has ended when <code class="md-code md-code-inline">true</code>, and <code class="md-code md-code-inline">false</code> means there may be more values</li>
  <li><code class="md-code md-code-inline">value</code> is the current item in the sequence</li></ul>

<p>In my example, the iterator method returns an object that has a finite list of items and which emits those items until there aren’t any more left. The code below is an iterable object in ES6.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">foo</span> <span class="op">=</span> {
  <mark class="md-mark md-code-mark">[<span class="md-code-symbol">Symbol</span>.<span class="built_in">iterator</span>]</mark>: () <span class="op">=&gt;</span> ({
    items: [<span class="str">'p'</span>, <span class="str">'o'</span>, <span class="str">'n'</span>, <span class="str">'y'</span>, <span class="str">'f'</span>, <span class="str">'o'</span>, <span class="str">'o'</span>],
    <mark class="md-mark md-code-mark">next</mark>: <span class="md-code-function"><span class="kw">function</span> <span class="fn">next</span> <span class="params">()</span> </span>{
      <span class="kw3">return</span> {
        done: <span class="kw3">this</span>.items.<span class="built_in">length</span> <span class="op">===</span> <span class="num">0</span>,
        value: <span class="kw3">this</span>.items.<span class="built_in">shift</span>()
      }
    }
  })
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>To actually iterate over the object, we could use <code class="md-code md-code-inline">for..of</code>. What would that look like? See below. The <code class="md-code md-code-inline">for..of</code> iteration method is also new in ES6, and it settles the everlasting war against looping over JavaScript collections and randomly finding things that didn’t belong in the result-set you were expecting.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw3">for</span> (<mark class="md-mark md-code-mark"><span class="kw">let</span> <span class="var">pony</span> <span class="kw">of</span> <span class="var">foo</span></mark>) {
  <span class="kw4">console.log</span>(<span class="var">pony</span>)
  <span class="com">// &lt;- 'p'</span>
  <span class="com">// &lt;- 'o'</span>
  <span class="com">// &lt;- 'n'</span>
  <span class="com">// &lt;- 'y'</span>
  <span class="com">// &lt;- 'f'</span>
  <span class="com">// &lt;- 'o'</span>
  <span class="com">// &lt;- 'o'</span>
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>You can use <code class="md-code md-code-inline">for..of</code> to iterate over any object that adheres to the <em>iterable</em> protocol. In ES6, that includes arrays, any objects with a user-defined <code class="md-code md-code-inline">[Symbol.iterator]</code> method, <a href="#es6-generators-in-depth" aria-label="ES6 Generators in Depth"><em>generators</em></a>, DOM node collections from <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/querySelectorAll" aria-label="Element.querySelectorAll() on MDN"><code class="md-code md-code-inline">.querySelectorAll</code></a> and friends, etc. If you just want to <em>“cast”</em> any iterable into an array, a couple of terse alternatives would be using the <a href="#es6-spread-and-butter-in-depth" aria-label="ES6 Spread and Butter in Depth">spread operator</a> and <code class="md-code md-code-inline">Array.from</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw4">console.log</span>(<mark class="md-mark md-code-mark">[<span class="op">...</span><span class="var">foo</span>]</mark>)
<span class="com">// &lt;- ['p', 'o', 'n', 'y', 'f', 'o', 'o']</span>
<span class="kw4">console.log</span>(<mark class="md-mark md-code-mark"><span class="kw">Array</span>.<span class="built_in">from</span>(<span class="var">foo</span>)</mark>)
<span class="com">// &lt;- ['p', 'o', 'n', 'y', 'f', 'o', 'o']</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>To recap, our <code class="md-code md-code-inline">foo</code> object adheres to the <em>iterable</em> protocol by assigning a method to <code class="md-code md-code-inline">[Symbol.iterator]</code> — <em>anywhere in the prototype chain for <code class="md-code md-code-inline">foo</code> would work</em>. This means that the object is <em>iterable</em>: it can be iterated. Said method returns an object that adheres to the <em>iterator</em> protocol. The iterator method is called once whenever we want to start iterating over the object, and the returned <em>iterator</em> is used to pull values out of <code class="md-code md-code-inline">foo</code>. To iterate over iterables, we can use <code class="md-code md-code-inline">for..of</code>, the <a href="#es6-spread-and-butter-in-depth" aria-label="ES6 Spread and Butter in Depth">spread operator</a>, or <code class="md-code md-code-inline">Array.from</code>.</p>


<h2 id="what-does-this-all-mean"><span class="md-heading">What Does This All Mean?</span></h2>

<p>In essence, the selling point about iteration protocols, <code class="md-code md-code-inline">for..of</code>, <code class="md-code md-code-inline">Array.from</code>, and the spread operator is that they provide expressive ways to effortlessly iterate over collections and array-likes <em>(such as <code class="md-code md-code-inline">arguments</code>)</em>. Having the ability to define how any object may be iterated is huge, because it enables libraries like <a href="http://lodash.com/docs" aria-label="Lodash documentation">lo-dash</a> to converge under a protocol the language natively understands — <em>iterables.</em> This is <strong>huge</strong>.</p>

<blockquote class="twitter-tweet">
<p>Lodash's chaining wrapper is now an iterator and iterable: var w = _({ a: 1, b: 2 }); Array.from(w); // =&gt; [1, 2]</p>— John-David Dalton (@jdalton) <a href="https://twitter.com/jdalton/status/638238228869283841">August 31, 2015</a></blockquote>

<p>Just to give you another example, remember how I always complain about jQuery wrapper objects not being <a href="http://ponyfoo.com/articles/how-to-avoid-objectprototype-pollution" aria-label="How To Avoid Object.prototype Pollution on Pony Foo">true arrays</a>, or how <code class="md-code md-code-inline">document.querySelectorAll</code> doesn’t return a true array either? If jQuery implemented the iterator protocol on their collection’s prototype, then you could do something like below.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw3">for</span> (<span class="kw">let</span> <span class="var">item</span> <span class="kw">of</span> $(<span class="str">'li'</span>)) {
  <span class="kw4">console.log</span>(<span class="var">item</span>)
  <span class="com">// &lt;- the &lt;li&gt; wrapped in a jQuery object</span>
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Why wrapped? Because it’s more expressive. You could easily iterate as deep as you need to.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw3">for</span> (<span class="kw">let</span> <span class="var">list</span> <span class="kw">of</span> $(<span class="str">'ul'</span>)) {
  <span class="kw3">for</span> (<span class="kw">let</span> <span class="var">item</span> <span class="kw">of</span> <span class="var">list</span>.<span class="built_in">find</span>(<span class="str">'li'</span>)) {
    <span class="kw4">console.log</span>(<span class="var">item</span>)
    <span class="com">// &lt;- the &lt;li&gt; wrapped in a jQuery object</span>
  }
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>This brings me to an important aspect of iterables and iterators.</p>



<h2 id="lazy-in-nature"><span class="md-heading">Lazy in Nature</span></h2>

<p>Iterators are <em>lazy in nature</em>. This is fancy-speak for saying that the sequence is accessed one item at a time. It can even be an infinite sequence — a legitimate scenario with many use cases. Given that iterators are lazy, having jQuery wrap every result in the sequence with their wrapper object wouldn’t have a big upfront cost. Instead, a wrapper is created each time a value is pulled from the <em>iterator</em>.</p>

<p>How would an infinite iterator look? The example below shows an iterator with a <code class="md-code md-code-inline">1..Infinity</code> range. Note how it will never yields <code class="md-code md-code-inline">done: true</code>, signaling that the sequence is over. Attempting to cast the iterable <code class="md-code md-code-inline">foo</code> object into an array using either <code class="md-code md-code-inline">Array.from(foo)</code> or <code class="md-code md-code-inline">[...foo]</code> would crash our program, since the sequence <em>never ends</em>. We must be very careful with these types of sequences as they can crash and burn our Node process, or the human’s browser tab.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">foo</span> <span class="op">=</span> {
  [<span class="md-code-symbol">Symbol</span>.<span class="built_in">iterator</span>]: () <span class="op">=&gt;</span> {
    <span class="kw">var</span> <span class="var">i</span> <span class="op">=</span> <span class="num">0</span>
    <span class="kw3">return</span> { next: () <span class="op">=&gt;</span> (<mark class="md-mark md-code-mark">{ value: <span class="op">++</span><span class="var">i</span> }</mark>) }
  }
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The correct way of working with such an iterator is with an escape condition that prevents the loop from going infinite. The example below loops over our infinite sequence using <code class="md-code md-code-inline">for..of</code>, but it breaks the loop as soon as the value goes over <code class="md-code md-code-inline">10</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw3">for</span> (<span class="kw">let</span> <span class="var">pony</span> <span class="kw">of</span> <span class="var">foo</span>) {
  <span class="kw">if</span> (<span class="var">pony</span> <span class="op">&gt;</span> <span class="num">10</span>) {
    <mark class="md-mark md-code-mark"><span class="kw3">break</span></mark>
  }
  <span class="kw4">console.log</span>(<span class="var">pony</span>)
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->
<blockquote>

<p>The iterator doesn’t really <em>know</em> that the sequence is infinite. In that regard, this is similar to the <a href="https://en.wikipedia.org/wiki/Halting_problem" aria-label="Halting Problem on Wikipedia">halting problem</a> — there is no way of knowing whether the sequence is infinite or not in code.</p>

<p><a href="https://xkcd.com/1266/" aria-label="Halting Problem on XKCD"><img alt="The halting problem depicted by XKCD" class="js-only" src="auxi/halting_problem.png"></a></p>

<p>We <strong>usually have a good idea</strong> about whether a sequence is <em>finite or infinite</em>, since we construct those sequences. Whenever we have an infinite sequence it’s up to us to add an escape condition that ensures our program won’t crash in an attempt to loop over every single value in the sequence.</p></blockquote>

<p><em>Come back tomorrow for <a href="#es6-generators-in-depth" aria-label="ES6 Generators in Depth">a discussion about generators!</a></em></p></section></section>

</article>

</div>
<p><a href="#top" class="top"><img src="./auxi/glyphicons-214-up-arrow.png" alt="up-arrow" class="uparrow" /> <b>Back to top</b></a></p>
</section></main>

<!--  iterators ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->
<!--  ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->









<!--  generators ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->

<main class="ly-main">
<header class="at-header">



<h1 itemprop="headline" class="dc-title" id="es6-generators-in-depth">ES6 Generators in Depth</h1></header>

<section class="at-teaser"><div class="at-teaser-markdown md-markdown">

<p>This is ES6 in Depth, the longest-running article series in the history of Pony Foo! Trapped in the ES5 bubble? Welcome! Let me get you started with <a href="#es6-destructuring-in-depth">destructuring</a>, <a href="#es6-template-strings-in-depth">template literals</a>, <a href="#es6-arrow-functions-in-depth">arrow functions</a>, the <a href="#es6-spread-and-butter-in-depth">spread operator and rest parameters</a>, improvements coming to <a href="#es6-object-literal-features-in-depth">object literals</a>, the new <a href="#es6-classes-in-depth"><em>classes</em></a> sugar on top of prototypes, <a href="#es6-let-const-and-temporal-dead-zone-in-depth"><code class="md-code md-code-inline">let</code>, <code class="md-code md-code-inline">const</code>, and the <em>“Temporal Dead Zone”</em></a>, and <a href="#es6-iterators-in-depth">Iterators</a>.</p></div></section>

<section class="at-container de-host"><div class="de-column">

<article itemscope="itemscope" itemtype="http://schema.org/BlogPosting" class="at-article ly-section">
<meta itemprop="dateCreated" content="2015-08-31T20:39:20+00:00" />
<meta itemprop="datePublished" content="2015-09-08T11:48:01+00:00" />
<meta itemprop="dateModified" content="2015-10-11T04:06:37+00:00" />
<meta itemprop="keywords" content="es6,generators,iterators,es6-in-depth" />

<section itemprop="articleBody" class="at-corpus">

<section itemprop="about" class="md-markdown at-introduction"><blockquote>

<p>As I did in previous articles on the series, I would love to point out that you should probably <a href="#universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That’ll make it so much easier for you to <strong>internalize the concepts</strong> discussed in the series. If you aren’t the <em>“install things on my computer”</em> kind of human, you might prefer to hop on <a href="http://codepen.io/">CodePen</a> and then click on the gear icon for JavaScript — <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em> Another alternative that’s also quite useful is to use Babel’s <a href="http://babeljs.io/repl/">online REPL</a> <em>— it’ll show you compiled ES5 code to the right of your ES6 code for quick comparison.</em></p></blockquote>

<p>Before getting into it, let me <a href="https://www.patreon.com/bevacqua"><em>shamelessly ask for your support</em></a> if you’re enjoying my ES6 in Depth series. Your contributions will go towards helping me keep up with the schedule, server bills, keeping me fed, and maintaining <strong>Pony Foo</strong> as a veritable source of JavaScript goodies.</p>

<p>Thanks for listening to that, and let’s go into generators now! If you haven’t yet, you should read yesterday’s article on <a href="#es6-iterators-in-depth">iterators</a>, as this article pretty much assumes that you’ve read it.</p></section>

<section class="md-markdown at-body">



<h2 id="generator-functions-and-generator-objects"><span class="md-heading">Generator Functions and Generator Objects</span></h2>

<p>Generators are a new feature in ES6. You declare a <em>generator function</em> which returns generator objects <code class="md-code md-code-inline">g</code> that can then be iterated using any of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from" aria-label="Array.from() on MDN"><code class="md-code md-code-inline">Array.from(g)</code></a>, <a href="#es6-spread-and-butter-in-depth" aria-label="ES6 Spread and Butter in Depth"><code class="md-code md-code-inline">[...g]</code></a>, or <a href="#es6-iterators-in-depth" aria-label="ES6 Iterators in Depth"><code class="md-code md-code-inline">for value of g</code></a> loops. Generator functions allow you to declare a special kind of <em>iterator</em>. These iterators can suspend execution while retaining their context. We already examined iterators in <a href="#es6-iterators-in-depth" aria-label="ES6 Iterators in Depth">the previous article</a> and how their <code class="md-code md-code-inline">.next()</code> method is called once at a time to pull values from a sequence.</p>

<p>Here is an example generator function. Note the <code class="md-code md-code-inline">*</code> after <code class="md-code md-code-inline">function</code>. That’s not a typo, that’s how you mark a generator function as a <em>generator</em>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span>* <span class="fn">generator</span> <span class="params">()</span> </span>{
  <span class="kw3">yield</span> <span class="str">'f'</span>
  <span class="kw3">yield</span> <span class="str">'o'</span>
  <span class="kw3">yield</span> <span class="str">'o'</span>
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Generator objects conform to both the <em>iterable</em> protocol and the <em>iterator</em> protocol. This means…</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">g</span> <span class="op">=</span> <mark class="md-mark md-code-mark"><span class="fn">generator</span>()</mark>
<span class="com">// a generator object g is built using the generator function</span>
<span class="kw">typeof</span> <span class="var">g</span>[<span class="md-code-symbol">Symbol</span>.<span class="built_in">iterator</span>] <span class="op">===</span> <span class="str">'function'</span>
<span class="com">// it's an iterable because it has an @@iterator</span>
<span class="kw">typeof</span> <span class="var">g</span>.<span class="built_in">next</span> <span class="op">===</span> <span class="str">'function'</span>
<span class="com">// it's also an iterator because it has a .next method</span>
<span class="var">g</span>[<span class="md-code-symbol">Symbol</span>.<span class="built_in">iterator</span>]() <span class="op">===</span> <span class="var">g</span>
<span class="com">// the iterator for a generator object is the generator object itself</span>
<span class="kw4">console.log</span>(<mark class="md-mark md-code-mark">[<span class="op">...</span><span class="var">g</span>]</mark>)
<span class="com">// &lt;- ['f', 'o', 'o']</span>
<span class="kw4">console.log</span>(<mark class="md-mark md-code-mark"><span class="kw">Array</span>.<span class="built_in">from</span>(<span class="var">g</span>)</mark>)
<span class="com">// &lt;- ['f', 'o', 'o']</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p><em>(This article is starting to sound an awful lot like a Math course…)</em></p>

<p>When you create a generator object <em>(I’ll just say “generator” from here on out)</em>, you’ll get an <em>iterator</em> that uses the generator to produce its <em>sequence</em>. Whenever a <code class="md-code md-code-inline">yield</code> expression is reached, that value is emitted by the iterator and <strong>function execution is suspended</strong>.</p>

<p>Let’s use a different example, this time with some other statements mixed in between <code class="md-code md-code-inline">yield</code> expressions. This is a simple generator but it behaves in an interesting enough way for our purposes here.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span>* <span class="fn">generator</span> <span class="params">()</span> </span>{
  <span class="kw3">yield</span> <span class="str">'p'</span>
  <span class="kw4">console.log</span>(<span class="str">'o'</span>)
  <span class="kw3">yield</span> <span class="str">'n'</span>
  <span class="kw4">console.log</span>(<span class="str">'y'</span>)
  <span class="kw3">yield</span> <span class="str">'f'</span>
  <span class="kw4">console.log</span>(<span class="str">'o'</span>)
  <span class="kw3">yield</span> <span class="str">'o'</span>
  <span class="kw4">console.log</span>(<span class="str">'!'</span>)
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>If we use a <code class="md-code md-code-inline">for..of</code> loop, this will print <code class="md-code md-code-inline">ponyfoo!</code> one character at a time, as expected.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">foo</span> <span class="op">=</span> <span class="fn">generator</span>()
<span class="kw3">for</span> (<mark class="md-mark md-code-mark"><span class="kw">let</span> <span class="var">pony</span> <span class="kw">of</span> <span class="var">foo</span></mark>) {
  <span class="kw4">console.log</span>(<span class="var">pony</span>)
  <span class="com">// &lt;- 'p'</span>
  <span class="com">// &lt;- 'o'</span>
  <span class="com">// &lt;- 'n'</span>
  <span class="com">// &lt;- 'y'</span>
  <span class="com">// &lt;- 'f'</span>
  <span class="com">// &lt;- 'o'</span>
  <span class="com">// &lt;- 'o'</span>
  <span class="com">// &lt;- '!'</span>
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>What about using the spread <code class="md-code md-code-inline">[...foo]</code> syntax? Things turn out a little different here. This might be a little unexpected, but that’s how generators work, everything that’s not yielded ends up becoming <strong>a side effect</strong>. As the sequence is being constructed, the <code class="md-code md-code-inline">console.log</code> statements in between <code class="md-code md-code-inline">yield</code> calls are executed, and they print characters to the console before <code class="md-code md-code-inline">foo</code> is spread over an array. The previous example worked because we were printing characters as soon as they were pulled from the sequence, instead of waiting to construct a range for the entire sequence first.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">foo</span> <span class="op">=</span> <span class="fn">generator</span>()
<span class="kw4">console.log</span>(<mark class="md-mark md-code-mark">[<span class="op">...</span><span class="var">foo</span>]</mark>)
<span class="com">// &lt;- 'o'</span>
<span class="com">// &lt;- 'y'</span>
<span class="com">// &lt;- 'o'</span>
<span class="com">// &lt;- '!'</span>
<span class="com">// &lt;- ['p', 'n', 'f', 'o']</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>A neat aspect of generator functions is that you can also use <code class="md-code md-code-inline">yield*</code> to delegate to another generator function. Want a very contrived way to split <code class="md-code md-code-inline">'ponyfoo'</code> into individual characters? Since strings in ES6 adhere to the <em>iterable</em> protocol, you could do the following.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span>* <span class="fn">generator</span> <span class="params">()</span> </span>{
  <span class="kw3">yield</span>* <span class="str">'ponyfoo'</span>
}
<span class="kw4">console.log</span>([<span class="op">...</span><span class="fn">generator</span>()])
<span class="com">// &lt;- ['p', 'o', 'n', 'y', 'f', 'o', 'o']</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Of course, in the real world you could just do <code class="md-code md-code-inline">[...'ponyfoo']</code>, since spread supports iterables just fine. Just like you could <code class="md-code md-code-inline">yield*</code> a string, you can <code class="md-code md-code-inline">yield*</code> anything that adheres to the iterable protocol. That includes other generators, arrays, and come ES6 — <em>just about anything.</em></p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">foo</span> <span class="op">=</span> {
  [<span class="md-code-symbol">Symbol</span>.<span class="built_in">iterator</span>]: () <span class="op">=&gt;</span> ({
    items: <mark class="md-mark md-code-mark">[<span class="str">'p'</span>, <span class="str">'o'</span>, <span class="str">'n'</span>, <span class="str">'y'</span>, <span class="str">'f'</span>, <span class="str">'o'</span>, <span class="str">'o'</span>]</mark>,
    next: <span class="md-code-function"><span class="kw">function</span> <span class="fn">next</span> <span class="params">()</span> </span>{
      <span class="kw3">return</span> {
        done: <span class="kw3">this</span>.items.<span class="built_in">length</span> <span class="op">===</span> <span class="num">0</span>,
        value: <span class="kw3">this</span>.items.<span class="built_in">shift</span>()
      }
    }
  })
}
<span class="md-code-function"><span class="kw">function</span>* <span class="fn">multiplier</span> <span class="params">(value)</span> </span>{
  <span class="kw3">yield</span> <span class="param">value</span> <span class="op">*</span> <span class="num">2</span>
  <span class="kw3">yield</span> <span class="param">value</span> <span class="op">*</span> <span class="num">3</span>
  <span class="kw3">yield</span> <span class="param">value</span> <span class="op">*</span> <span class="num">4</span>
  <span class="kw3">yield</span> <span class="param">value</span> <span class="op">*</span> <span class="num">5</span>
}
<span class="md-code-function"><span class="kw">function</span>* <span class="fn">trailmix</span> <span class="params">()</span> </span>{
  <span class="kw3">yield</span> <span class="num">0</span>
  <span class="kw3">yield*</span> [<span class="num">1</span>, <span class="num">2</span>]
  <span class="kw3">yield*</span> <mark class="md-mark md-code-mark">[<span class="op">...</span><span class="fn">multiplier</span>(<span class="num">2</span>)]</mark>
  <span class="kw3">yield*</span> <span class="fn">multiplier</span>(<span class="num">3</span>)
  <span class="kw3">yield*</span> <mark class="md-mark md-code-mark"><span class="var">foo</span></mark>
}
<span class="kw4">console.log</span>([<span class="op">...</span><span class="fn">trailmix</span>()])
<span class="com">// &lt;- [0, 1, 2, <mark class="md-mark md-code-mark">4, 6, 8, 10</mark>, 6, 9, 12, 15, <mark class="md-mark md-code-mark">'p', 'o', 'n', 'y', 'f', 'o', 'o'</mark>]</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>You could also iterate the sequence by hand, calling <code class="md-code md-code-inline">.next()</code>. This approach gives you the most control over the iteration, but it’s also the most involved. There’s a few features you can leverage here that give you even more control over the iteration.</p>



<h2 id="iterating-over-generators-by-hand"><span class="md-heading">Iterating Over Generators by Hand</span></h2>

<p>Besides iterating over <code class="md-code md-code-inline">trailmix</code> as we’ve already covered, using <code class="md-code md-code-inline">[...trailmix()]</code>, <code class="md-code md-code-inline">for value of trailmix()</code>, and <code class="md-code md-code-inline">Array.from(trailmix())</code>, we could use the generator returned by <code class="md-code md-code-inline">trailmix()</code> directly, and iterate over that. But <code class="md-code md-code-inline">trailmix</code> was an overcomplicated showcase of <code class="md-code md-code-inline">yield*</code>, let’s go back to the <em>side-effects</em> <code class="md-code md-code-inline">generator</code> for this one.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span>* <span class="fn">generator</span> <span class="params">()</span> </span>{
  <span class="kw3">yield</span> <span class="str">'p'</span>
  <span class="kw4">console.log</span>(<span class="str">'o'</span>)
  <span class="kw3">yield</span> <span class="str">'n'</span>
  <span class="kw4">console.log</span>(<span class="str">'y'</span>)
  <span class="kw3">yield</span> <span class="str">'f'</span>
  <span class="kw4">console.log</span>(<span class="str">'o'</span>)
  <span class="kw3">yield</span> <span class="str">'o'</span>
  <span class="kw4">console.log</span>(<span class="str">'!'</span>)
}
<span class="kw">var</span> <span class="var">g</span> <span class="op">=</span> <span class="fn">generator</span>()
<span class="kw">while</span> (<span class="md-code-boolean">true</span>) {
  <span class="kw">let</span> <span class="var">item</span> <span class="op">=</span> <mark class="md-mark md-code-mark"><span class="var">g</span>.<span class="built_in">next</span>()</mark>
  <span class="kw">if</span> (<span class="var">item</span>.<span class="built_in">done</span>) {
    <span class="kw3">break</span>
  }
  <span class="kw4">console.log</span>(<span class="var">item</span>.<span class="built_in">value</span>)
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Just like we <a href="#es6-iterators-in-depth" aria-label="ES6 Iterators in Depth">learned yesterday</a>, any items returned by an iterator will have a <code class="md-code md-code-inline">done</code> property that indicates whether the sequence has reached its end, and a <code class="md-code md-code-inline">value</code> indicating the current value in the sequence.</p><blockquote>

<p>If you’re confused as to <strong>why the <code class="md-code md-code-inline">'!'</code> is printed</strong> even though there are no more <code class="md-code md-code-inline">yield</code> expressions after it, that’s because <code class="md-code md-code-inline">g.next()</code> doesn’t know that. The way it works is that each time its called, it executes the method until a <code class="md-code md-code-inline">yield</code> expression is reached, emits its value and <em>suspends execution</em>. The next time <code class="md-code md-code-inline">g.next()</code> is called, _execution is resumed _from where it left off <em>(the last <code class="md-code md-code-inline">yield</code> expression)</em>, until the next <code class="md-code md-code-inline">yield</code> expression is reached. When no <code class="md-code md-code-inline">yield</code> expression is reached, the generator returns <code class="md-code md-code-inline">{ done: true }</code>, signaling that the sequence has ended. At this point, the <code class="md-code md-code-inline">console.log('!')</code> statement has been already executed, though.</p>

<p>It’s also worth noting that <strong>context is preserved</strong> across suspensions and resumptions. That means generators can be stateful. Generators are, in fact, the underlying implementation for <code class="md-code md-code-inline">async</code>/<code class="md-code md-code-inline">await</code> semantics coming in ES7.</p></blockquote>

<p>Whenever <code class="md-code md-code-inline">.next()</code> is called on a generator, there’s four “events” that will suspend execution in the generator, returning an <em><code class="md-code md-code-inline">IteratorResult</code></em> to the caller of <code class="md-code md-code-inline">.next()</code>.</p><ul>
  <li>A <code class="md-code md-code-inline">yield</code> expression returning the <em>next</em> value in the sequence</li>
  <li>A <code class="md-code md-code-inline">return</code> statement returning the <em>last</em> value in the sequence</li>
  <li>A <code class="md-code md-code-inline">throw</code> statement halts execution in the generator entirely</li>
  <li>Reaching the end of the generator function signals <code class="md-code md-code-inline">{ done: true }</code></li></ul>

<p>Once the <code class="md-code md-code-inline">g</code> generator ended iterating over a sequence, subsequent calls to <code class="md-code md-code-inline">g.next()</code> will have no effect and just return <code class="md-code md-code-inline">{ done: true }</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span>* <span class="fn">generator</span> <span class="params">()</span> </span>{
  <span class="kw3">yield</span> <span class="str">'only'</span>
}
<span class="kw">var</span> <span class="var">g</span> <span class="op">=</span> <span class="fn">generator</span>()
<span class="kw4">console.log</span>(<span class="var">g</span>.<span class="built_in">next</span>())
<span class="com">// &lt;- { done: false, value: 'only' }</span>
<span class="kw4">console.log</span>(<span class="var">g</span>.<span class="built_in">next</span>())
<span class="com">// &lt;- { done: true }</span>
<span class="kw4">console.log</span>(<span class="var">g</span>.<span class="built_in">next</span>())
<span class="com">// &lt;- { done: true }</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->




<h2 id="generators-the-del-weird-del-ins-awesome-ins-parts"><span class="md-heading">Generators: The <del>Weird</del> <ins><em>Awesome</em></ins> Parts</span></h2>

<p>Generator objects come with a couple more methods besides <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/next" aria-label="Generator.prototype.next() on MDN"><code class="md-code md-code-inline">.next</code></a>. These are <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/return" aria-label="Generator.prototype.return() on MDN"><code class="md-code md-code-inline">.return</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/throw" aria-label="Generator.prototype.throw() on MDN"><code class="md-code md-code-inline">.throw</code></a>. We’ve already covered <code class="md-code md-code-inline">.next</code> extensively, but not quite. You could also use <code class="md-code md-code-inline">.next(value)</code> to send values <em>into the generator</em>.</p>

<p>Let’s make <strong>a magic 8-ball generator</strong>. First off, you’ll need some answers. Wikipedia obliges, yielding <a href="https://en.wikipedia.org/wiki/Magic_8-Ball#Possible_answers" aria-label="Magic 8 Ball Possible Answers on Wikipedia">20 possible answers</a> for our magic 8-ball.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">answers</span> <span class="op">=</span> [
  <span class="str">`It is certain`, `It is decidedly so`, `Without a doubt`,
  `Yes definitely`, `You may rely on it`, `As I see it, yes`,
  `Most likely`, `Outlook good`, `Yes`, `Signs point to yes`,
  `Reply hazy try again`, `Ask again later`, `Better not tell you now`,
  `Cannot predict now`, `Concentrate and ask again`,
  `Don't count on it`, `My reply is no`, `My sources say no`,
  `Outlook not so good`, `Very doubtful`</span>
]
<span class="kw">function</span> <span class="fn">answer</span> () {
  <span class="kw3">return</span> <span class="var">answers</span>[<span class="kw">Math</span>.<span class="built_in">floor</span>(<span class="kw">Math</span>.<span class="built_in">random</span>() <span class="op">*</span> <span class="var">answers</span>.<span class="built_in">length</span>)]
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The following generator function can act as a <em>“genie”</em> that answers any questions you might have for them. Note how we discard the first result from <code class="md-code md-code-inline">g.next()</code>. That’s because the first call to <code class="md-code md-code-inline">.next</code> enters the generator and there’s no <code class="md-code md-code-inline">yield</code> expression waiting to capture the <code class="md-code md-code-inline">value</code> from <code class="md-code md-code-inline">g.next(value)</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span>* <span class="fn">chat</span> <span class="params">()</span> </span>{
  <span class="kw">while</span> (<span class="md-code-boolean">true</span>) {
    <span class="kw">let</span> <span class="var">question</span> <span class="op">=</span> <span class="kw3">yield</span> <span class="str">'[Genie] '</span> <span class="op">+</span> <span class="fn">answer</span>()
    <span class="kw4">console.log</span>(<span class="var">question</span>)
  }
}
<span class="kw">var</span> <span class="var">g</span> <span class="op">=</span> <span class="fn">chat</span>()
<mark class="md-mark md-code-mark"><span class="var">g</span>.<span class="built_in">next</span>()</mark>
<span class="kw4">console.log</span>(<span class="var">g</span>.<span class="built_in">next</span>(<span class="str">'[Me] Will ES6 die a painful death?'</span>).<span class="built_in">value</span>)
<span class="com">// &lt;- '[Me] Will ES6 die a painful death?'</span>
<span class="com">// &lt;- '[Genie] My sources say no'</span>
<span class="kw4">console.log</span>(<span class="var">g</span>.<span class="built_in">next</span>(<span class="str">'[Me] How youuu doing?'</span>).<span class="built_in">value</span>)
<span class="com">// &lt;- '[Me] How youuu doing?'</span>
<span class="com">// &lt;- '[Genie] Concentrate and ask again'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Randomly dropping <code class="md-code md-code-inline">g.next()</code> feels like a very dirty coding practice, though. What else could we do? We could flip responsibilities around.</p>



<h3 id="inversion-of-control"><span class="md-heading">Inversion of Control</span></h3>

<p>We could have the Genie be in control, and have the generator ask the questions. How would that look like? At first, you might think that the code below is unconventional, but in fact, most libraries built around generators work by inverting responsibility.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span>* <span class="fn">chat</span> <span class="params">()</span> </span>{
  <span class="kw3">yield</span> <span class="str">'[Me] Will ES6 die a painful death?'</span>
  <span class="kw3">yield</span> <span class="str">'[Me] How youuu doing?'</span>
}
<span class="kw">var</span> <span class="var">g</span> <span class="op">=</span> <span class="fn">chat</span>()
<span class="kw">while</span> (<span class="md-code-boolean">true</span>) {
  <span class="kw">let</span> <span class="var">question</span> <span class="op">=</span> <span class="var">g</span>.<span class="built_in">next</span>()
  <span class="kw">if</span> (<span class="var">question</span>.<span class="built_in">done</span>) {
    <span class="kw3">break</span>
  }
  <span class="kw4">console.log</span>(<span class="var">question</span>.<span class="built_in">value</span>)
  <span class="kw4">console.log</span>(<span class="str">'[Genie] '</span> <span class="op">+</span> <span class="fn">answer</span>())
  <span class="com">// &lt;- '[Me] Will ES6 die a painful death?'</span>
  <span class="com">// &lt;- '[Genie] Very doubtful'</span>
  <span class="com">// &lt;- '[Me] How youuu doing?'</span>
  <span class="com">// &lt;- '[Genie] My reply is no'</span>
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>You would expect the <strong>generator to do the heavy lifting</strong> of an iteration, but in fact generators make it easy to iterate over things by suspending execution of themselves — and deferring the heavy lifting. That’s one of the most powerful aspects of generators. Suppose now that the iterator is a <code class="md-code md-code-inline">genie</code> method in a library, like so:</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">genie</span> <span class="params">(questions)</span> </span>{
  <span class="kw">var</span> <span class="var">g</span> <span class="op">=</span> <span class="param">questions</span>()
  <span class="kw">while</span> (<span class="md-code-boolean">true</span>) {
    <span class="kw">let</span> <span class="var">question</span> <span class="op">=</span> <span class="var">g</span>.<span class="built_in">next</span>()
    <span class="kw">if</span> (<span class="var">question</span>.<span class="built_in">done</span>) {
      <span class="kw3">break</span>
    }
    <span class="kw4">console.log</span>(<span class="var">question</span>.<span class="built_in">value</span>)
    <span class="kw4">console.log</span>(<span class="str">'[Genie] '</span> <span class="op">+</span> <span class="fn">answer</span>())
  }
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>To use it, all you’d have to do is pass in a simple generator like the one we just made.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">genie(<span class="md-code-function"><span class="kw">function</span>* <span class="fn">questions</span> <span class="params">()</span> </span>{
  <span class="kw3">yield</span> <span class="str">'[Me] Will ES6 die a painful death?'</span>
  <span class="kw3">yield</span> <span class="str">'[Me] How youuu doing?'</span>
})
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Compare that to the generator we had before, where questions were sent to the generator instead of the other way around. See how much more complicated the logic would have to be to achieve the same goal? Letting the library deal with the flow control means you can <strong>just worry about the <em>thing</em> you want to iterate</strong> over, and you can <strong>delegate <em>how</em> to iterate over it</strong>. But yes, it does mean your code now has an asterisk in it. <em>Weird.</em></p>



<h3 id="dealing-with-asynchronous-flows"><span class="md-heading">Dealing with asynchronous flows</span></h3>

<p>Imagine now that the <code class="md-code md-code-inline">genie</code> library gets its magic 8-ball answers from an API. How does that look then? Probably something like the snippet below. Assume the <a href="https://github.com/Raynos/xhr" aria-label="Raynos/xhr on GitHub"><code class="md-code md-code-inline">xhr</code></a> pseudocode call always yields JSON responses like <code class="md-code md-code-inline">{ answer: 'No' }</code>. Keep in mind this is a simple example that just processes each question in series. You could put together different and more complex flow control algorithms depending on what you’re looking for.</p>

<p>This is just a demonstration of the sheer power of generators.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">genie</span> <span class="params">(questions)</span> </span>{
  <span class="kw">var</span> <span class="var">g</span> <span class="op">=</span> <span class="param">questions</span>()
  <span class="fn">pull</span>()
  <span class="md-code-function"><span class="kw">function</span> <span class="fn">pull</span> <span class="params">()</span> </span>{
    <span class="kw">let</span> <span class="var">question</span> <span class="op">=</span> <mark class="md-mark md-code-mark"><span class="var">g</span>.<span class="built_in">next</span>()</mark>
    <span class="kw">if</span> (<span class="var">question</span>.<span class="built_in">done</span>) {
      <span class="kw3">return</span>
    }
    <span class="fn">ask</span>(<span class="var">question</span>.<span class="built_in">value</span>, <span class="fn">pull</span>)
  }
  <span class="md-code-function"><span class="kw">function</span> <span class="fn">ask</span> <span class="params">(q, next)</span> </span>{
    <mark class="md-mark md-code-mark">xhr(<span class="str">'https://computer.genie/?q='</span> <span class="op">+</span> <span class="built_in">encodeURIComponent</span>(<span class="param">q</span>), got)</mark>
    <span class="md-code-function"><span class="kw">function</span> <span class="fn">got</span> <span class="params">(err, res, body)</span> </span>{
      <span class="kw">if</span> (<span class="param">err</span>) {
        <span class="com">// todo</span>
      }
      <span class="kw4">console.log</span>(<span class="param">q</span>)
      <span class="kw4">console.log</span>(<span class="str">'[Genie] '</span> <span class="op">+</span> <span class="param">body</span>.answer)
      <span class="param">next</span>()
    }
  }
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p><sub>See <a href="http://buff.ly/1UimWsZ" aria-label="Babel REPL of async generator for genie responses">this link for a live demo</a> on the Babel REPL</sub></p>

<p>Even though we’ve just made our <code class="md-code md-code-inline">genie</code> method asynchronous and are now using an API to fetch responses to the user’s questions, the way the consumer uses the <code class="md-code md-code-inline">genie</code> library by passing a <code class="md-code md-code-inline">questions</code> generator function <em>remains unchanged!</em> That’s awesome.</p>

<p>We haven’t handled the case for an <code class="md-code md-code-inline">err</code> coming out of the API. That’s inconvenient. What can we do about that one?</p>



<h3 id="throwing-at-a-generator"><span class="md-heading">Throwing <em>at</em> a Generator</span></h3>

<p>Now that we’ve figured out that the most important aspect of generators is <em>actually the control flow code</em> that decides when to call <code class="md-code md-code-inline">g.next()</code>, we can look at the other two methods and actually understand their purpose. Before shifting our thinking into <em>"the generator defines <strong>what</strong> to iterate over, not the <strong>how</strong>"</em>, we would’ve been hard pressed to find a user case for <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/throw" aria-label="Generator.prototype.throw() on MDN"><code class="md-code md-code-inline">g.throw</code></a>. Now however it seems immediately obvious. The flow control that leverages a generator needs to be able to tell the generator that’s yielding the sequence to be iterated when something goes wrong processing an item in the sequence.</p>

<p>In the case of our <code class="md-code md-code-inline">genie</code> flow, that is now using <a href="https://github.com/Raynos/xhr" aria-label="Raynos/xhr on GitHub"><code class="md-code md-code-inline">xhr</code></a>, we may experience network issues and be unable to continue processing items, or we may want to warn the user about unexpected errors. Here’s how, we simply add <code class="md-code md-code-inline">g.throw(error)</code> in our control flow code.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">genie</span> <span class="params">(questions)</span> </span>{
  <span class="kw">var</span> <span class="var">g</span> <span class="op">=</span> <span class="param">questions</span>()
  <span class="fn">pull</span>()
  <span class="md-code-function"><span class="kw">function</span> <span class="fn">pull</span> <span class="params">()</span> </span>{
    <span class="kw">let</span> <span class="var">question</span> <span class="op">=</span> <span class="var">g</span>.<span class="built_in">next</span>()
    <span class="kw">if</span> (<span class="var">question</span>.<span class="built_in">done</span>) {
      <span class="kw3">return</span>
    }
    <span class="fn">ask</span>(<span class="var">question</span>.<span class="built_in">value</span>, <span class="fn">pull</span>)
  }
  <span class="md-code-function"><span class="kw">function</span> <span class="fn">ask</span> <span class="params">(q, next)</span> </span>{
    xhr(<span class="str">'https://computer.genie/?q='</span> <span class="op">+</span> <span class="built_in">encodeURIComponent</span>(<span class="param">q</span>), <span class="fn">got</span>)
    <span class="md-code-function"><span class="kw">function</span> <span class="fn">got</span> <span class="params">(err, res, body)</span> </span>{
      <span class="kw">if</span> (<span class="param">err</span>) {
        <mark class="md-mark md-code-mark"><span class="var">g</span>.<span class="built_in">throw</span>(<span class="param">err</span>)</mark>
      }
      <span class="kw4">console.log</span>(<span class="param">q</span>)
      <span class="kw4">console.log</span>(<span class="str">'[Genie] '</span> <span class="op">+</span> <span class="param">body</span>.answer)
      <span class="param">next</span>()
    }
  }
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The <em>user code</em> is still unchanged, though. In between <code class="md-code md-code-inline">yield</code> statements it may throw errors now. You could use <code class="md-code md-code-inline">try</code>/<code class="md-code md-code-inline">catch</code> blocks to address those issues. If you do this, execution will be able to resume. The good thing is that this is up to the user, it’s still perfectly sequential on their end, and they can leverage <code class="md-code md-code-inline">try</code>/<code class="md-code md-code-inline">catch</code> semantics just like in high-school.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">genie(<span class="md-code-function"><span class="kw">function</span>* <span class="fn">questions</span> <span class="params">()</span> </span>{
  <span class="kw">try</span> {
    <span class="kw3">yield</span> <span class="str">'[Me] Will ES6 die a painful death?'</span>
  } <span class="kw">catch</span> (e) {
    <span class="kw4">console.error</span>(<span class="str">'Error'</span>, e.<span class="built_in">message</span>)
  }
  <span class="kw">try</span> {
    <span class="kw3">yield</span> <span class="str">'[Me] How youuu doing?'</span>
  } <span class="kw">catch</span> (e) {
    <span class="kw4">console.error</span>(<span class="str">'Error'</span>, e.<span class="built_in">message</span>)
  }
})
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->




<h3 id="returning-on-behalf-of-a-generator"><span class="md-heading">Returning on Behalf of a Generator</span></h3>

<p>Usually not as interesting in asynchronous control flow mechanisms in general, the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/return" aria-label="Generator.prototype.return() on MDN"><code class="md-code md-code-inline">g.return()</code></a> method allows you to resume execution inside a generator function, much like <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/throw" aria-label="Generator.prototype.throw() on MDN"><code class="md-code md-code-inline">g.throw()</code></a> did moments earlier. The key difference is that <code class="md-code md-code-inline">g.return()</code> won’t result in an exception at the generator level, although <strong>it will end the sequence.</strong></p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span>* <span class="fn">numbers</span> <span class="params">()</span> </span>{
  <span class="kw3">yield</span> <span class="num">1</span>
  <span class="kw3">yield</span> <span class="num">2</span>
  <span class="kw3">yield</span> <span class="num">3</span>
}
<span class="kw">var</span> <span class="var">g</span> <span class="op">=</span> <span class="fn">numbers</span>()
<span class="kw4">console.log</span>(<span class="var">g</span>.<span class="built_in">next</span>())
<span class="com">// &lt;- { done: false, value: 1 }</span>
<span class="kw4">console.log</span>(<mark class="md-mark md-code-mark"><span class="var">g</span>.<span class="built_in">return</span>()</mark>)
<span class="com">// &lt;- { done: true }</span>
<span class="kw4">console.log</span>(<span class="var">g</span>.<span class="built_in">next</span>())
<span class="com">// &lt;- { done: true }, <mark class="md-mark md-code-mark">as we know</mark></span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>You could also return a <code class="md-code md-code-inline">value</code> using <code class="md-code md-code-inline">g.return(value)</code>, and the resulting <code class="md-code md-code-inline">IteratorResult</code> will contain said <code class="md-code md-code-inline">value</code>. This is equivalent to having <code class="md-code md-code-inline">return value</code> somewhere in the generator function. You should be careful there though — as neither <code class="md-code md-code-inline">for..of</code>, <code class="md-code md-code-inline">[...generator()]</code>, nor <code class="md-code md-code-inline">Array.from(generator())</code> include the <code class="md-code md-code-inline">value</code> in the <code class="md-code md-code-inline">IteratorResult</code> that signals <code class="md-code md-code-inline">{ done: true }</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span>* <span class="fn">numbers</span> <span class="params">()</span> </span>{
  <span class="kw3">yield</span> <span class="num">1</span>
  <span class="kw3">yield</span> <span class="num">2</span>
  <mark class="md-mark md-code-mark"><span class="kw3">return</span> <span class="num">3</span></mark>
  <span class="kw3">yield</span> <span class="num">4</span>
}
<span class="kw4">console.log</span>([<span class="op">...</span><span class="fn">numbers</span>()])
<span class="com">// &lt;- <mark class="md-mark md-code-mark">[1, 2]</mark></span>
<span class="kw4">console.log</span>(<span class="kw">Array</span>.<span class="built_in">from</span>(<span class="fn">numbers</span>()))
<span class="com">// &lt;- [1, 2]</span>
<span class="kw3">for</span> (<span class="kw">let</span> <span class="var">n</span> <span class="kw">of</span> <span class="fn">numbers</span>()) {
  <span class="kw4">console.log</span>(<span class="var">n</span>)
  <span class="com">// &lt;- 1</span>
  <span class="com">// &lt;- 2</span>
}
<span class="kw">var</span> <span class="var">g</span> <span class="op">=</span> <span class="fn">numbers</span>()
<span class="kw4">console.log</span>(<span class="var">g</span>.<span class="built_in">next</span>())
<span class="com">// &lt;- { done: false, value: 1 }</span>
<span class="kw4">console.log</span>(<span class="var">g</span>.<span class="built_in">next</span>())
<span class="com">// &lt;- { done: false, value: 2 }</span>
<span class="kw4">console.log</span>(<span class="var">g</span>.<span class="built_in">next</span>())
<span class="com">// &lt;- { done: true, <mark class="md-mark md-code-mark">value: 3</mark> }</span>
<span class="kw4">console.log</span>(<span class="var">g</span>.<span class="built_in">next</span>())
<span class="com">// &lt;- { done: true }</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Using <code class="md-code md-code-inline">g.return</code> is no different in this regard, think of it as the programmatic equivalent of what we just did.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span>* <span class="fn">numbers</span> <span class="params">()</span> </span>{
  <span class="kw3">yield</span> <span class="num">1</span>
  <span class="kw3">yield</span> <span class="num">2</span>
  <span class="kw3">return</span> <span class="num">3</span>
  <span class="kw3">yield</span> <span class="num">4</span>
}
<span class="kw">var</span> <span class="var">g</span> <span class="op">=</span> <span class="fn">numbers</span>()
<span class="kw4">console.log</span>(<span class="var">g</span>.<span class="built_in">next</span>())
<span class="com">// &lt;- { done: false, value: 1 }</span>
<span class="kw4">console.log</span>(<span class="var">g</span>.<span class="built_in">return</span>(<span class="num">5</span>))
<span class="com">// &lt;- { done: true, value: 5 }</span>
<span class="kw4">console.log</span>(<span class="var">g</span>.<span class="built_in">next</span>())
<span class="com">// &lt;- { done: true }</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>You can avoid the impending sequence termination, <a href="http://www.2ality.com/2015/03/es6-generators.html" aria-label="ES6 generators in depth by Dr. Axel Rauschmayer">as Axel points out</a>, if the code in the generator function when <code class="md-code md-code-inline">g.return()</code> got called is wrapped in <code class="md-code md-code-inline">try</code>/<code class="md-code md-code-inline">finally</code>. Once the <code class="md-code md-code-inline">yield</code> expressions in the <code class="md-code md-code-inline">finally</code> block are over, the sequence <em>will</em> end with the <code class="md-code md-code-inline">value</code> passed to <code class="md-code md-code-inline">g.return(value)</code></p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span>* <span class="fn">numbers</span> <span class="params">()</span> </span>{
  <span class="kw3">yield</span> <span class="num">1</span>
  <span class="kw">try</span> {
    <span class="kw3">yield</span> <span class="num">2</span>
  } <span class="kw">finally</span> {
    <span class="kw3">yield</span> <span class="num">3</span>
    <span class="kw3">yield</span> <span class="num">4</span>
  }
  <span class="kw3">yield</span> <span class="num">5</span>
}
<span class="kw">var</span> <span class="var">g</span> <span class="op">=</span> <span class="fn">numbers</span>()
<span class="kw4">console.log</span>(<span class="var">g</span>.<span class="built_in">next</span>())
<span class="com">// &lt;- { done: false, value: 1 }</span>
<span class="kw4">console.log</span>(<span class="var">g</span>.<span class="built_in">next</span>())
<span class="com">// &lt;- { done: false, value: 2 }</span>
<span class="kw4">console.log</span>(<mark class="md-mark md-code-mark"><span class="var">g</span>.<span class="built_in">return</span>(<span class="num">6</span>)</mark>)
<span class="com">// &lt;- { done: false, value: 3 }</span>
<span class="kw4">console.log</span>(<span class="var">g</span>.<span class="built_in">next</span>())
<span class="com">// &lt;- { done: false, value: 4 }</span>
<span class="kw4">console.log</span>(<span class="var">g</span>.<span class="built_in">next</span>())
<span class="com">// &lt;- { done: true, <mark class="md-mark md-code-mark">value: 6</mark> }</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>That’s all there is to know when it comes to generators <em>in terms of functionality.</em></p>



<h2 id="use-cases-for-es6-generators"><span class="md-heading">Use Cases for ES6 Generators</span></h2>

<p>At this point in the article you should feel comfortable with the concepts of iterators, iterables, and generators in ES6. If you feel like reading more on the subject, I highly recommend you go over <a href="http://www.2ality.com/2015/03/es6-generators.html" aria-label="ES6 generators in depth by Dr. Axel Rauschmayer">Axel’s article on generators</a>, as he put together an amazing write-up on use cases for generators just <em>a few months ago</em>.</p></section></section>

</article>

</div>
<p><a href="#top" class="top"><img src="./auxi/glyphicons-214-up-arrow.png" alt="up-arrow" class="uparrow" /> <b>Back to top</b></a></p>
</section></main>

<!--  generators ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->
<!--  ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->









<!--  symbols ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->

<main class="ly-main"><header class="at-header">



<h1 itemprop="headline" class="dc-title" id="es6-symbols-in-depth">ES6 Symbols in Depth</h1></header><section class="at-teaser"><div class="at-teaser-markdown md-markdown">

<p>Buon giorno! Willkommen to ES6 — <em>“I can’t believe this is yet another installment”</em> — in Depth. If you have no idea how you got here or what ES6 even is, I recommend reading <a href="#a-brief-history-of-es6-tooling">A Brief History of ES6 Tooling</a>. Then, make your way through <a href="#es6-destructuring-in-depth">destructuring</a>, <a href="#es6-template-strings-in-depth">template literals</a>, <a href="#es6-arrow-functions-in-depth">arrow functions</a>, the <a href="#es6-spread-and-butter-in-depth">spread operator and rest parameters</a>, improvements coming to <a href="#es6-object-literal-features-in-depth">object literals</a>, the new <a href="#es6-classes-in-depth"><em>classes</em></a> sugar on top of prototypes, <a href="#es6-let-const-and-temporal-dead-zone-in-depth"><code class="md-code md-code-inline">let</code>, <code class="md-code md-code-inline">const</code>, and the <em>“Temporal Dead Zone”</em></a>, <a href="#es6-iterators-in-depth">iterators</a>, and <a href="#es6-generators-in-depth">generators</a>. Today we’ll be discussing <em>Symbols</em>.</p></div></section>
<section class="at-container de-host"><div class="de-column">

<article itemscope="itemscope" itemtype="http://schema.org/BlogPosting" class="at-article ly-section">
<meta itemprop="dateCreated" content="2015-09-01T02:53:23+00:00" />
<meta itemprop="datePublished" content="2015-09-09T12:12:01+00:00" />
<meta itemprop="dateModified" content="2015-10-11T04:06:37+00:00" />
<meta itemprop="keywords" content="es6,symbols,es6-in-depth" />

<section itemprop="articleBody" class="at-corpus">
<section itemprop="about" class="md-markdown at-introduction">
<blockquote>

<p>As I did in previous articles on the series, I would love to point out that you should probably <a href="#universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That’ll make it so much easier for you to <strong>internalize the concepts</strong> discussed in the series. If you aren’t the <em>“install things on my computer”</em> kind of human, you might prefer to hop on <a href="http://codepen.io/">CodePen</a> and then click on the gear icon for JavaScript — <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em> Another alternative that’s also quite useful is to use Babel’s <a href="http://babeljs.io/repl/">online REPL</a> <em>— it’ll show you compiled ES5 code to the right of your ES6 code for quick comparison.</em></p></blockquote>

<p>Before getting into it, let me <a href="https://www.patreon.com/bevacqua"><em>shamelessly ask for your support</em></a> if you’re enjoying my ES6 in Depth series. Your contributions will go towards helping me keep up with the schedule, server bills, keeping me fed, and maintaining <strong>Pony Foo</strong> as a veritable source of JavaScript goodies.</p>

<p>Thanks for listening to that, and let’s go into symbols now! For a bit of context, you may want to check out the last two articles, — on <a href="#es6-iterators-in-depth">iterators</a> and <a href="#es6-generators-in-depth">generators</a> — where we first talked about Symbols.</p></section><section class="md-markdown at-body">



<h2 id="what-are-symbols"><span class="md-heading">What are Symbols?</span></h2>

<p>Symbols are a new primitive type in ES6. If you ask me, they’re <em>an awful lot like strings</em>. Just like with numbers and strings, symbols also come with their accompanying <code class="md-code md-code-inline">Symbol</code> wrapper object.</p>

<p>We can create our own Symbols.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">mystery</span> <span class="op">=</span> <span class="md-code-symbol">Symbol</span>()()
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Note that there was no <code class="md-code md-code-inline">new</code>. The <code class="md-code md-code-inline">new</code> operator even throws a <code class="md-code md-code-inline">TypeError</code> when we try it on <code class="md-code md-code-inline">Symbol</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">oops</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-symbol">Symbol</span>()()
<span class="com">// &lt;- TypeError</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>For debugging purposes, you can describe symbols.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">mystery</span> <span class="op">=</span> <span class="md-code-symbol">Symbol</span>()(<span class="str">'this is a descriptive description'</span>)
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Symbols are <em>immutable</em>. Just like numbers or strings. Note however that symbols are <em>unique</em>, unlike primitive numbers and strings.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw4">console.log</span>(<span class="md-code-symbol">Symbol</span>() <span class="op">===</span> <span class="md-code-symbol">Symbol</span>()())
<span class="com">// &lt;- false</span>
<span class="kw4">console.log</span>(<span class="md-code-symbol">Symbol</span>(<span class="str">'foo'</span>) <span class="op">===</span> <span class="md-code-symbol">Symbol</span>()(<span class="str">'foo'</span>))
<span class="com">// &lt;- false</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Symbols are <em>symbols</em>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw4">console.log</span>(<span class="kw">typeof</span> <span class="md-code-symbol">Symbol</span>()())
<span class="com">// &lt;- 'symbol'</span>
<span class="kw4">console.log</span>(<span class="kw">typeof</span> <span class="md-code-symbol">Symbol</span>()(<span class="str">'foo'</span>))
<span class="com">// &lt;- 'symbol'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>There are three different flavors of symbols — each flavor is accessed in a different way. We’ll explore each of these and slowly figure out what all of this means.</p><ul>
  <li>You can access local symbols by obtaining a reference to them <em>directly</em></li>
  <li>You can place symbols on the <em>global registry</em> and access them across <em>realms</em></li>
  <li>“Well-known” symbols exist across <em>realms</em> — but you can’t create them and they’re not on the <em>global registry</em></li></ul>

<p>What the heck is a <em>realm</em>, you say? A <em>realm</em> is <strong>spec-speak</strong> for any execution context, such as the page your application is running in, or an <code class="md-code md-code-inline">&lt;iframe&gt;</code> within your page.</p>



<h2 id="the-runtime-wide-symbol-registry"><span class="md-heading">The “Runtime-Wide” Symbol Registry</span></h2>

<p>There’s two methods you can use to add symbols to the runtime-wide symbol registry: <code class="md-code md-code-inline">Symbol.for(key)</code> and <code class="md-code md-code-inline">Symbol.keyFor(symbol)</code>. What do these do?</p>



<h3 id="symbolfor-key"><span class="md-heading"><code class="md-code md-code-inline">Symbol.for(key)</code></span></h3>

<p>This method looks up <code class="md-code md-code-inline">key</code> in the runtime-wide symbol registry. If a symbol with that <code class="md-code md-code-inline">key</code> exists in the global registry, that symbol is returned. If no symbol with that <code class="md-code md-code-inline">key</code> is found in the registry, one is created. That’s to say, <code class="md-code md-code-inline">Symbol.for(key)</code> is <em>idempotent</em>. In the snippet below, the first call to <code class="md-code md-code-inline">Symbol.for('foo')</code> creates a symbol, adds it to the registry, and returns it. The second call returns that same symbol because the <code class="md-code md-code-inline">key</code> is already in the registry by then — and associated to the symbol returned by the first call.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-symbol">Symbol</span>.<span class="built_in">for</span>(<span class="str">'foo'</span>) <span class="op">===</span> <span class="md-code-symbol">Symbol</span>().<span class="built_in">for</span>(<span class="str">'foo'</span>)
<span class="com">// &lt;- true</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>That is in contrast to what we knew about symbols being unique. The global symbol registry however keeps track of symbols by a <code class="md-code md-code-inline">key</code>. Note that your <code class="md-code md-code-inline">key</code> will also be used as a <code class="md-code md-code-inline">description</code> when the symbols that go into the registry are created. Also note that these symbols are <strong>as global as globals get in JavaScript</strong>, so play nice and use a prefix and don’t just name your symbols <code class="md-code md-code-inline">'user'</code> or some generic name like that.</p>



<h3 id="symbolkeyfor-symbol"><span class="md-heading"><code class="md-code md-code-inline">Symbol.keyFor(symbol)</code></span></h3>

<p>Given a symbol <code class="md-code md-code-inline">symbol</code>, <code class="md-code md-code-inline">Symbol.keyFor(symbol)</code> returns the <code class="md-code md-code-inline">key</code> that was associated with <code class="md-code md-code-inline">symbol</code> when the symbol was added to the global registry.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">symbol</span> <span class="op">=</span> <span class="md-code-symbol">Symbol</span>.<span class="built_in">for</span>(<span class="str">'foo'</span>)
<span class="kw4">console.log</span>(<span class="md-code-symbol">Symbol</span>.<span class="built_in">keyFor</span>(<span class="var">symbol</span>))
<span class="com">// &lt;- 'foo'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->




<h3 id="how-wide-is-runtime-wide"><span class="md-heading">How Wide is Runtime-Wide?</span></h3>

<p>Runtime-wide means the symbols in the global registry are <em>accessible across code realms</em>. I’ll probably have more success explaining this with a piece of code. It just means the registry is shared across realms.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">frame</span> <span class="op">=</span> <span class="kw">document</span>.<span class="built_in">createElement</span>(<span class="str">'iframe'</span>)
<span class="kw">document</span>.<span class="built_in">body.appendChild</span>(<span class="var">frame</span>)
<span class="kw4">console.log</span>(<span class="md-code-symbol">Symbol</span>.<span class="built_in">for</span>(<span class="str">'foo'</span>) <span class="op">===</span> <span class="var">frame</span>.<span class="built_in">contentWindow</span>.<span class="md-code-symbol">Symbol</span>.<span class="built_in">for</span>(<span class="str">'foo'</span>))
<span class="com">// &lt;- true</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<h2 id="the-well-known-symbols"><span class="md-heading">The “Well-Known” Symbols</span></h2>

<p>Let me put you at ease: <strong>these aren’t actually well-known at all.</strong> Far from it. I didn’t have any idea these things existed until a few months ago. Why are they <em>“well-known”</em>, then? That’s because they are JavaScript <em>built-ins</em>, and they are used to control parts of the language. They weren’t exposed to user code before ES6, but now you can fiddle with them.</p>

<p>A great example of a <em>“well-known”</em> symbol is something we’ve already been playing with on Pony Foo: the <a href="#es6-iterators-in-depth" aria-label="ES6 Iterators in Depth"><code class="md-code md-code-inline">Symbol.iterator</code></a> well-known symbol. We used that symbol to define the <code class="md-code md-code-inline">@@iterator</code> method on objects that adhere to the <em>iterator</em> protocol. There’s <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Well-known_symbols" aria-label="Well-known symbols on MDN">a list of well-known symbols</a> on MDN, but few of them are documented at the time of this writing.</p>

<p>One of the well-known symbols that <em>is</em> documented at this time is <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/match" aria-label="Symbol.match on MDN"><code class="md-code md-code-inline">Symbol.match</code></a>. According to MDN, you can set the <code class="md-code md-code-inline">Symbol.match</code> property on regular expressions to <code class="md-code md-code-inline">false</code> and have them behave as string literals when matching <em>(instead of regular expressions, which don’t play nice with <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith" aria-label="String.prototype.startsWith() — MDN"><code class="md-code md-code-inline">.startsWith</code></a>, <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith" aria-label="String.prototype.endsWith() — MDN"><code class="md-code md-code-inline">.endsWith</code></a>, or <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/includes" aria-label="String.prototype.<span class="built_in">includes</span>() — MDN"><code class="md-code md-code-inline">.includes</code></a>)</em>.</p>

<p>This part of the spec hasn’t been implemented in Babel yet, <em>— I assume that’s just because it’s not worth the trouble –</em> but supposedly it goes like this.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">text</span> <span class="op">=</span> <span class="str">'/foo/'</span>
<span class="kw">var</span> <span class="var">literal</span> <span class="op">=</span> <span class="md-code-regexp">/foo/</span>
<mark class="md-mark md-code-mark"><span class="var">literal</span>[<span class="md-code-symbol">Symbol</span>.<span class="built_in">match</span>] <span class="op">=</span> <span class="md-code-bool">false</span></mark>
<span class="kw4">console.log</span>(<span class="var">text</span>.<span class="built_in">startsWith</span>(<span class="var">literal</span>))
<span class="com">// &lt;- true</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Why you’d want to do that instead of just casting <code class="md-code md-code-inline">literal</code> to a string <em>is beyond me</em>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">text</span> <span class="op">=</span> <span class="str">'/foo/'</span>
<span class="kw">var</span> <span class="var">casted</span> <span class="op">=</span> <span class="md-code-regexp">/foo/</span><mark class="md-mark md-code-mark">.<span class="built_in">toString</span>()</mark>
<span class="kw4">console.log</span>(<span class="var">text</span>.<span class="built_in">startsWith</span>(<span class="var">casted</span>))
<span class="com">// &lt;- true</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>I suspect the language has <strong>legitimate performance reasons</strong> that warrant the existence of this symbol, but I don’t think it’ll become a front-end development staple anytime soon.</p><blockquote>

<p>Regardless, <a href="#es6-iterators-in-depth" aria-label="ES6 Iterators in Depth"><code class="md-code md-code-inline">Symbol.iterator</code></a> is actually very useful, and I’m sure other well-known symbols are useful as well.</p></blockquote>

<p>Note that well-known symbols are unique, but <strong>shared across realms</strong>, even when they’re not accessible through the <em>global registry</em>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">frame</span> <span class="op">=</span> <span class="kw">document</span>.<span class="built_in">createElement</span>(<span class="str">'iframe'</span>)
<span class="kw">document.<span class="built_in">body.appendChild</span></span>(<span class="var">frame</span>)
<span class="kw4">console.log</span>(<span class="md-code-symbol">Symbol</span>.<span class="built_in">iterator</span> <span class="op">===</span> <span class="var">frame</span>.<span class="built_in">contentWindow</span>.<span class="md-code-symbol">Symbol</span>.<span class="built_in">iterator</span>)
<span class="com">// &lt;- true</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Not accessible through the <em>global registry</em>? Nope!</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw4">console.log</span>(<span class="md-code-symbol">Symbol</span>.<span class="built_in">keyFor</span>(<span class="md-code-symbol">Symbol</span>.<span class="built_in">iterator</span>))
<span class="com">// &lt;- undefined</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->

<p>Accessing them statically from anywhere should be more than enough, though.</p>



<h2 id="symbols-and-iteration"><span class="md-heading">Symbols and Iteration</span></h2>

<p>Any consumer of the <em>iterable</em> protocol obviously ignores symbols other than the well-known <a href="#es6-iterators-in-depth" aria-label="ES6 Iterators in Depth"><code class="md-code md-code-inline">Symbol.iterator</code></a> that would define how to iterate and help identify the object as an <em>iterable</em>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">foo</span> <span class="op">=</span> {
  [<span class="md-code-symbol">Symbol</span>()]: <span class="str">'foo'</span>,
  [<span class="md-code-symbol">Symbol</span>(<span class="str">'foo'</span>)]: <span class="str">'bar'</span>,
  [<span class="md-code-symbol">Symbol</span>.<span class="built_in">for</span>(<span class="str">'bar'</span>)]: <span class="str">'baz'</span>,
  what: <span class="str">'ever'</span>
}
<span class="kw4">console.log</span>([<span class="op">...</span><span class="var">foo</span>])
<span class="com">// &lt;- []</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The ES5 <code class="md-code md-code-inline">Object.keys</code> method ignores symbols.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw4">console.log</span>(<span class="cls">Object</span>.<span class="built_in">keys</span>(<span class="var">foo</span>))
<span class="com">// &lt;- ['what']</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Same goes for <code class="md-code md-code-inline">JSON.stringify</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw4">console.log</span>(<span class="cls">JSON</span>.<span class="built_in">stringify</span>(<span class="var">foo</span>))
<span class="com">// &lt;- {"what":"ever"}</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>So, <code class="md-code md-code-inline">for..in</code> then? Nope.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw3">for</span> (<span class="kw">let</span> <span class="var">key</span> <span class="kw">in</span> <span class="var">foo</span>) {
  <span class="kw4">console.log</span>(<span class="var">key</span>)
  <span class="com">// &lt;- 'what'</span>
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>I know, <code class="md-code md-code-inline">Object.getOwnPropertyNames</code>. Nah! <em>— but close.</em></p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw4">console.log</span>(<span class="cls">Object</span>.<span class="built_in">getOwnPropertyNames</span>(<span class="var">foo</span>))
<span class="com">// &lt;- ['what']</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>You need to be explicitly looking for symbols to stumble upon them. They’re like JavaScript neutrinos. You can use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols" aria-label="Object.getOwnPropertySymbols() — MDN"><code class="md-code md-code-inline">Object.getOwnPropertySymbols</code></a> to detect them.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw4">console.log</span>(<span class="cls">Object</span>.<span class="built_in">getOwnPropertySymbols</span>(<span class="var">foo</span>))
<span class="com">// &lt;- [Symbol(), Symbol('foo'), Symbol.for('bar')]</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The magical drapes of symbols drop, and you can now iterate over the symbols with a <code class="md-code md-code-inline">for..of</code> loop to finally figure out the treasures they were guarding. Hopefully, they won’t be as disappointing as the flukes in the snippet below.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw3">for</span> (<span class="kw">let</span> <span class="var">symbol</span> <span class="kw">of</span> <span class="cls">Object</span>.<span class="built_in">getOwnPropertySymbols</span>(<span class="var">foo</span>)) {
  <span class="kw4">console.log</span>(<span class="var">foo</span>[<span class="var">symbol</span>])
  <span class="com">// &lt;- 'foo'</span>
  <span class="com">// &lt;- 'bar'</span>
  <span class="com">// &lt;- 'baz'</span>
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<h2 id="why-would-i-want-symbols"><span class="md-heading">Why Would I Want Symbols?</span></h2>

<p>There are a few different uses for symbols.</p>



<h3 id="name-clashes"><span class="md-heading">Name Clashes</span></h3>

<p>You can use symbols to <strong>avoid name clashes</strong> in property keys. This is important when following the <em>“objects as hash maps”</em> pattern, which regularly ends up failing miserably as native methods and properties are overridden unintentionally <em>(or maliciously)</em>.</p>



<h3 id="privacy"><span class="md-heading">“Privacy”?</span></h3>

<p>Symbols are <em>invisible to all “reflection” methods before ES6</em>. This can be useful in some scenarios, but they’re not private by any stretch of imagination, as we’ve just demonstrated with the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols" aria-label="Object.getOwnPropertySymbols() — MDN"><code class="md-code md-code-inline">Object.getOwnPropertySymbols</code></a> API.</p>

<p>That being said, the fact that you have to actively look for symbols to find them means they’re useful in situations where you want to define metadata that shouldn’t be part of iterable sequences for arrays or any <em>iterable</em> objects.</p>



<h3 id="defining-protocols"><span class="md-heading">Defining Protocols</span></h3>

<p>I think the <em>biggest use case for symbols</em> is exactly what the ES6 implementers use them for: <strong>defining protocols</strong> — just like there’s <a href="#es6-iterators-in-depth" aria-label="ES6 Iterators in Depth"><code class="md-code md-code-inline">Symbol.iterator</code></a> which allows you to define how an object can be iterated.</p>

<p>Imagine for instance a library like <a href="https://github.com/bevacqua/dragula" aria-label="bevacqua/dragula on GitHub"><code class="md-code md-code-inline">dragula</code></a> defining a protocol through <code class="md-code md-code-inline">Symbol.for('dragula.moves')</code>, where you could add a method on that <code class="md-code md-code-inline">Symbol</code> to any DOM elements. If a DOM element follows the protocol, then <code class="md-code md-code-inline">dragula</code> could call the <code class="md-code md-code-inline">el[Symbol.for('dragula.moves')]()</code> user-defined method to assert whether the element can be moved.</p>

<p>This way, the logic about elements being draggable by <code class="md-code md-code-inline">dragula</code> is shifted from a single place for the entire <code class="md-code md-code-inline">drake</code> <em>(the <code class="md-code md-code-inline">options</code> for an instance of <code class="md-code md-code-inline">dragula</code>)</em>, to each individual DOM element. That’d make it easier to deal with complex interactions in larger implementations, as the logic would be delegated to individual DOM nodes instead of being centralized in a single <code class="md-code md-code-inline">options.moves</code> method.</p></section></section>

</article>

</div>
<p><a href="#top" class="top"><img src="./auxi/glyphicons-214-up-arrow.png" alt="up-arrow" class="uparrow" /> <b>Back to top</b></a></p></section></main>

<!--  symbols ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->
<!--  ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->









<!--  maps ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->

<main class="ly-main"><header class="at-header">



<h1 itemprop="headline" class="dc-title" id="es6-maps-in-depth">ES6 Maps in Depth</h1></header>

<section class="at-teaser"><div class="at-teaser-markdown md-markdown">

<p>Hello, this is ES6 — <em>“Please make them stop”</em> — in Depth. New here? Start with <a href="#a-brief-history-of-es6-tooling">A Brief History of ES6 Tooling</a>. Then, make your way through <a href="#es6-destructuring-in-depth">destructuring</a>, <a href="#es6-template-strings-in-depth">template literals</a>, <a href="#es6-arrow-functions-in-depth">arrow functions</a>, the <a href="#es6-spread-and-butter-in-depth">spread operator and rest parameters</a>, improvements coming to <a href="#es6-object-literal-features-in-depth">object literals</a>, the new <a href="#es6-classes-in-depth"><em>classes</em></a> sugar on top of prototypes, <a href="#es6-let-const-and-temporal-dead-zone-in-depth"><code class="md-code md-code-inline">let</code>, <code class="md-code md-code-inline">const</code>, and the <em>“Temporal Dead Zone”</em></a>, <a href="#es6-iterators-in-depth">iterators</a>, <a href="#es6-generators-in-depth">generators</a>, and <a href="#es6-symbols-in-depth">Symbols</a>. Today we’ll be discussing a new collection data structure objects coming in ES6 — I’m talking about <code class="md-code md-code-inline">Map</code>.</p></div></section>

<section class="at-container de-host"><div class="de-column">

<article itemscope="itemscope" itemtype="http://schema.org/BlogPosting" class="at-article ly-section">
<meta itemprop="dateCreated" content="2015-09-05T00:21:38+00:00" />
<meta itemprop="datePublished" content="2015-09-10T12:06:01+00:00" />
<meta itemprop="dateModified" content="2015-10-11T04:06:37+00:00" />
<meta itemprop="keywords" content="es6,maps,es6-in-depth" />

<section itemprop="articleBody" class="at-corpus">

<section itemprop="about" class="md-markdown at-introduction"><blockquote>

<p>As I did in previous articles on the series, I would love to point out that you should probably <a href="#universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That’ll make it so much easier for you to <strong>internalize the concepts</strong> discussed in the series. If you aren’t the <em>“install things on my computer”</em> kind of human, you might prefer to hop on <a href="http://codepen.io/">CodePen</a> and then click on the gear icon for JavaScript — <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em> Another alternative that’s also quite useful is to use Babel’s <a href="http://babeljs.io/repl/">online REPL</a> <em>— it’ll show you compiled ES5 code to the right of your ES6 code for quick comparison.</em></p></blockquote>

<p>Before getting into it, let me <a href="https://www.patreon.com/bevacqua"><em>shamelessly ask for your support</em></a> if you’re enjoying my ES6 in Depth series. Your contributions will go towards helping me keep up with the schedule, server bills, keeping me fed, and maintaining <strong>Pony Foo</strong> as a veritable source of JavaScript goodies.</p>

<p>Thanks for reading that, and let’s go into collections now! For a bit of context, you may want to check out the article on <a href="#es6-iterators-in-depth">iterators</a> <em>— which are closely related to ES6 collections –</em> and the one on <a href="#es6-spread-and-butter-in-depth">spread and rest parameters</a>.</p>

<p>Now, let’s start with <code class="md-code md-code-inline">Map</code>. I moved the rest of the ES6 collections to tomorrow’s publication in order to keep the series sane, as otherwise this would’ve been too long for a single article!</p></section>

<section class="md-markdown at-body">



<h1 id="before-es6-there-were-hash-maps"><span class="md-heading">Before ES6, There Were Hash-Maps</span></h1>

<p>A very common <em>ab</em>use case of JavaScript objects is hash-maps, where we map string keys to arbitrary values. For example, one might use an object to map <code class="md-code md-code-inline">npm</code> package names to their metadata, like so:</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">registry</span> <span class="op">=</span> {}
<span class="md-code-function"><span class="kw">function</span> <span class="fn">add</span> <span class="params">(name, meta)</span> </span>{
  <span class="var">registry</span>[<span class="param">name</span>] <span class="op">=</span> <span class="param">meta</span>
}
<span class="md-code-function"><span class="kw">function</span> <span class="fn">get</span> <span class="params">(name)</span> </span>{
  <span class="kw3">return</span> <span class="var">registry</span>[<span class="param">name</span>]
}
<span class="var">add</span>(<span class="str">'contra'</span>, { description: <span class="str">'Asynchronous flow control'</span> })
<span class="var">add</span>(<span class="str">'dragula'</span>, { description: <span class="str">'Drag and drop'</span> })
<span class="var">add</span>(<span class="str">'woofmark'</span>, { description: <span class="str">'Markdown and WYSIWYG editor'</span> })
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>There are several issues with this approach, to wit:</p><ul>
  <li><strong>Security issues</strong> where user-provided keys like <code class="md-code md-code-inline">__proto__</code>, <code class="md-code md-code-inline">toString</code>, or anything in <code class="md-code md-code-inline">Object.prototype</code> break expectations and make interaction with these kinds of <em>hash-map</em> data structures more cumbersome</li>
  <li>Iteration over list items is verbose with <code class="md-code md-code-inline">Object.keys(registry).forEach</code> or implementing the <a href="#es6-iterators-in-depth" aria-label="ES6 Iterators in Depth"><em>iterable</em> protocol</a> on the <code class="md-code md-code-inline">registry</code></li>
  <li>Keys are limited to strings, making it hard to create hash-maps where you’d like to index values by DOM elements or other non-string references</li></ul>

<p>The first problem could be fixed using a prefix, and being careful to always get or set values in the hash-map through methods. It would be even better to use <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Proxy" aria-label="Proxy Objects in ES6 on MDN">ES6 proxies</a>, but we <em>won’t be covering those until tomorrow!</em></p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">registry</span> <span class="op">=</span> {}
<span class="md-code-function"><span class="kw">function</span> <span class="fn">add</span> <span class="params">(name, meta)</span> </span>{
  <span class="var">registry</span>[<mark class="md-mark md-code-mark"><span class="str">'map:'</span> <span class="op">+</span> </mark><span class="param">name</span>] <span class="op">=</span> <span class="param">meta</span>
}
<span class="md-code-function"><span class="kw">function</span> <span class="fn">get</span> <span class="params">(name)</span> </span>{
  <span class="kw3">return</span> <span class="var">registry</span>[<mark class="md-mark md-code-mark"><span class="str">'map:'</span> <span class="op">+</span> </mark><span class="param">name</span>]
}
<span class="var">add</span>(<span class="str">'contra'</span>, { description: <span class="str">'Asynchronous flow control'</span> })
<span class="var">add</span>(<span class="str">'dragula'</span>, { description: <span class="str">'Drag and drop'</span> })
<span class="var">add</span>(<span class="str">'woofmark'</span>, { description: <span class="str">'Markdown and WYSIWYG editor'</span> })
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Luckily for us, though, <em>ES6 maps</em> provide us with an even better solution to the key-naming security issue. At the same time they facilitate collection behaviors out the box that may also come in handy. Let’s plunge into their practical usage and inner workings.</p>



<h1 id="es6-maps"><span class="md-heading">ES6 Maps</span></h1>

<p>Map is a key/value data structure in ES6. It provides a better data structure to be used for hash-maps. Here’s how what we had earlier looks like with ES6 maps.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">map</span> <span class="op">=</span> <mark class="md-mark md-code-mark"><span class="kw">new</span> <span class="md-code-map">Map</span>()</mark>
<mark class="md-mark md-code-mark"><span class="var">map</span>.<span class="built_in">set</span></mark>(<span class="str">'contra'</span>, { description: <span class="str">'Asynchronous flow control'</span> })
<span class="var">map</span>.<span class="built_in">set</span>(<span class="str">'dragula'</span>, { description: <span class="str">'Drag and drop'</span> })
<span class="var">map</span>.<span class="built_in">set</span>(<span class="str">'woofmark'</span>, { description: <span class="str">'Markdown and WYSIWYG editor'</span> })
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>One of the important differences is also that you’re able to use anything for the keys. You’re not just limited to primitive values like symbols, numbers, or strings, but you can even use functions, objects and dates — too. Keys won’t be casted to strings like with regular objects, either.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">map</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-map">Map</span>()
<span class="var">map</span>.<span class="built_in">set</span>(<span class="kw">new</span> <span class="date">Date</span>(), <span class="md-code-function"><span class="kw">function</span> <span class="fn">today</span> <span class="params">()</span> </span>{})
<span class="var">map</span>.<span class="built_in">set</span>(() <span class="op">=&gt;</span> <span class="str">'key'</span>, { pony: <span class="str">'foo'</span> })
<span class="var">map</span>.<span class="built_in">set</span>(<span class="md-code-symbol">Symbol</span>(<span class="str">'items'</span>), [<span class="num">1</span>, <span class="num">2</span>])
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>You can also provide <code class="md-code md-code-inline">Map</code> objects with any object that follows the <a href="#es6-iterators-in-depth" aria-label="ES6 Iterators in Depth"><em>iterable</em> protocol</a> and produces a collection such as <code class="md-code md-code-inline">[['key', 'value'], ['key', 'value']]</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">map</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-map">Map</span>([
  [<span class="kw">new</span> <span class="date">Date</span>(), <span class="md-code-function"><span class="kw">function</span> <span class="fn">today</span> <span class="params">()</span> </span>{}],
  [() <span class="op">=&gt;</span> <span class="str">'key'</span>, { pony: <span class="str">'foo'</span> }],
  [<span class="md-code-symbol">Symbol</span>(<span class="str">'items'</span>), [<span class="num">1</span>, <span class="num">2</span>]]
])
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The above would be effectively the same as the following. Note how we’re using destructuring in the parameters of <code class="md-code md-code-inline">items.forEach</code> to <em>effortlessly</em> pull the <code class="md-code md-code-inline">key</code> and <code class="md-code md-code-inline">value</code> out of the two-dimensional <code class="md-code md-code-inline">item</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">items</span> <span class="op">=</span> [
  [<span class="kw">new</span> <span class="date">Date</span>(), <span class="md-code-function"><span class="kw">function</span> <span class="fn">today</span> <span class="params">()</span> </span>{}],
  [() <span class="op">=&gt;</span> <span class="str">'key'</span>, { pony: <span class="str">'foo'</span> }],
  [<span class="md-code-symbol">Symbol</span>(<span class="str">'items'</span>), [<span class="num">1</span>, <span class="num">2</span>]]
]
<span class="kw">var</span> <span class="var">map</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-map">Map</span>()
<span class="var">items</span>.<span class="built_in">forEach</span>((<mark class="md-mark md-code-mark">[key, value]</mark>) <span class="op">=&gt;</span> <span class="var">map</span>.<span class="built_in">set</span>(key, value))
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Of course, it’s kind of silly to go through the trouble of adding items one by one when you can just feed an iterable to your <code class="md-code md-code-inline">Map</code>. Speaking of iterables — <code class="md-code md-code-inline">Map</code> adheres to the <a href="#es6-iterators-in-depth" aria-label="ES6 Iterators in Depth"><em>iterable</em></a> protocol. It’s very easy to pull a key-value pair collection much like the ones you can feed to the <code class="md-code md-code-inline">Map</code> constructor.</p>

<p>Naturally, we can use the spread operator to this effect.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">map</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-map">Map</span>()
<span class="var">map</span>.<span class="built_in">set</span>(<span class="str">'p'</span>, <span class="str">'o'</span>)
<span class="var">map</span>.<span class="built_in">set</span>(<span class="str">'n'</span>, <span class="str">'y'</span>)
<span class="var">map</span>.<span class="built_in">set</span>(<span class="str">'f'</span>, <span class="str">'o'</span>)
<span class="var">map</span>.<span class="built_in">set</span>(<span class="str">'o'</span>, <span class="str">'!'</span>)
<span class="kw4">console.log</span>([<span class="op">...</span><span class="var">map</span>])
<span class="com">// &lt;- [['p', 'o'], ['n', 'y'], ['f', 'o'], ['o', '!']]</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>You could also use a <code class="md-code md-code-inline">for..of</code> loop, and we could combine that with <a href="#es6-destructuring-in-depth" aria-label="ES6 JavaScript Destructuring in Depth">destructuring</a> to make it seriously terse. Also, remember <a href="#es6-template-strings-in-depth" aria-label="ES6 Template Literals in Depth">template literals</a>?</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">map</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-map">Map</span>()
<span class="var">map</span>.<span class="built_in">set</span>(<span class="str">'p'</span>, <span class="str">'o'</span>)
<span class="var">map</span>.<span class="built_in">set</span>(<span class="str">'n'</span>, <span class="str">'y'</span>)
<span class="var">map</span>.<span class="built_in">set</span>(<span class="str">'f'</span>, <span class="str">'o'</span>)
<span class="var">map</span>.<span class="built_in">set</span>(<span class="str">'o'</span>, <span class="str">'!'</span>)
<span class="kw3">for</span> (<span class="kw">let</span> <mark class="md-mark md-code-mark">[<span class="var">key</span>, <span class="var">value</span>]</mark> <span class="kw">of</span> <span class="var">map</span>) {
  <span class="kw4">console.log</span>(<mark class="md-mark md-code-mark"><span class="str">`${key}: ${value}`</span></mark>)
  <span class="com">// &lt;- 'p: o'</span>
  <span class="com">// &lt;- 'n: y'</span>
  <span class="com">// &lt;- 'f: o'</span>
  <span class="com">// &lt;- 'o: !'</span>
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Even though maps have a programmatic API to add items, keys are unique, just like with hash-maps. Setting a key over and over again will only overwrite its value.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">map</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-map">Map</span>()
<span class="var">map</span>.<span class="built_in">set</span>(<span class="str">'a'</span>, <span class="str">'a'</span>)
<span class="var">map</span>.<span class="built_in">set</span>(<span class="str">'a'</span>, <span class="str">'b'</span>)
<span class="var">map</span>.<span class="built_in">set</span>(<span class="str">'a'</span>, <span class="str">'c'</span>)
<span class="kw4">console.log</span>([<span class="op">...</span><span class="var">map</span>])
<span class="com">// &lt;- [['a', 'c']]</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>In ES6 <code class="md-code md-code-inline">Map</code>, <code class="md-code md-code-inline">NaN</code> becomes a “corner-case” that gets <strong>treated as a value that’s equal to itself</strong> even though the following expression actually evaluates to <code class="md-code md-code-inline">true</code> — <code class="md-code md-code-inline">NaN !== NaN</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw4">console.log</span>(<span class="md-code-nan">NaN</span> <span class="op">===</span> <span class="md-code-nan">NaN</span>)
<span class="com">// &lt;- false</span>
<span class="kw">var</span> <span class="var">map</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-map">Map</span>()
<span class="var">map</span>.<span class="built_in">set</span>(<span class="md-code-nan">NaN</span>, <span class="str">'foo'</span>)
<span class="var">map</span>.<span class="built_in">set</span>(<span class="md-code-nan">NaN</span>, <span class="str">'bar'</span>)
<span class="kw4">console.log</span>([<span class="op">...</span><span class="var">map</span>])
<span class="com">// &lt;- [[NaN, 'bar']]</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<h2 id="hash-maps-and-the-dom"><span class="md-heading">Hash-Maps and the DOM</span></h2>

<p>In ES5, whenever we had a DOM element we wanted to associate with an API object for some library, we had to follow a verbose and slow pattern like the one below. The following piece of code just returns an API object with a bunch of methods for a given DOM element, allowing us to put and remove DOM elements from the cache, and also allowing us to retrieve the API object for a DOM element — if one already exists.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">cache</span> <span class="op">=</span> []
<span class="md-code-function"><span class="kw">function</span> <span class="fn">put</span> <span class="params">(el, api)</span> </span>{
  <span class="var">cache</span>.<span class="built_in">push</span>({ el: <span class="param">el</span>, api: <span class="param">api</span> })
}
<span class="md-code-function"><span class="kw">function</span> <span class="fn">find</span> <span class="params">(<span class="param">el</span>)</span> </span>{
  <span class="kw3">for</span> (<span class="var">i</span> <span class="op">=</span> <span class="num">0</span>; <span class="var">i</span> <span class="op">&lt;</span> <span class="var">cache</span>.<span class="built_in">length</span>; <span class="var">i</span><span class="op">++</span>) {
    <span class="kw">if</span> (<span class="var">cache</span>[<span class="var">i</span>].<span class="param">el</span> <span class="op">===</span> <span class="param">el</span>) {
      <span class="kw3">return</span> <span class="var">cache</span>[<span class="var">i</span>].<span class="param">api</span>
    }
  }
}
<span class="md-code-function"><span class="kw">function</span> <span class="fn">destroy</span> <span class="params">(el)</span> </span>{
  <span class="kw3">for</span> (<span class="var">i</span> <span class="op">=</span> <span class="num">0</span>; <span class="var">i</span> <span class="op">&lt;</span> <span class="var">cache</span>.<span class="built_in">length</span>; <span class="var">i</span><span class="op">++</span>) {
    <span class="kw">if</span> (<span class="var">cache</span>[<span class="var">i</span>].<span class="param">el</span> <span class="op">===</span> <span class="param">el</span>) {
      <span class="var">cache</span>.<span class="built_in">splice</span>(<span class="var">i</span>, <span class="num">1</span>)
      <span class="kw3">return</span>
    }
  }
}
<span class="md-code-function"><span class="kw">function</span> <span class="fn">thing</span> <span class="params">(el)</span> </span>{
  <span class="kw">var</span> <span class="var">api</span> <span class="op">=</span> <span class="fn">find</span>(<span class="param">el</span>)
  <span class="kw">if</span> (<span class="var">api</span>) {
    <span class="kw3">return</span> <span class="var">api</span>
  }
  <span class="var">api</span> <span class="op">=</span> {
    method: method,
    method2: method2,
    method3: method3,
    destroy: destroy.<span class="built_in">bind</span>(<span class="md-code-null">null</span>, <span class="param">el</span>)
  }
  <span class="kw">put</span>(<span class="param">el</span>, <span class="var">api</span>)
  <span class="kw3">return</span> <span class="var">api</span>
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>One of the coolest aspects of <code class="md-code md-code-inline">Map</code>, <em>as I’ve previously mentioned</em>, is the ability to index by DOM elements. The fact that <code class="md-code md-code-inline">Map</code> also has collection manipulation abilities also greatly simplifies things.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">cache</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-map">Map</span>()
<span class="md-code-function"><span class="kw">function</span> <span class="fn">put</span> <span class="params">(el, api)</span> </span>{
  <mark class="md-mark md-code-mark"><span class="var">cache</span>.<span class="built_in">set</span>(<span class="param">el</span>, <span class="param">api</span>)</mark>
}
<span class="md-code-function"><span class="kw">function</span> <span class="fn">find</span> <span class="params">(<span class="param">el</span>)</span> </span>{
  <span class="kw3">return</span> <mark class="md-mark md-code-mark"><span class="var">cache</span>.<span class="built_in">get</span>(<span class="param">el</span>)</mark>
}
<span class="md-code-function"><span class="kw">function</span> <span class="fn">destroy</span> <span class="params">(<span class="param">el</span>)</span> </span>{
  <mark class="md-mark md-code-mark"><span class="var">cache</span>.<span class="built_in">delete</span>(<span class="param">el</span>)</mark>
}
<span class="md-code-function"><span class="kw">function</span> <span class="fn">thing</span> <span class="params">(<span class="param">el</span>)</span> </span>{
  <span class="kw">var</span> <span class="var">api</span> <span class="op">=</span> <span class="fn">find</span>(<span class="param">el</span>)
  <span class="kw">if</span> (<span class="var">api</span>) {
    <span class="kw3">return</span> <span class="var">api</span>
  }
  <span class="var">api</span> <span class="op">=</span> {
    method: method,
    method2: method2,
    method3: method3,
    destroy: destroy.<span class="built_in">bind</span>(<span class="md-code-null">null</span>, <span class="param">el</span>)
  }
  <span class="kw">put</span>(<span class="param">el</span>, <span class="var">api</span>)
  <span class="kw3">return</span> <span class="var">api</span>
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The fact that these methods have now become one liners means we can just inline them, as readability is no longer an issue. We just went from <em>~30 LOC</em> to <strong>half that amount</strong>. Needless to say, at some point in the future this will also perform <em>much</em> faster than the haystack alternative.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">cache</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-map">Map</span>()
<span class="md-code-function"><span class="kw">function</span> <span class="fn">thing</span> <span class="params">(el)</span> </span>{
  <span class="kw">var</span> <span class="var">api</span> <span class="op">=</span> <mark class="md-mark md-code-mark"><span class="var">cache</span>.<span class="built_in">get</span>(<span class="param">el</span>)</mark>
  <span class="kw">if</span> (<span class="var">api</span>) {
    <span class="kw3">return</span> <span class="var">api</span>
  }
  <span class="var">api</span> <span class="op">=</span> {
    method: method,
    method2: method2,
    method3: method3,
    destroy: () <span class="op">=&gt;</span> <mark class="md-mark md-code-mark"><span class="var">cache</span>.<span class="built_in">delete</span>(<span class="param">el</span>)</mark>
  }
  <mark class="md-mark md-code-mark"><span class="var">cache</span>.<span class="built_in">set</span>(<span class="param">el</span>, <span class="var">api</span>)</mark>
  <span class="kw3">return</span> <span class="var">api</span>
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The simplicity of <code class="md-code md-code-inline">Map</code> is amazing. If you ask me, we desperately needed this feature in JavaScript. Being to index a collection by arbitrary objects is <strong>super important</strong>.</p><blockquote>

<p>What else can we do with <code class="md-code md-code-inline">Map</code>?</p></blockquote>



<h2 id="collection-methods-in-map"><span class="md-heading">Collection Methods in <code class="md-code md-code-inline">Map</code></span></h2>

<p>Maps make it very easy to probe the collection and figure out whether a <code class="md-code md-code-inline">key</code> is defined in the <code class="md-code md-code-inline">Map</code>. As we noted earlier, <code class="md-code md-code-inline">NaN</code> equals <code class="md-code md-code-inline">NaN</code> as far as <code class="md-code md-code-inline">Map</code> is concerned. However, <code class="md-code md-code-inline">Symbol</code> values are always different, so you’ll have to use them by value!</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">map</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-map">Map</span>([[<span class="md-code-nan">NaN</span>, <span class="num">1</span>], [<span class="md-code-symbol">Symbol</span>(), <span class="num">2</span>], [<span class="str">'foo'</span>, <span class="str">'bar'</span>]])
<span class="kw4">console.log</span>(<span class="var">map</span>.<span class="built_in">has</span>(<span class="md-code-nan">NaN</span>))
<span class="com">// &lt;- true</span>
<span class="kw4">console.log</span>(<span class="var">map</span>.<span class="built_in">has</span>(<span class="md-code-symbol">Symbol</span>()))
<span class="com">// &lt;- <mark class="md-mark md-code-mark">false</mark></span>
<span class="kw4">console.log</span>(<span class="var">map</span>.<span class="built_in">has</span>(<span class="str">'foo'</span>))
<span class="com">// &lt;- true</span>
<span class="kw4">console.log</span>(<span class="var">map</span>.<span class="built_in">has</span>(<span class="str">'bar'</span>))
<span class="com">// &lt;- false</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>As long as you keep a <code class="md-code md-code-inline">Symbol</code> reference around, you’ll be okay. <em>Keep your references close, and your <code class="md-code md-code-inline">Symbol</code>s closer?</em></p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><mark class="md-mark md-code-mark"><span class="kw">var</span> <span class="var">sym</span> <span class="op">=</span> <span class="md-code-symbol">Symbol</span>()</mark>
<span class="kw">var</span> <span class="var">map</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-map">Map</span>([[<span class="md-code-nan">NaN</span>, <span class="num">1</span>], [<span class="var">sym</span>, <span class="num">2</span>], [<span class="str">'foo'</span>, <span class="str">'bar'</span>]])
<span class="kw4">console.log</span>(<span class="var">map</span>.<span class="built_in">has</span>(<span class="var">sym</span>))
<span class="com">// &lt;- <mark class="md-mark md-code-mark">true</mark></span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Also, remember the <strong>no key-casting</strong> thing? <em>Beware!</em> We are so used to objects casting keys to strings that this may bite you if you’re not careful.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">map</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-map">Map</span>([[<span class="num">1</span>, <span class="str">'a'</span>]])
<span class="kw4">console.log</span>(<span class="var">map</span>.<span class="built_in">has</span>(<span class="num">1</span>))
<span class="com">// &lt;- true</span>
<span class="kw4">console.log</span>(<span class="var">map</span>.<span class="built_in">has</span>(<span class="str">'1'</span>))
<span class="com">// &lt;- <mark class="md-mark md-code-mark">false</mark></span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>You can also clear a <code class="md-code md-code-inline">Map</code> entirely of entries without losing a reference to it. This can be very handy sometimes.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">map</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-map">Map</span>([[<span class="num">1</span>, <span class="num">2</span>], [<span class="num">3</span>, <span class="num">4</span>], [<span class="num">5</span>, <span class="num">6</span>]])
<span class="var">map</span>.<span class="built_in">clear</span>()
<span class="kw4">console.log</span>(<span class="var">map</span>.<span class="built_in">has</span>(<span class="num">1</span>))
<span class="com">// &lt;- false</span>
<span class="kw4">console.log</span>([<span class="op">...</span><span class="var">map</span>])
<span class="com">// &lt;- []</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>When you use <code class="md-code md-code-inline">Map</code> as an iterable, you are actually looping over its <code class="md-code md-code-inline">.entries()</code>. That means that you don’t need to <strong>explicitly</strong> iterate over <code class="md-code md-code-inline">.entries()</code>. It’ll be done on your behalf anyways. You do remember <a href="#es6-iterators-in-depth" aria-label="ES6 Iterators in Depth"><code class="md-code md-code-inline">Symbol.iterator</code></a>, right?</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw4">console.log</span>(<span class="var">map</span>[<mark class="md-mark md-code-mark"><span class="md-code-symbol">Symbol</span>.<span class="built_in">iterator</span></mark>] <span class="op">===</span> <span class="var">map</span>.<span class="built_in">entries</span>)
<span class="com">// &lt;- true</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Just like <code class="md-code md-code-inline">.entries()</code>, <code class="md-code md-code-inline">Map</code> has two other iterators you can leverage. These are <code class="md-code md-code-inline">.keys()</code> and <code class="md-code md-code-inline">.values()</code>. I’m sure you guessed what sequences of values they yield, but here’s a code snippet anyways.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">map</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-map">Map</span>([[<span class="num">1</span>, <span class="num">2</span>], [<span class="num">3</span>, <span class="num">4</span>], [<span class="num">5</span>, <span class="num">6</span>]])
<span class="kw4">console.log</span>([<span class="op">...</span><span class="var">map</span>.<span class="built_in">keys</span>()])
<span class="com">// &lt;- [1, 3, 5]</span>
<span class="kw4">console.log</span>([<span class="op">...</span><span class="var">map</span>.<span class="built_in">values</span>()])
<span class="com">// &lt;- [2, 4, 6]</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Maps also come with a <em>read-only</em> <code class="md-code md-code-inline">.size</code> property that behaves sort of like <code class="md-code md-code-inline">Array.prototype.length</code> — at any point in time it gives you the current amount of entries in the map.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">map</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-map">Map</span>([[<span class="num">1</span>, <span class="num">2</span>], [<span class="num">3</span>, <span class="num">4</span>], [<span class="num">5</span>, <span class="num">6</span>]])
<span class="kw4">console.log</span>(<span class="var">map</span>.<span class="built_in">size</span>)
<span class="com">// &lt;- 3</span>
<span class="var">map</span>.<span class="built_in">delete</span>(<span class="num">3</span>)
<span class="kw4">console.log</span>(<span class="var">map</span>.<span class="built_in">size</span>)
<span class="com">// &lt;- 2</span>
<span class="var">map</span>.<span class="built_in">clear</span>()
<span class="kw4">console.log</span>(<span class="var">map</span>.<span class="built_in">size</span>)
<span class="com">// &lt;- 0</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>One more aspect of <code class="md-code md-code-inline">Map</code> that’s worth mentioning is that their entries are always iterated in <strong>insertion order</strong>. This is in contrast with <code class="md-code md-code-inline">Object.keys</code> loops which follow <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in" aria-label="for..in on MDN">an arbitrary order</a>.</p><blockquote>

<p>The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in" aria-label="for..in on MDN"><code class="md-code md-code-inline">for..in</code></a> statement iterates over the enumerable properties of an object, in arbitrary order.</p></blockquote>

<p>Maps also have a <code class="md-code md-code-inline">.forEach</code> method that’s identical in <em>behavior</em> to that in ES5 <code class="md-code md-code-inline">Array</code> objects. Once again, keys do not get casted into strings here.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">map</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-map">Map</span>([[<span class="md-code-nan">NaN</span>, <span class="num">1</span>], [<span class="md-code-symbol">Symbol</span>(), <span class="num">2</span>], [<span class="str">'foo'</span>, <span class="str">'bar'</span>]])
<span class="var">map</span>.<span class="built_in">forEach</span>(<mark class="md-mark md-code-mark">(value, key)</mark> <span class="op">=&gt;</span> <span class="kw4">console.log</span>(key, value))
<span class="com">// &lt;- NaN 1</span>
<span class="com">// &lt;- Symbol() 2</span>
<span class="com">// &lt;- 'foo' 'bar'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->
<blockquote>

<p>Get up early tomorrow morning, we’ll be having <a href="http://ponyfoo.com/articles/es6-weakmaps-sets-and-weaksets-in-depth" aria-label="ES6 WeakMaps, Sets, and WeakSets in Depth"><code class="md-code md-code-inline">WeakMap</code>, <code class="md-code md-code-inline">Set</code>, and <code class="md-code md-code-inline">WeakSet</code></a> for breakfast :)</p></blockquote></section></section>

</article>

</div>
<p><a href="#top" class="top"><img src="./auxi/glyphicons-214-up-arrow.png" alt="up-arrow" class="uparrow" /> <b>Back to top</b></a></p>
</section></main>

<!--  maps ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->
<!--  ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->









<!--  weakmaps sets ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->

<main class="ly-main"><header class="at-header">



<h1 itemprop="headline" class="dc-title" id="es6-weakmaps-sets-and-weaksets-in-depth">ES6 WeakMaps, Sets, and WeakSets in Depth</h1></header>

<section class="at-teaser"><div class="at-teaser-markdown md-markdown">

<p>Welcome once again to ES6 — <em>“I can’t take this anymore”</em> — in Depth. New here? Start with <a href="#a-brief-history-of-es6-tooling">A Brief History of ES6 Tooling</a>. Then, make your way through <a href="#es6-destructuring-in-depth">destructuring</a>, <a href="#es6-template-strings-in-depth">template literals</a>, <a href="#es6-arrow-functions-in-depth">arrow functions</a>, the <a href="#es6-spread-and-butter-in-depth">spread operator and rest parameters</a>, improvements coming to <a href="#es6-object-literal-features-in-depth">object literals</a>, the new <a href="#es6-classes-in-depth"><em>classes</em></a> sugar on top of prototypes, <a href="#es6-let-const-and-temporal-dead-zone-in-depth"><code class="md-code md-code-inline">let</code>, <code class="md-code md-code-inline">const</code>, and the <em>“Temporal Dead Zone”</em></a>, <a href="#es6-iterators-in-depth">iterators</a>, <a href="#es6-generators-in-depth">generators</a>, <a href="#es6-symbols-in-depth">Symbols</a> and <a href="#es6-maps-in-depth">Maps</a>. This morning we’ll be discussing three more collection data structures coming in ES6: <code class="md-code md-code-inline">WeakMap</code>, <code class="md-code md-code-inline">Set</code> and <code class="md-code md-code-inline">WeakSet</code>.</p></div></section>

<section class="at-container de-host"><div class="de-column">

<article itemscope="itemscope" itemtype="http://schema.org/BlogPosting" class="at-article ly-section">
<meta itemprop="dateCreated" content="2015-09-05T00:32:32+00:00" />
<meta itemprop="datePublished" content="2015-09-11T11:24:01+00:00" />
<meta itemprop="dateModified" content="2015-10-11T04:06:37+00:00" />
<meta itemprop="keywords" content="es6,maps,weakmaps,sets,weaksets,es6-in-depth" />

<section itemprop="articleBody" class="at-corpus">

<section itemprop="about" class="md-markdown at-introduction"><blockquote>

<p>As I did in previous articles on the series, I would love to point out that you should probably <a href="#universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That’ll make it so much easier for you to <strong>internalize the concepts</strong> discussed in the series. If you aren’t the <em>“install things on my computer”</em> kind of human, you might prefer to hop on <a href="http://codepen.io/">CodePen</a> and then click on the gear icon for JavaScript — <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em> Another alternative that’s also quite useful is to use Babel’s <a href="http://babeljs.io/repl/">online REPL</a> <em>— it’ll show you compiled ES5 code to the right of your ES6 code for quick comparison.</em></p></blockquote>

<p>Before getting into it, let me <a href="https://www.patreon.com/bevacqua"><em>shamelessly ask for your support</em></a> if you’re enjoying my ES6 in Depth series. Your contributions will go towards helping me keep up with the schedule, server bills, keeping me fed, and maintaining <strong>Pony Foo</strong> as a veritable source of JavaScript goodies.</p>

<p>Thanks for reading that, and let’s go into collections now! For a bit of context, you may want to check out the article on <a href="#es6-iterators-in-depth">iterators</a> <em>— which are closely related to ES6 collections –</em> and the one on <a href="#es6-spread-and-butter-in-depth">spread and rest parameters</a>.</p><blockquote>

<p>Now, let’s pick up <a href="#es6-maps-in-depth">where we left off</a> — it’s time for <code class="md-code md-code-inline">WeakMap</code>.</p></blockquote></section>



<section class="md-markdown at-body">



<h1 id="es6-weakmaps"><span class="md-heading">ES6 WeakMaps</span></h1>

<p>You can think of <code class="md-code md-code-inline">WeakMap</code> as a subset of <a href="#es6-maps-in-depth" aria-label="ES6 Maps in Depth"><code class="md-code md-code-inline">Map</code></a>. There are a few limitations on <code class="md-code md-code-inline">WeakMap</code> that we didn’t find in <code class="md-code md-code-inline">Map</code>. The biggest limitation is that <code class="md-code md-code-inline">WeakMap</code> is not iterable, as opposed to <code class="md-code md-code-inline">Map</code> — that means there is no <a href="#es6-iterators-in-depth" aria-label="ES6 Iterators in Depth"><em>iterable</em></a> protocol, no <code class="md-code md-code-inline">.entries()</code>, no <code class="md-code md-code-inline">.keys()</code>, no <code class="md-code md-code-inline">.values()</code>, no <code class="md-code md-code-inline">.forEach()</code> and no <code class="md-code md-code-inline">.clear()</code>.</p>

<p>Another <em>“limitation”</em> found in <code class="md-code md-code-inline">WeakMap</code> as opposed to <code class="md-code md-code-inline">Map</code> is that every <code class="md-code md-code-inline">key</code> must be an object, and <strong>value types are not admitted as keys</strong>. Note that <code class="md-code md-code-inline">Symbol</code> is a value type as well, and they’re not allowed either.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">map</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-map">WeakMap</span>()
<span class="var">map</span>.<span class="built_in">set</span>(<span class="num">1</span>, <span class="num">2</span>)
<span class="com">// TypeError: 1 is not an object!</span>
<span class="var">map</span>.<span class="built_in">set</span>(<span class="md-code-symbol">Symbol</span>(), <span class="num">2</span>)
<span class="com">// TypeError: Invalid value used as weak map key</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->
<blockquote>

<p>This is more of a feature than an issue, though, as it enables map keys to be garbage collected when they’re only being referenced as <code class="md-code md-code-inline">WeakMap</code> keys. Usually you want this behavior when storing metadata related to something like a DOM node, and now you can keep that metadata in a <code class="md-code md-code-inline">WeakMap</code>. If you want all of those you could always <a href="#es6-maps-in-depth" aria-label="ES6 Maps in Depth">use a regular <code class="md-code md-code-inline">Map</code> as we explored earlier</a>.</p></blockquote>

<p>You are still able to pass an iterable to populate a <code class="md-code md-code-inline">WeakMap</code> through its constructor.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">map</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-map">WeakMap</span>([[<span class="kw">new</span> <span class="date">Date</span>(), <span class="str">'foo'</span>], [() <span class="op">=&gt;</span> <span class="str">'bar'</span>, <span class="str">'baz'</span>]])
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Just like with <code class="md-code md-code-inline">Map</code>, you can use <code class="md-code md-code-inline">.has</code>, <code class="md-code md-code-inline">.get</code>, and <code class="md-code md-code-inline">.delete</code> too.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">date</span> <span class="op">=</span> <span class="kw">new</span> <span class="date">Date</span>()
<span class="kw">var</span> <span class="var">map</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-map">WeakMap</span>([[<span class="var">date</span>, <span class="str">'foo'</span>], [() <span class="op">=&gt;</span> <span class="str">'bar'</span>, <span class="str">'baz'</span>]])
<span class="kw4">console.log</span>(<span class="var">map</span>.<span class="built_in">has</span>(<span class="var">date</span>))
<span class="com">// &lt;- true</span>
<span class="kw4">console.log</span>(<span class="var">map</span>.<span class="built_in">get</span>(<span class="var">date</span>))
<span class="com">// &lt;- 'foo'</span>
<span class="var">map</span>.<span class="built_in">delete</span>(<span class="var">date</span>)
<span class="kw4">console.log</span>(<span class="var">map</span>.<span class="built_in">has</span>(<span class="var">date</span>))
<span class="com">// &lt;- false</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<h2 id="is-this-a-strictly-worse-map"><span class="md-heading">Is This a Strictly Worse Map?</span></h2>

<p>I know! You must be wondering — why the hell would I use <code class="md-code md-code-inline">WeakMap</code> when it has so many limitations when compared to <code class="md-code md-code-inline">Map</code>?</p>

<p>The difference that may make <code class="md-code md-code-inline">WeakMap</code> worth it is in its name. <code class="md-code md-code-inline">WeakMap</code> holds references to its keys <em>weakly</em>, meaning that if there are no other references to one of its keys, the object is subject to <strong>garbage collection</strong>.</p>

<p>Use cases for <code class="md-code md-code-inline">WeakMap</code> generally revolve around the need to specify metadata or extend an object while still being able to garbage collect it if nobody else cares about it. A perfect example might be the underlying implementation for <a href="https://iojs.org/api/process.html#process_event_unhandledrejection" aria-label="Node.js Documentation for 'unhandledRejection' process event"><code class="md-code md-code-inline">process.on('unhandledRejection')</code></a> which <a href="https://github.com/petkaantonov/io.js/commit/f46874357ee7b909ae54304c6791f2a4baddf613#diff-6ff379484cbabad48301d485db111c08R269" aria-label="node: implement unhandled rejection tracking">uses a <code class="md-code md-code-inline">WeakMap</code></a> to keep track of promises that were rejected but <em>no error handlers dealt with the rejection</em> within a tick.</p>

<p>Keeping data about DOM elements that should be released from memory when they’re no longer of interested is another very important use case, and in this regard using <code class="md-code md-code-inline">WeakMap</code> is probably an even better solution to the DOM-related <a href="#es6-maps-in-depth#hash-maps-and-the-dom" aria-label="Hash-Maps and the DOM">API caching solution</a> we wrote about earlier using <code class="md-code md-code-inline">Map</code>.</p>

<p>In so many words then, <strong>no</strong>. <code class="md-code md-code-inline">WeakMap</code> is not strictly worse than <code class="md-code md-code-inline">Map</code> <em>— they just cater to different use cases.</em></p>



<h2 id="es6-sets"><span class="md-heading">ES6 Sets</span></h2>

<p>Sets are <em>yet another</em> collection type in ES6. Sets are <em>very</em> similar to <code class="md-code md-code-inline">Map</code>. To wit:</p><ul>
  <li><code class="md-code md-code-inline">Set</code> is also <a href="#es6-iterators-in-depth" aria-label="ES6 Iterators in Depth"><em>iterable</em></a></li>
  <li><code class="md-code md-code-inline">Set</code> constructor also accepts an <em>iterable</em></li>
  <li><code class="md-code md-code-inline">Set</code> also has a <code class="md-code md-code-inline">.size</code> property</li>
  <li>Keys can also be arbitrary values</li>
  <li>Keys must be unique</li>
  <li><code class="md-code md-code-inline">NaN</code> equals <code class="md-code md-code-inline">NaN</code> when it comes to <code class="md-code md-code-inline">Set</code> too</li>
  <li>All of <code class="md-code md-code-inline">.keys</code>, <code class="md-code md-code-inline">.values</code>, <code class="md-code md-code-inline">.entries</code>, <code class="md-code md-code-inline">.forEach</code>, <del><code class="md-code md-code-inline">.get</code></del>, <del><code class="md-code md-code-inline">.set</code></del>, <code class="md-code md-code-inline">.has</code>, <code class="md-code md-code-inline">.delete</code>, and <code class="md-code md-code-inline">.clear</code></li></ul>

<p>However, there’s a few differences as well!</p><ul>
  <li>Sets only have <code class="md-code md-code-inline">values</code></li>
  <li>No <code class="md-code md-code-inline">set.get</code> — but <strong>why</strong> would you want <code class="md-code md-code-inline">get(value) =&gt; value</code>?</li>
  <li>Having <code class="md-code md-code-inline">set.set</code> would be weird, so we have <code class="md-code md-code-inline">set.add</code> instead</li>
  <li><code class="md-code md-code-inline">set[Symbol.iterator] !== set.entries</code></li>
  <li><code class="md-code md-code-inline">set[Symbol.iterator] <span class="op">===</span> set.values</code></li>
  <li><code class="md-code md-code-inline">set.keys <span class="op">===</span> set.values</code></li>
  <li><code class="md-code md-code-inline">set.entries()</code> returns an iterator on a sequence of items like <code class="md-code md-code-inline">[value, value]</code></li></ul>

<p>In the example below you can note how it takes an iterable with duplicate values, it can be spread over an <code class="md-code md-code-inline">Array</code> using the <a href="#es6-spread-and-butter-in-depth" aria-label="ES6 Spread and Butter in Depth">spread operator</a>, and how the duplicate value <em>has been ignored</em>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">set</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-set">Set</span>([<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <mark class="md-mark md-code-mark">4</mark>])
<span class="kw4">console.log</span>([<span class="op">...</span><span class="var">set</span>])
<span class="com">// &lt;- <mark class="md-mark md-code-mark">[1, 2, 3, 4]</mark></span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Sets may be a great alternative to work with DOM elements. The following piece of code creates a <code class="md-code md-code-inline">Set</code> with all the <code class="md-code md-code-inline">&lt;div&gt;</code> elements on a page and then prints how many it found. Then, we query the DOM <em>again</em> and call <code class="md-code md-code-inline">set.add</code> again for every DOM element. Since they’re all already in the <code class="md-code md-code-inline">set</code>, the <code class="md-code md-code-inline">.size</code> property won’t change, meaning the <code class="md-code md-code-inline">set</code> remains the same.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">divs</span> <span class="params">()</span> </span>{
  <span class="kw3">return</span> <mark class="md-mark md-code-mark">[<span class="op">...</span><span class="kw">document</span>.querySelectorAll(<span class="str">'div'</span>)]</mark>
}
<span class="kw">var</span> <span class="var">set</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-set">Set</span>(<mark class="md-mark md-code-mark">divs()</mark>)
<span class="kw4">console.log</span>(<span class="var">set</span>.<span class="built_in">size</span>)
<span class="com">// &lt;- 56</span>
<mark class="md-mark md-code-mark">divs().<span class="built_in">forEach</span>(div <span class="op">=&gt;</span> <span class="var">set</span>.<span class="built_in">add</span>(div))</mark>
<span class="kw4">console.log</span>(<span class="var">set</span>.<span class="built_in">size</span>)
<span class="com">// &lt;- 56</span>
<span class="com">// &lt;- look at that, no duplicates!</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<h1 id="es6-weaksets"><span class="md-heading">ES6 WeakSets</span></h1>

<p>Much like with <code class="md-code md-code-inline">WeakMap</code> and <code class="md-code md-code-inline">Map</code>, <code class="md-code md-code-inline">WeakSet</code> is <strong><code class="md-code md-code-inline">Set</code> plus weakness</strong> minus the <em>iterability</em> <em>— I just made that term up, didn’t I?</em></p>

<p>That means you can’t iterate over <code class="md-code md-code-inline">WeakSet</code>. Its values must be <strong>unique object references</strong>. If nothing else is referencing a <code class="md-code md-code-inline">value</code> found in a <code class="md-code md-code-inline">WeakSet</code>, it’ll be subject to garbage collection.</p>

<p>Much like in <code class="md-code md-code-inline">WeakMap</code>, you can only <code class="md-code md-code-inline">.add</code>, <code class="md-code md-code-inline">.has</code>, and <code class="md-code md-code-inline">.delete</code> values from a <code class="md-code md-code-inline">WeakSet</code>. And just like in <code class="md-code md-code-inline">Set</code>, there’s no <code class="md-code md-code-inline">.get</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">set</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-set">WeakSet</span>()
<span class="var">set</span>.<span class="built_in">add</span>({})
<span class="var">set</span>.<span class="built_in">add</span>(<span class="kw">new</span> <span class="date">Date</span>())
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>As we know, we can’t use primitive values.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">set</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-set">WeakSet</span>()
<span class="var">set</span>.<span class="built_in">add</span>(<span class="md-code-symbol">Symbol</span>())
<span class="com">// TypeError: invalid value used in weak set</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Just like with <code class="md-code md-code-inline">WeakMap</code>, passing iterators to the constructor is still allowed even though a <code class="md-code md-code-inline">WeakSet</code> instance is not iterable itself.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">set</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-set">WeakSet</span>([<span class="kw">new</span> <span class="date">Date</span>(), {}, () <span class="op">=&gt;</span> {}, [<span class="num">1</span>]])
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Use cases for <code class="md-code md-code-inline">WeakSet</code> vary, and here’s one from <a href="https://esdiscuss.org/topic/actual-weakset-use-cases#content-1" aria-label="Actual WeakSet Use Cases on ES Discuss">a thread on <em>es-discuss</em></a> — the mailing list for the ECMAScript-262 specification of JavaScript.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">const</span> <span class="md-code-const">foos</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-set">WeakSet</span>()
<span class="kw">class</span> <span class="cls">Foo</span> {
  <span class="built_in">constructor</span>() {
    <mark class="md-mark md-code-mark"><span class="md-code-const">foos</span>.<span class="built_in">add</span>(<span class="kw3">this</span>)</mark>
  }
  <span class="built_in">method</span> () {
    <span class="kw">if</span> (!<mark class="md-mark md-code-mark"><span class="md-code-const">foos</span>.<span class="built_in">has</span>(<span class="kw3">this</span>)</mark>) {
      <span class="kw">throw</span> <span class="kw">new</span> <span class="md-code-error">TypeError</span>(<span class="str">'Foo.prototype.method called on incompatible object!'</span>)
    }
  }
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>As a general rule of thumb, you can also try and figure out whether a <code class="md-code md-code-inline">WeakSet</code> will do when you’re considering to use a <code class="md-code md-code-inline">WeakMap</code> as some use cases may overlap. Particularly, if all you need to check for is whether a reference value is in the <code class="md-code md-code-inline">WeakSet</code> or not.</p><blockquote>

<p>Next week we’ll be having <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Proxy" aria-label="Proxy Objects in ES6 on MDN"><code class="md-code md-code-inline">Proxy</code></a> for brunch :)</p></blockquote></section></section>
</article>
</div>
<p><a href="#top" class="top"><img src="./auxi/glyphicons-214-up-arrow.png" alt="up-arrow" class="uparrow" /> <b>Back to top</b></a></p></section></main>

<!--  weakmaps sets ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->
<!--  ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->









<!--  proxies  ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->

<main class="ly-main"><header class="at-header">



<h1 itemprop="headline" class="dc-title" id="es6-proxies-in-depth">ES6 Proxies in Depth</h1></header>

<section class="at-teaser"><div class="at-teaser-markdown md-markdown">

<p>Cheers, <strong>please come in</strong>. This is ES6 — <em>“Elaine, you gotta have a baby!”</em> — in Depth. What? Never heard of it? Check out <a href="#a-brief-history-of-es6-tooling">A Brief History of ES6 Tooling</a>. Then, make your way through <a href="#es6-destructuring-in-depth">destructuring</a>, <a href="#es6-template-strings-in-depth">template literals</a>, <a href="#es6-arrow-functions-in-depth">arrow functions</a>, the <a href="#es6-spread-and-butter-in-depth">spread operator and rest parameters</a>, improvements coming to <a href="#es6-object-literal-features-in-depth">object literals</a>, the new <a href="#es6-classes-in-depth"><em>classes</em></a> sugar on top of prototypes, <a href="#es6-let-const-and-temporal-dead-zone-in-depth"><code class="md-code md-code-inline">let</code>, <code class="md-code md-code-inline">const</code>, and the <em>“Temporal Dead Zone”</em></a>, <a href="#es6-iterators-in-depth">iterators</a>, <a href="#es6-generators-in-depth">generators</a>, <a href="#es6-symbols-in-depth">Symbols</a>, <a href="#es6-maps-in-depth">Maps</a>, <a href="#es6-weakmaps-sets-and-weaksets-in-depth">WeakMaps, Sets, and WeakSets</a>. We’ll be discussing <em>ES6 proxies</em> today.</p></div></section>

<section class="at-container de-host"><div class="de-column">

<article itemscope="itemscope" itemtype="http://schema.org/BlogPosting" class="at-article ly-section">
<meta itemprop="dateCreated" content="2015-09-05T05:07:35+00:00" />
<meta itemprop="datePublished" content="2015-09-14T12:12:01+00:00" />
<meta itemprop="dateModified" content="2015-10-11T04:06:37+00:00" />
<meta itemprop="keywords" content="es6,proxies,es6-in-depth" />

<section itemprop="articleBody" class="at-corpus">

<section itemprop="about" class="md-markdown at-introduction"><blockquote>

<p>As I did in previous articles on the series, I would love to point out that you should probably <a href="#universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That’ll make it so much easier for you to <strong>internalize the concepts</strong> discussed in the series. If you aren’t the <em>“install things on my computer”</em> kind of human, you might prefer to hop on <a href="http://codepen.io/">CodePen</a> and then click on the gear icon for JavaScript — <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em> Another alternative that’s also quite useful is to use Babel’s <a href="http://babeljs.io/repl/">online REPL</a> <em>— it’ll show you compiled ES5 code to the right of your ES6 code for quick comparison.</em></p>

<p>Note that <code class="md-code md-code-inline">Proxy</code> is harder to play around with as Babel doesn’t support it unless the underlying browser has support for it. You can check out the <a href="http://kangax.github.io/compat-table/es6/">ES6 compatibility table</a> for supporting browsers. At the time of this writing, you can use <em>Microsoft Edge</em> or <em>Mozilla Firefox</em> to try out <code class="md-code md-code-inline">Proxy</code>. Personally, I’ll be verifying my examples using <em>Firefox</em>.</p></blockquote>

<p>Before getting into it, let me <a href="https://www.patreon.com/bevacqua"><em>shamelessly ask for your support</em></a> if you’re enjoying my ES6 in Depth series. Your contributions will go towards helping me keep up with the schedule, server bills, keeping me fed, and maintaining <strong>Pony Foo</strong> as a veritable source of JavaScript goodies.</p>

<p>Thanks for reading that, and let’s go into Proxies now!</p></section>

<section class="md-markdown at-body">


<h1 id="es6-proxies"><span class="md-heading">ES6 Proxies</span></h1>

<p>Proxies are a quite interesting feature coming in ES6. In a nutshell, you can use a <code class="md-code md-code-inline">Proxy</code> to determine behavior whenever the properties of a <code class="md-code md-code-inline">target</code> object are accessed. A <code class="md-code md-code-inline">handler</code> object can be used to configure <em>traps</em> for your <code class="md-code md-code-inline">Proxy</code>, as we’ll see in a bit.</p>

<p>By default, proxies don’t do much — in fact they don’t do anything. If you don’t set any <em>“options”</em>, your <code class="md-code md-code-inline">proxy</code> will just work as a <em>pass-through</em> to the <code class="md-code md-code-inline">target</code> object — MDN calls this a <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Proxy#No-op_forwarding_proxy" aria-label="No-op forwarding proxy on MDN">"no-op forwarding <code class="md-code md-code-inline">Proxy</code>"</a>, which makes sense.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">target</span> <span class="op">=</span> {}
<span class="kw">var</span> <span class="var">handler</span> <span class="op">=</span> {}
<span class="kw">var</span> <span class="var">proxy</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-proxy">Proxy</span>(<span class="var">target</span>, <span class="var">handler</span>)
<span class="var">proxy</span>.a <span class="op">=</span> <span class="str">'b'</span>
<span class="kw4">console.log</span>(<span class="var">target</span>.a)
<span class="com">// &lt;- 'b'</span>
<span class="kw4">console.log</span>(<span class="var">proxy</span>.c <span class="op">===</span> <span class="literal">undefined</span>)
<span class="com">// &lt;- true</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>We can make our proxy a bit more interesting by adding traps. Traps allow you to intercept interactions with <code class="md-code md-code-inline">target</code> in different ways, as long as those interactions happen through <code class="md-code md-code-inline">proxy</code>. We could use a <code class="md-code md-code-inline">get</code> <em>trap</em> to log every attempt to pull a value out of a property in <code class="md-code md-code-inline">target</code>. Let’s try that next.</p>



<h2 id="get"><span class="md-heading"><code class="md-code md-code-inline">get</code></span></h2>

<p>The proxy below is able to track any and every <strong>property access</strong> event because it has a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/get" aria-label="handler.get() on MDN"><code class="md-code md-code-inline">handler.get</code></a> trap. It can also be used to <em>transform</em> the value we get out of accessing any given property. We can already imagine <code class="md-code md-code-inline">Proxy</code> becoming a staple when it comes to developer tooling.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">handler</span> <span class="op">=</span> {
  <span class="built_in">get</span> <span class="params">(target, key)</span> {
    <span class="built_in">console.info</span>(<span class="str">`Get on property "${key}"`</span>)
    <span class="kw3">return</span> <span class="param">target</span>[<span class="param">key</span>]
  }
}
<span class="kw">var</span> <span class="var">target</span> <span class="op">=</span> {}
<span class="kw">var</span> <span class="var">proxy</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-proxy">Proxy</span>(<span class="var">target</span>, <span class="var">handler</span>)
<span class="var">proxy</span>.a <span class="op">=</span> <span class="str">'b'</span>
<span class="var">proxy</span>.a
<span class="com">// &lt;- 'Get on property "a"'</span>
<span class="var">proxy</span>.b
<span class="com">// &lt;- 'Get on property "b"'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Of course, your getter doesn’t necessarily have to return the original <code class="md-code md-code-inline">target[key]</code> value. How about finally making those <code class="md-code md-code-inline">_prop</code> properties actually private?</p>


<h2 id="set"><span class="md-heading"><code class="md-code md-code-inline">set</code></span></h2>

<p>Know how we usually define conventions such as Angular’s <em>dollar signs</em> where properties prefixed by a single dollar sign should hardly be accessed from an application and properties prefixed by two dollar signs should <strong>not be accessed at all</strong>? We usually do something like that ourselves in our applications, typically in the form of underscore-prefixed variables.</p>

<p>The <code class="md-code md-code-inline">Proxy</code> in the example below prevents property access for both <code class="md-code md-code-inline">get</code> and <code class="md-code md-code-inline">set</code> <em>(via a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/set" aria-label="handler.set() on MDN"><code class="md-code md-code-inline">handler.set</code></a> trap)</em> while accessing <code class="md-code md-code-inline">target</code> through <code class="md-code md-code-inline">proxy</code>. Note how <code class="md-code md-code-inline">set</code> always returns <code class="md-code md-code-inline">true</code> here? — this means that setting the property <code class="md-code md-code-inline">key</code> to a given <code class="md-code md-code-inline">value</code> should <em>succeed</em>. If the return value for the <code class="md-code md-code-inline">set</code> trap is <code class="md-code md-code-inline">false</code>, setting the property value will throw a <code class="md-code md-code-inline">TypeError</code> under strict mode, and otherwise fail silently.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">handler</span> <span class="op">=</span> {
  <span class="built_in">get</span> <span class="params">(target, key)</span> {
    <span class="fn">invariant</span>(<span class="param">key</span>, <span class="str">'get'</span>)
    <span class="kw3">return</span> <span class="param">target</span>[<span class="param">key</span>]
  },
  <span class="built_in">set</span> <span class="params">(target, key, value)</span> {
    <span class="fn">invariant</span>(<span class="param">key</span>, <span class="str">'set'</span>)
    <mark class="md-mark md-code-mark"><span class="kw3">return</span> <span class="md-code-boolean">true</span></mark>
  }
}
<span class="md-code-function"><span class="kw">function</span> <span class="fn">invariant</span> <span class="params">(<span class="param">key</span>, action)</span> </span>{
  <span class="kw">if</span> (<span class="param">key</span>[<span class="num">0</span>] <span class="op">===</span> <span class="str">'_'</span>) {
    <span class="kw">throw</span> <span class="kw">new</span> <span class="md-code-error">Error</span>(<mark class="md-mark md-code-mark"><span class="str">`Invalid attempt to ${action} private "${key}" property`</span></mark>)
  }
}
<span class="kw">var</span> <span class="var">target</span> <span class="op">=</span> {}
<span class="kw">var</span> <span class="var">proxy</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-proxy">Proxy</span>(<span class="var">target</span>, <span class="var">handler</span>)
<span class="var">proxy</span>.a <span class="op">=</span> <span class="str">'b'</span>
<span class="kw4">console.log</span>(<span class="var">proxy</span>.a)
<span class="com">// &lt;- 'b'</span>
<span class="var">proxy</span>._prop
<span class="com">// &lt;- Error: Invalid attempt to get private "_prop" property</span>
<span class="var">proxy</span>._prop <span class="op">=</span> <span class="str">'c'</span>
<span class="com">// &lt;- Error: Invalid attempt to set private "_prop" property</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p><sub><em>You do remember string interpolation with <a href="#es6-template-strings-in-depth" aria-label="ES6 Template Literals in Depth">template literals</a>, right?</em></sub></p>

<p>It might be worth mentioning that the <code class="md-code md-code-inline">target</code> object <em>(the object being proxied)</em> should often be completely hidden from accessors in proxying scenarios. Effectively <strong>preventing direct access</strong> to the <code class="md-code md-code-inline">target</code> and instead forcing access to <code class="md-code md-code-inline">target</code> exclusively through <code class="md-code md-code-inline">proxy</code>. Consumers of <code class="md-code md-code-inline">proxy</code> will get to access <code class="md-code md-code-inline">target</code> through the <code class="md-code md-code-inline">Proxy</code> object, but will have to <strong>obey your access rules</strong> — such as <em>“properties prefixed with <code class="md-code md-code-inline">_</code> are off-limits”</em>.</p>

<p>To that end, you could simply wrap your proxied object in a method, and then return the <code class="md-code md-code-inline">proxy</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">proxied</span> <span class="params">()</span> </span>{
  <span class="kw">var</span> <span class="var">target</span> <span class="op">=</span> {}
  <span class="kw">var</span> <span class="var">handler</span> <span class="op">=</span> {
    <span class="kw">get</span> <span class="params">(target, key)</span> {
      <span class="fn">invariant</span>(<span class="param">key</span>, <span class="str">'get'</span>)
      <span class="kw3">return</span> <span class="param">target</span>[<span class="param">key</span>]
    },
    <span class="kw">set</span> <span class="params">(target, key, value)</span> {
      <span class="fn">invariant</span>(<span class="param">key</span>, <span class="str">'set'</span>)
      <span class="kw3">return</span> <span class="md-code-boolean">true</span>
    }
  }
  <span class="kw3">return</span> <mark class="md-mark md-code-mark"><span class="kw">new</span> <span class="md-code-proxy">Proxy</span>(<span class="param">target</span>, <span class="var">handler</span>)</mark>
}
<span class="md-code-function"><span class="kw">function</span> <span class="fn">invariant</span> <span class="params">(key, action)</span> </span>{
  <span class="kw">if</span> (<span class="param">key</span>[<span class="num">0</span>] <span class="op">===</span> <span class="str">'_'</span>) {
    <span class="kw">throw</span> <span class="kw">new</span> <span class="md-code-error">Error</span>(<span class="str">`Invalid attempt to ${action} private "${key}" property`</span>)
  }
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Usage stays the same, except now access to <code class="md-code md-code-inline">target</code> is completely governed by <code class="md-code md-code-inline">proxy</code> and its mischievous traps. At this point, any <code class="md-code md-code-inline">_prop</code> properties in <code class="md-code md-code-inline">target</code> are completely inaccessible through the proxy, and since <code class="md-code md-code-inline">target</code> can’t be accessed directly from outside the <code class="md-code md-code-inline">proxied</code> method, they’re sealed off from consumers for good.</p>

<p>You might be tempted to argue that you could achieve the same behavior in ES5 simply by using variables privately scoped to the <code class="md-code md-code-inline">proxied</code> method, without the need for the <code class="md-code md-code-inline">Proxy</code> itself. The big difference is that proxies allow you to “privatize” property access <strong>on different layers</strong>. Imagine an underlying <code class="md-code md-code-inline">underling</code> object that already has several <em>“private”</em> properties, which you still access in some other <code class="md-code md-code-inline">middletier</code> module that has intimate knowledge of the internals of <code class="md-code md-code-inline">underling</code>. The <code class="md-code md-code-inline">middletier</code> module could return a <code class="md-code md-code-inline">proxied</code> version of <code class="md-code md-code-inline">underling</code> without having to map the API onto an entirely new object in order to protect those internal variables. Just locking access to any of the “private” properties would suffice!</p>

<p>Here’s a use case on schema validation using proxies.</p>


<h2 id="schema-validation-with-proxies"><span class="md-heading">Schema Validation with Proxies</span></h2>

<p>While, yes, <em>you could</em> set up schema validation on the <code class="md-code md-code-inline">target</code> object itself, doing it on a <code class="md-code md-code-inline">Proxy</code> means that you separate the validation concerns from the <code class="md-code md-code-inline">target</code> object, which will go on to live as a <strong>POJO</strong> <em>(Plain Old JavaScript Object)</em> happily ever after. Similarly, you can use the proxy as an intermediary for access to many different objects that conform to a schema, without having to rely on prototypal inheritance or <a href="#es6-classes-in-depth" aria-label="ES6 Classes in Depth">ES6 <code class="md-code md-code-inline">class</code> classes</a>.</p>

<p>In the example below, <code class="md-code md-code-inline">person</code> is a plain model object, and we’ve also defined a <code class="md-code md-code-inline">validator</code> object with a <code class="md-code md-code-inline">set</code> trap that will be used as the <code class="md-code md-code-inline">handler</code> for a <code class="md-code md-code-inline">proxy</code> validator of people models. As long as the <code class="md-code md-code-inline">person</code> properties are set through <code class="md-code md-code-inline">proxy</code>, the model invariants will be satisfied according to our validation rules.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">validator</span> <span class="op">=</span> {
  <span class="kw">set</span> <span class="params">(target, key, value)</span> {
    <span class="kw">if</span> (<span class="param">key</span> <span class="op">===</span> <span class="str">'age'</span>) {
      <span class="kw">if</span> (<span class="kw">typeof</span> <span class="param">value</span> <span class="op">!==</span> <span class="str">'number'</span> <span class="op">||</span> <span class="cls">Number</span>.<span class="built_in">isNaN</span>(<span class="param">value</span>)) {
        <span class="kw">throw</span> <span class="kw">new</span> <span class="md-code-error">TypeError</span>(<span class="str">'Age must be a number'</span>)
      }
      <span class="kw">if</span> (<span class="param">value</span> <span class="op">&lt;=</span> <span class="num">0</span>) {
        <span class="kw">throw</span> <span class="kw">new</span> <span class="md-code-error">TypeError</span>(<span class="str">'Age must be a positive number'</span>)
      }
    }
    <span class="kw3">return</span> <span class="md-code-boolean">true</span>
  }
}
<span class="kw">var</span> <span class="var">person</span> <span class="op">=</span> { age: <span class="num">27</span> }
<span class="kw">var</span> <span class="var">proxy</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-proxy">Proxy</span>(<span class="var">person</span>, <span class="var">validator</span>)
<span class="var">proxy</span>.age <span class="op">=</span> <span class="str">'foo'</span>
<span class="com">// &lt;- TypeError: Age must be a number</span>
<span class="var">proxy</span>.age <span class="op">=</span> <span class="md-code-nan">NaN</span>
<span class="com">// &lt;- TypeError: Age must be a number</span>
<span class="var">proxy</span>.age <span class="op">=</span> <span class="num">0</span>
<span class="com">// &lt;- TypeError: Age must be a positive number</span>
<span class="var">proxy</span>.age <span class="op">=</span> <span class="num">28</span>
<span class="kw4">console.log</span>(<span class="var">person</span>.age)
<span class="com">// &lt;- 28</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>There’s also a particularly “severe” type of proxies that allows us to completely shut off access to <code class="md-code md-code-inline">target</code> whenever we deem it necessary.</p>


<h2 id="revocable-proxies"><span class="md-heading">Revocable Proxies</span></h2>

<p>We can use <code class="md-code md-code-inline">Proxy.revocable</code> in a similar way to <code class="md-code md-code-inline">Proxy</code>. The main differences are that the return value will be <code class="md-code md-code-inline">{ proxy, revoke }</code>, and that once <code class="md-code md-code-inline">revoke</code> is called the <code class="md-code md-code-inline">proxy</code> <strong>will throw</strong> on <em>any operation</em>. Let’s go back to our pass-through <code class="md-code md-code-inline">Proxy</code> example and make it <code class="md-code md-code-inline">revocable</code>. Note that we’re <em>not using</em> the <code class="md-code md-code-inline">new</code> operator here. Calling <code class="md-code md-code-inline">revoke()</code> over and over has no effect.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">target</span> <span class="op">=</span> {}
<span class="kw">var</span> <span class="var">handler</span> <span class="op">=</span> {}
<span class="kw">var</span> <mark class="md-mark md-code-mark">{<span class="var">proxy</span>, <span class="var">revoke</span>} <span class="op">=</span> <span class="md-code-proxy">Proxy</span>.<span class="built_in">revocable</span>(<span class="var">target</span>, <span class="var">handler</span>)</mark>
<span class="var">proxy</span>.a <span class="op">=</span> <span class="str">'b'</span>
<span class="kw4">console.log</span>(<span class="var">proxy</span>.a)
<span class="com">// &lt;- 'b'</span>
<mark class="md-mark md-code-mark"><span class="var">revoke</span>()</mark>
<span class="var">revoke</span>()
<span class="var">revoke</span>()
<span class="kw4">console.log</span>(<span class="var">proxy</span>.a)
<span class="com">// &lt;- TypeError: illegal operation attempted on a revoked proxy</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>This type of <code class="md-code md-code-inline">Proxy</code> is particularly useful because you can now completely cut off access to the <code class="md-code md-code-inline">proxy</code> granted to a consumer. You start by passing of a revocable <code class="md-code md-code-inline">Proxy</code> and keeping around the <code class="md-code md-code-inline">revoke</code> method <em>(hey, maybe you can <a href="#es6-weakmaps-sets-and-weaksets-in-depth" aria-label="ES6 WeakMaps, Sets, and WeakSets in Depth">use a <code class="md-code md-code-inline">WeakMap</code></a> for that)</em>, and when its clear that the consumer shouldn’t have access to <code class="md-code md-code-inline">target</code> anymore, — not even through <code class="md-code md-code-inline">proxy</code> — you <code class="md-code md-code-inline">.revoke()</code> the hell out of their access. <em>Goodbye consumer!</em></p>

<p>Furthermore, since <code class="md-code md-code-inline">revoke</code> is available on the same scope where your <code class="md-code md-code-inline">handler</code> traps live, you could set up <strong>extremely paranoid rules</strong> such as <em>“if a consumer attempts to access a private property more than once, revoke their <code class="md-code md-code-inline">proxy</code> entirely”</em>.</p><blockquote>

<p>Check back tomorrow for the second part of the article about proxies, which discusses <code class="md-code md-code-inline">Proxy</code> <em>traps</em> beyond <code class="md-code md-code-inline">get</code> and <code class="md-code md-code-inline">set</code>.</p></blockquote></section></section>
</article>
</div>
<p><a href="#top" class="top"><img src="./auxi/glyphicons-214-up-arrow.png" alt="up-arrow" class="uparrow" /> <b>Back to top</b></a></p></section></main>


<!--  proxies ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->
<!--  ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->









<!--  proxy traps ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->

<main class="ly-main"><header class="at-header">



<h1 itemprop="headline" class="dc-title" id="es6-proxy-traps-in-depth">ES6 Proxy Traps in Depth</h1></header>

<section class="at-teaser"><div class="at-teaser-markdown md-markdown">

<p>Welcome to ES6 — <em>“Please, not again”</em> — in Depth. Looking for other ES6 goodness? Refer to <a href="#a-brief-history-of-es6-tooling">A Brief History of ES6 Tooling</a>. Then, make your way through <a href="#es6-destructuring-in-depth">destructuring</a>, <a href="#es6-template-strings-in-depth">template literals</a>, <a href="#es6-arrow-functions-in-depth">arrow functions</a>, the <a href="#es6-spread-and-butter-in-depth">spread operator and rest parameters</a>, improvements coming to <a href="#es6-object-literal-features-in-depth">object literals</a>, the new <a href="#es6-classes-in-depth"><em>classes</em></a> sugar on top of prototypes, <a href="#es6-let-const-and-temporal-dead-zone-in-depth"><code class="md-code md-code-inline">let</code>, <code class="md-code md-code-inline">const</code>, and the <em>“Temporal Dead Zone”</em></a>, <a href="#es6-iterators-in-depth">iterators</a>, <a href="#es6-generators-in-depth">generators</a>, <a href="#es6-symbols-in-depth">Symbols</a>, <a href="#es6-maps-in-depth">Maps</a>, <a href="#es6-weakmaps-sets-and-weaksets-in-depth">WeakMaps, Sets, and WeakSets</a>, and <a href="#es6-proxies-in-depth">proxies</a>. We’ll be discussing <em>ES6 proxy <strong>traps</strong></em> today.</p></div></section>

<section class="at-container de-host"><div class="de-column">

<article itemscope="itemscope" itemtype="http://schema.org/BlogPosting" class="at-article ly-section">
<meta itemprop="dateCreated" content="2015-09-07T19:57:51+00:00" />
<meta itemprop="datePublished" content="2015-09-15T11:42:01+00:00" />
<meta itemprop="dateModified" content="2015-10-11T04:06:37+00:00" />
<meta itemprop="keywords" content="es6,proxies,traps,es6-in-depth" />

<section itemprop="articleBody" class="at-corpus">

<section itemprop="about" class="md-markdown at-introduction"><blockquote>

<p>As I did in previous articles on the series, I would love to point out that you should probably <a href="#universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That’ll make it so much easier for you to <strong>internalize the concepts</strong> discussed in the series. If you aren’t the <em>“install things on my computer”</em> kind of human, you might prefer to hop on <a href="http://codepen.io/">CodePen</a> and then click on the gear icon for JavaScript — <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em> Another alternative that’s also quite useful is to use Babel’s <a href="http://babeljs.io/repl/">online REPL</a> <em>— it’ll show you compiled ES5 code to the right of your ES6 code for quick comparison.</em></p>

<p>Note that <code class="md-code md-code-inline">Proxy</code> is harder to play around with as Babel doesn’t support it unless the underlying browser has support for it. You can check out the <a href="http://kangax.github.io/compat-table/es6/">ES6 compatibility table</a> for supporting browsers. At the time of this writing, you can use <em>Microsoft Edge</em> or <em>Mozilla Firefox</em> to try out <code class="md-code md-code-inline">Proxy</code>. Personally, I’ll be verifying my examples using <em>Firefox</em>.</p></blockquote>

<p>Before getting into it, let me <a href="https://www.patreon.com/bevacqua"><em>shamelessly ask for your support</em></a> if you’re enjoying my ES6 in Depth series. Your contributions will go towards helping me keep up with the schedule, server bills, keeping me fed, and maintaining <strong>Pony Foo</strong> as a veritable source of JavaScript goodies.</p>

<p>Thanks for reading that, and let’s go into more <code class="md-code md-code-inline">Proxy</code> <em>traps</em> now! If you haven’t yet, I encourage you to read <a href="#es6-proxies-in-depth">yesterday’s article on the <code class="md-code md-code-inline">Proxy</code> built-in</a> for an introduction to the subject.</p></section>



<section class="md-markdown at-body">



<h2 id="proxy-trap-handlers"><span class="md-heading">Proxy Trap Handlers</span></h2>

<p>An interesting aspect of proxies is how you can use them to intercept just about any interaction with a <code class="md-code md-code-inline">target</code> object — not just <code class="md-code md-code-inline">get</code> or <code class="md-code md-code-inline">set</code> operations. Below are some of the traps you can set up, here’s a summary.</p><ul>
  <li><a href="#has"><code class="md-code md-code-inline">has</code></a> — traps <code class="md-code md-code-inline">in</code> operator</li>
  <li><a href="#deleteproperty"><code class="md-code md-code-inline">deleteProperty</code></a> — traps <code class="md-code md-code-inline">delete</code> operator</li>
  <li><a href="#defineproperty"><code class="md-code md-code-inline">defineProperty</code></a> — traps <code class="md-code md-code-inline">Object.defineProperty</code> and declarative alternatives</li>
  <li><a href="#enumerate"><code class="md-code md-code-inline">enumerate</code></a> — traps <code class="md-code md-code-inline">for..in</code> loops</li>
  <li><a href="#ownkeys"><code class="md-code md-code-inline">ownKeys</code></a> — traps <code class="md-code md-code-inline">Object.keys</code> and related methods</li>
  <li><a href="#apply"><code class="md-code md-code-inline">apply</code></a> — traps <em>function calls</em></li></ul>

<p>We’ll bypass <code class="md-code md-code-inline">get</code> and <code class="md-code md-code-inline">set</code>, because we <a href="#es6-proxies-in-depth" aria-label="ES6 Proxies in Depth">already covered those two</a> yesterday; and there’s a few more traps that aren’t listed here that will make it into an article published tomorrow. <em>Stay tuned!</em></p>



<h3 id="has"><span class="md-heading"><code class="md-code md-code-inline">has</code></span></h3>

<p>You can use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/has" aria-label="handler.has() on MDN"><code class="md-code md-code-inline">handler.has</code></a> to <em>“hide”</em> any property you want. It’s a trap for the <code class="md-code md-code-inline">in</code> operator. In the <a href="#es6-proxies-in-depth#set" aria-label="ES6 Proxy set trap example"><code class="md-code md-code-inline">set</code></a> trap example we prevented changes and even access to <em><code class="md-code md-code-inline">_</code>-prefixed</em> properties, but unwanted accessors could still ping our proxy to figure out whether these properties are actually there or not. <em>Like <a href="https://en.wikipedia.org/wiki/Goldilocks_and_the_Three_Bears" aria-label="Goldilocks and the Three Bears on Wikipedia">Goldilocks</a></em>, we have three options here.</p><ul>
  <li>We can let <code class="md-code md-code-inline">key in proxy</code> <em>fall through</em> to <code class="md-code md-code-inline">key in target</code></li>
  <li>We can <code class="md-code md-code-inline">return false</code> <em>(or <code class="md-code md-code-inline">true</code>)</em> — even though <code class="md-code md-code-inline">key</code> <strong>may or may not</strong> actually be there</li>
  <li>We can <code class="md-code md-code-inline">throw</code> an error and deem the question <strong>invalid</strong> in the first place</li></ul>

<p>The last option is quite harsh, and I imagine it being indeed a valid choice in some situations — but you would be acknowledging that the property <em>(or “property space”)</em> is, in fact, <em>protected</em>. It’s often best to just smoothly indicate that the property is not <code class="md-code md-code-inline">in</code> the object. Usually, a fall-through case where you just return the result of the <code class="md-code md-code-inline">key in target</code> expression is a good default case to have.</p>

<p>In our example, we probably want to <code class="md-code md-code-inline">return false</code> for properties in the <em><code class="md-code md-code-inline">_</code>-prefixed “property space”</em> and the default of <code class="md-code md-code-inline">key in target</code> for all other properties. This will keep our inaccessible properties well hidden from unwanted visitors.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">handler</span> <span class="op">=</span> {
  <span class="built_in">get</span> <span class="params">(target, key)</span> {
    <span class="fn">invariant</span>(<span class="param">key</span>, <span class="str">'get'</span>)
    <span class="kw3">return</span> <span class="param">target</span>[<span class="param">key</span>]
  },
  <span class="built_in">set</span> <span class="params">(target, key, value)</span> {
    <span class="fn">invariant</span>(<span class="param">key</span>, <span class="str">'set'</span>)
    <span class="kw3">return</span> <span class="md-code-boolean">true</span>
  },
  <mark class="md-mark md-code-mark"><span class="built_in">has</span> (<span class="param">target</span>, <span class="param">key</span>) {</mark>
    <span class="kw">if</span> (<span class="param">key</span>[<span class="num">0</span>] <span class="op">===</span> <span class="str">'_'</span>) {
      <mark class="md-mark md-code-mark"><span class="kw3">return</span> <span class="md-code-boolean">false</span></mark>
    }
    <mark class="md-mark md-code-mark"><span class="kw3">return</span> <span class="param">key</span> <span class="kw">in</span> <span class="param">target</span></mark>
  }
}
<span class="md-code-function"><span class="kw">function</span> <span class="fn">invariant</span> <span class="params">(key, action)</span> </span>{
  <span class="kw">if</span> (<span class="param">key</span>[<span class="num">0</span>] <span class="op">===</span> <span class="str">'_'</span>) {
    <span class="kw">throw</span> <span class="kw">new</span> <span class="md-code-error">Error</span>(<span class="str">`Invalid attempt to ${action} private "${key}" property`</span>)
  }
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Note how accessing properties through the proxy will now return <code class="md-code md-code-inline">false</code> whenever accessing one of our private properties, with the consumer being none the wiser — completely unaware that we’ve intentionally hid the property from them.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">target</span> <span class="op">=</span> { _prop: <span class="str">'foo'</span>, pony: <span class="str">'foo'</span> }
<span class="kw">var</span> <span class="var">proxy</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-proxy">Proxy</span>(<span class="var">target</span>, <span class="var">handler</span>)
<span class="kw4">console.log</span>(<span class="str">'pony'</span> <span class="kw">in</span> <span class="var">proxy</span>)
<span class="com">// &lt;- true</span>
<span class="kw4">console.log</span>(<span class="str">'_prop'</span> <span class="kw">in</span> <span class="var">proxy</span>)
<span class="com">// &lt;- false</span>
<span class="kw4">console.log</span>(<span class="str">'_prop'</span> <span class="kw">in</span> <span class="var">target</span>)
<span class="com">// &lt;- true</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Sure, we could’ve thrown an exception instead. That’d be useful in situations where attempts to access properties in the private space is seen more of <strong>as a mistake that results in broken modularity</strong> than as a <em>security concern</em> in code that aims to be embedded into third party websites.</p><blockquote>

<p>It really depends on your use case!</p></blockquote>



<h3 id="deleteproperty"><span class="md-heading"><code class="md-code md-code-inline">deleteProperty</code></span></h3>

<p>I use the <code class="md-code md-code-inline">delete</code> operator a lot. Setting a property to <code class="md-code md-code-inline">undefined</code> clears its value, but the property is still part of the object. Using the <code class="md-code md-code-inline">delete</code> operator on a property with code like <code class="md-code md-code-inline">delete foo.bar</code> means that the <code class="md-code md-code-inline">bar</code> property will be forever gone from the <code class="md-code md-code-inline">foo</code> object.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">foo</span> <span class="op">=</span> { bar: <span class="str">'baz'</span> }
<span class="var">foo</span>.bar <span class="op">=</span> <span class="str">'baz'</span>
<span class="kw4">console.log</span>(<span class="str">'bar'</span> <span class="kw">in</span> <span class="var">foo</span>)
<span class="com">// &lt;- true</span>
<span class="kw">delete</span> <span class="var">foo</span>.bar
<span class="kw4">console.log</span>(<span class="str">'bar'</span> <span class="kw">in</span> <span class="var">foo</span>)
<span class="com">// &lt;- false</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Remember our <a href="#es6-proxies-in-depth#set" aria-label="ES6 Proxy set trap example"><code class="md-code md-code-inline">set</code></a> trap example where we prevented access to <em><code class="md-code md-code-inline">_</code>-prefixed</em> properties? That code had a problem. Even though you couldn’t change the value of <code class="md-code md-code-inline">_prop</code>, you could remove the property entirely using the <code class="md-code md-code-inline">delete</code> operator. Even through the <code class="md-code md-code-inline">proxy</code> object!</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">target</span> <span class="op">=</span> { _prop: <span class="str">'foo'</span> }
<span class="kw">var</span> <span class="var">proxy</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-proxy">Proxy</span>(<span class="var">target</span>, handler)
<span class="kw4">console.log</span>(<span class="str">'_prop'</span> <span class="kw">in</span> <span class="var">proxy</span>)
<span class="com">// &lt;- true</span>
<span class="kw">delete</span> <span class="var">proxy</span>._prop
<span class="kw4">console.log</span>(<span class="str">'_prop'</span> <span class="kw">in</span> <span class="var">proxy</span>)
<span class="com">// &lt;- false</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>You can use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/deleteProperty" aria-label="handler.deleteProperty() on MDN"><code class="md-code md-code-inline">handler.deleteProperty</code></a> to prevent a <code class="md-code md-code-inline">delete</code> operation from working. Just like with the <code class="md-code md-code-inline">get</code> and <code class="md-code md-code-inline">set</code> traps, throwing in the <code class="md-code md-code-inline">deleteProperty</code> trap will be enough to prevent the deletion of a property.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">handler</span> <span class="op">=</span> {
  <span class="built_in">get</span> <span class="params">(target, key)</span> {
    <span class="fn">invariant</span>(<span class="param">key</span>, <span class="str">'get'</span>)
    <span class="kw3">return</span> <span class="param">target</span>[<span class="param">key</span>]
  },
  <span class="built_in">set</span> <span class="params">(target, key, value)</span> {
    <span class="fn">invariant</span>(<span class="param">key</span>, <span class="str">'set'</span>)
    <span class="kw3">return</span> <span class="md-code-boolean">true</span>
  },
  <mark class="md-mark md-code-mark">deleteProperty <span class="params">(target, key)</span> {</mark>
    <span class="fn">invariant</span>(<span class="param">key</span>, <span class="str">'delete'</span>)
    <span class="kw3">return</span> <span class="md-code-boolean">true</span>
  }
}
<span class="md-code-function"><span class="kw">function</span> <span class="fn">invariant</span> <span class="params">(key, action)</span> </span>{
  <span class="kw">if</span> (<span class="param">key</span>[<span class="num">0</span>] <span class="op">===</span> <span class="str">'_'</span>) {
    <span class="kw">throw</span> <span class="kw">new</span> <span class="md-code-error">Error</span>(<span class="str">`Invalid attempt to ${action} private "${key}" property`</span>)
  }
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>If we run the exact same piece of code we tried earlier, we’ll run into the exception while trying to delete <code class="md-code md-code-inline">_prop</code> from the <code class="md-code md-code-inline">proxy</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">target</span> <span class="op">=</span> { _prop: <span class="str">'foo'</span> }
<span class="kw">var</span> <span class="var">proxy</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-proxy">Proxy</span>(<span class="var">target</span>, handler)
<span class="kw4">console.log</span>(<span class="str">'_prop'</span> <span class="kw">in</span> <span class="var">proxy</span>)
<span class="com">// &lt;- true</span>
<mark class="md-mark md-code-mark"><span class="kw">delete</span> <span class="var">proxy</span>._prop</mark>
<span class="com">// &lt;- Error: Invalid attempt to delete private "_prop" property</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Deleting properties in your <code class="md-code md-code-inline">_private</code> property space is no longer possible for consumers interacting with <code class="md-code md-code-inline">target</code> through the <code class="md-code md-code-inline">proxy</code>.</p>



<h3 id="defineproperty"><span class="md-heading"><code class="md-code md-code-inline">defineProperty</code></span></h3>

<p>We typically use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" aria-label="Object.defineProperty() on MDN"><code class="md-code md-code-inline">Object.defineProperty(obj, key, descriptor)</code></a> in two types of situations.</p><ol>
  <li>When we wanted to ensure cross-browser support of <em>getters and setters</em></li>
  <li>Whenever we want to define a custom property accessor</li></ol>

<p>Properties added by hand are read-write, they are deletable, and they are enumerable. Properties added through <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" aria-label="Object.defineProperty() on MDN"><code class="md-code md-code-inline">Object.defineProperty</code></a>, <em>in contrast</em>, default to being <em>read-only</em>, <em>write-only</em>, <em>non-deletable</em>, and <em>non-enumerable</em> — in other words, the property starts off being completely <strong>immutable</strong>. You can customize these aspects of the property descriptor, and you can find them below — alongside with their <em>default values</em> when using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" aria-label="Object.defineProperty() on MDN"><code class="md-code md-code-inline">Object.defineProperty</code></a>.</p><ul>
  <li><code class="md-code md-code-inline">configurable: false</code> disables most changes to the property descriptor and makes the property <em>undeletable</em></li>
  <li><code class="md-code md-code-inline">enumerable: false</code> hides the property from <code class="md-code md-code-inline">for..in</code> loops and <code class="md-code md-code-inline">Object.keys</code></li>
  <li><code class="md-code md-code-inline">value: undefined</code> is the initial value for the property</li>
  <li><code class="md-code md-code-inline">writable: false</code> makes the property value immutable</li>
  <li><code class="md-code md-code-inline">get: undefined</code> is a method that acts as the getter for the property</li>
  <li><code class="md-code md-code-inline">set: undefined</code> is a method that receives the new <code class="md-code md-code-inline">value</code> and updates the property’s <code class="md-code md-code-inline">value</code></li></ul>

<p>Note that when defining a property you’ll have to choose between using <code class="md-code md-code-inline">value</code> and <code class="md-code md-code-inline">writable</code> or <code class="md-code md-code-inline">get</code> and <code class="md-code md-code-inline">set</code>. When choosing the former you’re configuring a <em>data descriptor</em> — this is the kind you get when declaring properties like <code class="md-code md-code-inline">foo.bar = 'baz'</code>, it has a <code class="md-code md-code-inline">value</code> and it <em>may or may not</em> be <code class="md-code md-code-inline">writable</code>. When choosing the latter you’re creating an <em>accessor descriptor</em>, which is entirely defined by the methods you can use to <code class="md-code md-code-inline">get()</code> or <code class="md-code md-code-inline">set(value)</code> the value for the property.</p>

<p>The code sample below shows how property descriptors are completely different depending on whether you went for the declarative option or through the programmatic API.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">target</span> <span class="op">=</span> {}
<mark class="md-mark md-code-mark"><span class="var">target</span>.foo <span class="op">=</span> <span class="str">'bar'</span></mark>
<span class="kw4">console.log</span>(<span class="cls">Object</span>.<span class="built_in">getOwnPropertyDescriptor</span>(target, <span class="str">'foo'</span>))
<span class="com">// &lt;- { value: 'bar', writable: true, enumerable: true, configurable: true }</span>
<mark class="md-mark md-code-mark"><span class="cls">Object</span>.<span class="built_in">defineProperty</span>(target, <span class="str">'baz'</span>, { value: <span class="str">'ponyfoo'</span> })</mark>
<span class="kw4">console.log</span>(<span class="cls">Object</span>.<span class="built_in">getOwnPropertyDescriptor</span>(target, <span class="str">'baz'</span>))
<span class="com">// &lt;- { value: 'ponyfoo', writable: false, enumerable: false, configurable: false }</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Now that we went over a blitzkrieg overview of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" aria-label="Object.defineProperty() on MDN"><code class="md-code md-code-inline">Object.defineProperty</code></a>, we can move on to the trap.</p>


<h4 id="it-s-a-trap"><span class="md-heading">It’s a Trap</span></h4>

<p>The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/defineProperty" aria-label="handler.defineProperty() on MDN"><code class="md-code md-code-inline">handler.defineProperty</code></a> trap can be used to intercept calls to <code class="md-code md-code-inline">Object.defineProperty</code>. You get the <code class="md-code md-code-inline">key</code> and the <code class="md-code md-code-inline">descriptor</code> being used. The example below completely prevents the addition of properties through the <code class="md-code md-code-inline">proxy</code>. How cool is it that this intercepts the declarative <code class="md-code md-code-inline">foo.bar = 'baz'</code> property declaration alternative as well? <em>Quite cool!</em></p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">handler</span> <span class="op">=</span> {
  <span class="fn">defineProperty</span> <span class="params">(target, key, descriptor)</span> {
    <mark class="md-mark md-code-mark"><span class="kw3">return</span> <span class="md-code-boolean">false</span></mark>
  }
}
<span class="kw">var</span> <span class="var">target</span> <span class="op">=</span> {}
<span class="kw">var</span> <span class="var">proxy</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-proxy">Proxy</span>(<span class="var">target</span>, <span class="var">handler</span>)
<span class="var">proxy</span>.foo <span class="op">=</span> <span class="str">'bar'</span>
<span class="com">// &lt;- TypeError: proxy defineProperty handler returned false for property '"foo"'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>If we go back to our <em>“private properties”</em> example, we could use the <code class="md-code md-code-inline">defineProperty</code> trap to prevent the creation of private properties through the proxy. We’ll reuse the <code class="md-code md-code-inline">invariant</code> method we had to <code class="md-code md-code-inline">throw</code> on attempts to define a property in the <em>“private <code class="md-code md-code-inline">_</code>-prefixed space”</em>, and that’s it.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">handler</span> <span class="op">=</span> {
  defineProperty <span class="params">(target, key, descriptor)</span> {
    <mark class="md-mark md-code-mark"><span class="fn">invariant</span>(<span class="param">key</span>, <span class="str">'define'</span>)</mark>
    <span class="kw3">return</span> <span class="md-code-boolean">true</span>
  }
}
<span class="md-code-function"><span class="kw">function</span> <span class="fn">invariant</span> <span class="params">(key, action)</span> </span>{
  <span class="kw">if</span> (<span class="param">key</span>[<span class="num">0</span>] <span class="op">===</span> <span class="str">'_'</span>) {
    <span class="kw">throw</span> <span class="kw">new</span> <span class="md-code-error">Error</span>(<span class="str">`Invalid attempt to ${action} private "${key}" property`</span>)
  }
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>You could then try it out on a <code class="md-code md-code-inline">target</code> object, setting properties with a <code class="md-code md-code-inline">_</code> prefix will now throw an error. You could make it fail silently by returning <code class="md-code md-code-inline">false</code> <em>— depends on your use case!</em></p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">target</span> <span class="op">=</span> {}
<span class="kw">var</span> <span class="var">proxy</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-proxy">Proxy</span>(<span class="var">target</span>, handler)
<span class="var">proxy</span>._foo <span class="op">=</span> <span class="str">'bar'</span>
<span class="com">// &lt;- Error: Invalid attempt to define private "_foo" property</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Your <code class="md-code md-code-inline">proxy</code> is now safely hiding <code class="md-code md-code-inline">_private</code> properties behind a trap that guards them from definition through either <code class="md-code md-code-inline">proxy[key] = value</code> or <code class="md-code md-code-inline">Object.defineProperty(proxy, key, { value })</code> <em>— pretty amazing!</em></p>



<h3 id="enumerate"><span class="md-heading"><code class="md-code md-code-inline">enumerate</code></span></h3>

<p>The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/enumerate" aria-label="handler.enumerate() on MDN"><code class="md-code md-code-inline">handler.enumerate</code></a> method can be used to trap <code class="md-code md-code-inline">for..in</code> statements. With <a href="#has" aria-label="ES6 Proxy has trap example"><code class="md-code md-code-inline">has</code></a> we could prevent <code class="md-code md-code-inline">key in proxy</code> from returning <code class="md-code md-code-inline">true</code> for any property in our underscored private space, but what about a <code class="md-code md-code-inline">for..in</code> loop? Even though our <code class="md-code md-code-inline">has</code> trap hides the property from a <code class="md-code md-code-inline">key in proxy</code> check, the consumer will accidentally stumble upon the property when using a <code class="md-code md-code-inline">for..in</code> loop!</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">handler</span> <span class="op">=</span> {
  <span class="built_in">has</span> <span class="params">(target, key)</span> {
    <span class="kw">if</span> (<span class="param">key</span>[<span class="num">0</span>] <span class="op">===</span> <span class="str">'_'</span>) {
      <span class="kw3">return</span> <span class="md-code-boolean">false</span>
    }
    <span class="kw3">return</span> <span class="param">key</span> <span class="kw">in</span> <span class="param">target</span>
  }
}
<span class="kw">var</span> <span class="var">target</span> <span class="op">=</span> { _prop: <span class="str">'foo'</span> }
<span class="kw">var</span> <span class="var">proxy</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-proxy">Proxy</span>(<span class="var">target</span>, <span class="var">handler</span>)
<mark class="md-mark md-code-mark"><span class="kw3">for</span> (<span class="kw">let</span> <span class="var">key</span> <span class="kw">in</span> <span class="var">proxy</span>) {</mark>
  <span class="kw4">console.log</span>(<span class="var">key</span>)
  <span class="com">// &lt;- '_prop'</span>
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>We can use the <code class="md-code md-code-inline">enumerate</code> trap to return an <em>iterator</em> that’ll be used instead of the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in#Description" aria-label="for..in loops on MDN"><em>enumerable properties</em></a> found in <code class="md-code md-code-inline">proxy</code> during a <code class="md-code md-code-inline">for..in</code> loop. The returned iterator must conform to the iterator protocol, such as the iterators returned from any <a href="#es6-iterators-in-depth" aria-label="ES6 Iterators in Depth"><code class="md-code md-code-inline">Symbol.iterator</code></a> method. Here’s a possible implementation of such a <code class="md-code md-code-inline">proxy</code> that would return the output of <code class="md-code md-code-inline">Object.keys</code> minus the properties found in our <em>private space</em>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">handler</span> <span class="op">=</span> {
  <span class="built_in">has</span> <span class="param">(target, key)</span> {
    <span class="kw">if</span> (<span class="param">key</span>[<span class="num">0</span>] <span class="op">===</span> <span class="str">'_'</span>) {
      <span class="kw3">return</span> <span class="md-code-boolean">false</span>
    }
    <span class="kw3">return</span> <span class="param">key</span> <span class="kw">in</span> <span class="param">target</span>
  },
  <span class="built_in">enumerate</span> <span class="param">(target)</span> {
    <span class="kw3">return</span> <span class="cls">Object</span>.<span class="built_in">keys</span>(<span class="param">target</span>).<span class="built_in">filter</span>(key <span class="op">=&gt;</span> key[<span class="num">0</span>] <span class="op">!==</span> <span class="str">'_'</span>)<mark class="md-mark md-code-mark">[<span class="md-code-symbol">Symbol</span>.<span class="built_in">iterator</span>]()</mark>
  }
}
<span class="kw">var</span> <span class="var">target</span> <span class="op">=</span> { pony: <span class="str">'foo'</span>, _bar: <span class="str">'baz'</span>, _prop: <span class="str">'foo'</span> }
<span class="kw">var</span> <span class="var">proxy</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-proxy">Proxy</span>(<span class="var">target</span>, <span class="var">handler</span>)
<span class="kw3">for</span> (<span class="kw">let</span> <span class="var">key</span> <span class="kw">in</span> <span class="var">proxy</span>) {
  <span class="kw4">console.log</span>(<span class="var">key</span>)
  <span class="com">// &lt;- 'pony'</span>
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Now your private properties are hidden from those prying <code class="md-code md-code-inline">for..in</code> eyes!</p>



<h3 id="ownkeys"><span class="md-heading"><code class="md-code md-code-inline">ownKeys</code></span></h3>

<p>The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/ownKeys" aria-label="handler.ownKeys() on MDN"><code class="md-code md-code-inline">handler.ownKeys</code></a> method may be used to return an <code class="md-code md-code-inline">Array</code> of properties that will be used as a result for <code class="md-code md-code-inline">Reflect.ownKeys()</code> <em>— it should include all properties of <code class="md-code md-code-inline">target</code> (enumerable or not, and symbols too).</em> A default implementation, <em>as seen below</em>, could just call <code class="md-code md-code-inline">Reflect.ownKeys</code> on the proxied <code class="md-code md-code-inline">target</code> object. Don’t worry, we’ll get to the <code class="md-code md-code-inline">Reflect</code> built-in later in the es6-in-depth series.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">handler</span> <span class="op">=</span> {
  <span class="built_in">ownKeys</span> <span class="params">(target)</span> {
    <mark class="md-mark md-code-mark"><span class="kw3">return</span> <span class="cls">Reflect</span>.<span class="built_in">ownKeys</span>(<span class="param">target</span>)</mark>
  }
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Interception wouldn’t affect the output of <code class="md-code md-code-inline">Object.keys</code> in this case.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">target</span> <span class="op">=</span> {
  _bar: <span class="str">'foo'</span>,
  _prop: <span class="str">'bar'</span>,
  [<span class="md-code-symbol">Symbol</span>(<span class="str">'secret'</span>)]: <span class="str">'baz'</span>,
  pony: <span class="str">'ponyfoo'</span>
}
<span class="kw">var</span> <span class="var">proxy</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-proxy">Proxy</span>(<span class="var">target</span>, handler)
<span class="kw3">for</span> (<span class="kw">let</span> <span class="var">key</span> <span class="kw">of</span> <span class="cls">Object</span>.<span class="built_in">keys</span>(<span class="var">proxy</span>)) {
  <span class="kw4">console.log</span>(<span class="var">key</span>)
  <span class="com">// &lt;- '_bar'</span>
  <span class="com">// &lt;- '_prop'</span>
  <span class="com">// &lt;- 'pony'</span>
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Do note that the <code class="md-code md-code-inline">ownKeys</code> interceptor is used during all of the following operations.</p><ul>
  <li><code class="md-code md-code-inline">Object.getOwnPropertyNames()</code> — just non-symbol properties</li>
  <li><code class="md-code md-code-inline">Object.getOwnPropertySymbols()</code> — just symbol properties</li>
  <li><code class="md-code md-code-inline">Object.keys()</code> — just non-symbol enumerable properties</li>
  <li><code class="md-code md-code-inline">Reflect.ownKeys()</code> — we’ll get to <code class="md-code md-code-inline">Reflect</code> later in the series!</li></ul>

<p>In the use case where we want to shut off access to a property space prefixed by <code class="md-code md-code-inline">_</code>, we could take the output of <code class="md-code md-code-inline">Reflect.ownKeys(target)</code> and filter that.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">handler</span> <span class="op">=</span> {
  <span class="built_in">ownKeys</span> <span class="params">(target)</span> {
    <span class="kw3">return</span> <span class="cls">Reflect</span>.<span class="built_in">ownKeys</span>(<span class="param">target</span>).<span class="built_in">filter</span>(<mark class="md-mark md-code-mark">key <span class="op">=&gt;</span> key[<span class="num">0</span>] <span class="op">!==</span> <span class="str">'_'</span></mark>)
  }
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>If we now used the <code class="md-code md-code-inline">handler</code> in the snippet above to pull the object keys, we’ll just find the properties in the public, non <code class="md-code md-code-inline">_</code>-prefixed space.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">target</span> <span class="op">=</span> {
  _bar: <span class="str">'foo'</span>,
  _prop: <span class="str">'bar'</span>,
  [<span class="md-code-symbol">Symbol</span>(<span class="str">'secret'</span>)]: <span class="str">'baz'</span>,
  pony: <span class="str">'ponyfoo'</span>
}
<span class="kw">var</span> <span class="var">proxy</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-proxy">Proxy</span>(<span class="var">target</span>, <span class="var">handler</span>)
<span class="kw3">for</span> (<span class="kw">let</span> <span class="var">key</span> <span class="kw">of</span> <mark class="md-mark md-code-mark"><span class="cls">Object</span>.<span class="built_in">keys</span>(<span class="var">proxy</span>)</mark>) {
  <span class="kw4">console.log</span>(<span class="var">key</span>)
  <span class="com">// &lt;- 'pony'</span>
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Symbol iteration wouldn’t be affected by this as <code class="md-code md-code-inline">sym[0]</code> yields <code class="md-code md-code-inline">undefined</code> <em>— and in any case decidedly not <code class="md-code md-code-inline">'_'</code>.</em></p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">target</span> <span class="op">=</span> {
  _bar: <span class="str">'foo'</span>,
  _prop: <span class="str">'bar'</span>,
  [<mark class="md-mark md-code-mark"><span class="md-code-symbol">Symbol</span>(<span class="str">'secret'</span>)</mark>]: <span class="str">'baz'</span>,
  pony: <span class="str">'ponyfoo'</span>
}
<span class="kw">var</span> <span class="var">proxy</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-proxy">Proxy</span>(<span class="var">target</span>, handler)
<span class="kw3">for</span> (<span class="kw">let</span> <span class="var">key</span> <span class="kw">of</span> <mark class="md-mark md-code-mark"><span class="cls">Object</span>.getOwnPropertySymbols(<span class="var">proxy</span>)</mark>) {
  <span class="kw4">console.log</span>(<span class="var">key</span>)
  <span class="com">// &lt;- Symbol(secret)</span>
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>We were able to hide properties prefixed with <code class="md-code md-code-inline">_</code> from key enumeration while leaving symbols and other properties unaffected.</p>



<h3 id="apply"><span class="md-heading"><code class="md-code md-code-inline">apply</code></span></h3>

<p>The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/apply" aria-label="handler.apply() on MDN"><code class="md-code md-code-inline">handler.apply</code></a> method is quite interesting. You can use it as a trap on any invocation of <code class="md-code md-code-inline">proxy</code>. All of the following will go through the <code class="md-code md-code-inline">apply</code> trap for your proxy.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="var">proxy</span>(<span class="num">1</span>, <span class="num">2</span>)
<span class="var">proxy</span>(<span class="op">...</span>args)
<span class="var">proxy</span>.<span class="built_in">call</span>(<span class="md-code-null">null</span>, <span class="num">1</span>, <span class="num">2</span>)
<span class="var">proxy</span>.<span class="built_in">apply</span>(<span class="md-code-null">null</span>, [<span class="num">1</span>, <span class="num">2</span>])
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The <code class="md-code md-code-inline">apply</code> method takes three arguments.</p><ul>
  <li><code class="md-code md-code-inline">target</code> — the function being proxied</li>
  <li><code class="md-code md-code-inline">ctx</code> — the context passed as <code class="md-code md-code-inline">this</code> to <code class="md-code md-code-inline">target</code> when applying a call</li>
  <li><code class="md-code md-code-inline">args</code> — the arguments passed to <code class="md-code md-code-inline">target</code> when applying the call</li></ul>

<p>A naïve implementation might look like <code class="md-code md-code-inline">target.apply(ctx, args)</code>, but below we’ll be using <code class="md-code md-code-inline">Reflect.apply(...arguments)</code>. We’ll dig deeper into the <code class="md-code md-code-inline">Reflect</code> built-in later in the series. For now, just think of them as equivalent, and take into account that the value returned by the <code class="md-code md-code-inline">apply</code> trap is also going to be used as the result of a function call through <code class="md-code md-code-inline">proxy</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">handler</span> <span class="op">=</span> {
  <span class="fn">apply</span> <span class="params">(target, ctx, args)</span> {
    <span class="kw3">return</span> <mark class="md-mark md-code-mark"><span class="cls">Reflect</span>.<span class="fn">apply</span>(<span class="op">...</span>arguments)</mark>
  }
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Besides the obvious <em>"being able to log all parameters of every function call for <code class="md-code md-code-inline">proxy</code>"</em>, this trap can be used for parameter balancing and to tweak the results of a function call without changing the method itself <em>— and without changing the calling code either.</em></p>

<p>The example below proxies a <code class="md-code md-code-inline">sum</code> method through a <code class="md-code md-code-inline">twice</code> trap handler that doubles the results of <code class="md-code md-code-inline">sum</code> without affecting the code around it other than using the <code class="md-code md-code-inline">proxy</code> instead of the <code class="md-code md-code-inline">sum</code> method directly.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">twice</span> <span class="op">=</span> {
  <span class="fn">apply</span> <span class="params">(target, ctx, args)</span> {
    <span class="kw3">return</span> <span class="cls">Reflect</span>.<span class="fn">apply</span>(<span class="op">...</span>arguments) <mark class="md-mark md-code-mark"><span class="op">*</span> <span class="num">2</span></mark>
  }
}
<span class="md-code-function"><span class="kw">function</span> <span class="fn">sum</span> <span class="params">(left, right)</span> </span>{
  <span class="kw3">return</span> <span class="param">left</span> <span class="op">+</span> <span class="param">right</span>
}
<span class="kw">var</span> <span class="var">proxy</span> <span class="op">=</span> <mark class="md-mark md-code-mark"><span class="kw">new</span> <span class="md-code-proxy">Proxy</span>(<span class="fn">sum</span>, <span class="var">twice</span>)</mark>
<span class="kw4">console.log</span>(<span class="var">proxy</span>(<span class="num">1</span>, <span class="num">2</span>))
<span class="com">// &lt;- 6</span>
<span class="kw4">console.log</span>(<span class="var">proxy</span>(<span class="op">...</span>[<span class="num">3</span>, <span class="num">4</span>]))
<span class="com">// &lt;- 14</span>
<span class="kw4">console.log</span>(<span class="var">proxy</span>.<span class="built_in">call</span>(<span class="md-code-null">null</span>, <span class="num">5</span>, <span class="num">6</span>))
<span class="com">// &lt;- 22</span>
<span class="kw4">console.log</span>(<span class="var">proxy</span>.<span class="built_in">apply</span>(<span class="md-code-null">null</span>, [<span class="num">7</span>, <span class="num">8</span>]))
<span class="com">// &lt;- 30</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Naturally, calling <code class="md-code md-code-inline">Reflect.apply</code> on the <code class="md-code md-code-inline">proxy</code> will be caught by the <code class="md-code md-code-inline">apply</code> <em>trap</em> as well.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="cls">Reflect</span>.<span class="built_in">apply</span>(<span class="var">proxy</span>, <span class="md-code-null">null</span>, [<span class="num">9</span>, <span class="num">10</span>])
<span class="com">// &lt;- 38</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->
<blockquote>

<p>What else would you use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/apply" aria-label="handler.apply() on MDN"><code class="md-code md-code-inline">handler.apply</code></a> for?</p></blockquote>

<p>Tomorrow I’ll publish the last article on <code class="md-code md-code-inline">Proxy</code> <em>— Promise! —</em> It’ll include the remaining <em>trap</em> handlers, such as <code class="md-code md-code-inline">construct</code> and <code class="md-code md-code-inline">getPrototypeOf</code>. </p></section></section>

</article>
</div>
<p><a href="#top" class="top"><img src="./auxi/glyphicons-214-up-arrow.png" alt="up-arrow" class="uparrow" /> <b>Back to top</b></a></p></section></main>


<!--  proxy traps ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->
<!--  ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->









<!--  more-proxy-traps ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->

<main class="ly-main"><header class="at-header">



<h1 itemprop="headline" class="dc-title" id="more-es6-proxy-traps-in-depth">More ES6 Proxy Traps in Depth</h1></header>

<section class="at-teaser"><div class="at-teaser-markdown md-markdown">

<p>Hey there! This is ES6 — <em>“Traps? Again?”</em> — in Depth. Looking for other ES6 goodness? Refer to <a href="#a-brief-history-of-es6-tooling">A Brief History of ES6 Tooling</a>. Then, make your way through <a href="#es6-destructuring-in-depth">destructuring</a>, <a href="#es6-template-strings-in-depth">template literals</a>, <a href="#es6-arrow-functions-in-depth">arrow functions</a>, the <a href="#es6-spread-and-butter-in-depth">spread operator and rest parameters</a>, improvements coming to <a href="#es6-object-literal-features-in-depth">object literals</a>, the new <a href="#es6-classes-in-depth"><em>classes</em></a> sugar on top of prototypes, <a href="#es6-let-const-and-temporal-dead-zone-in-depth"><code class="md-code md-code-inline">let</code>, <code class="md-code md-code-inline">const</code>, and the <em>“Temporal Dead Zone”</em></a>, <a href="#es6-iterators-in-depth">iterators</a>, <a href="#es6-generators-in-depth">generators</a>, <a href="#es6-symbols-in-depth">Symbols</a>, <a href="#es6-maps-in-depth">Maps</a>, <a href="#es6-weakmaps-sets-and-weaksets-in-depth">WeakMaps, Sets, and WeakSets</a>, <a href="#es6-proxies-in-depth">proxies</a>, and <a href="#es6-proxy-traps-in-depth">proxy traps</a>. We’ll be discussing about <em><strong>more</strong> ES6 proxy <strong>traps</strong></em> today.</p></div></section>

<section class="at-container de-host"><div class="de-column">

<article itemscope="itemscope" itemtype="http://schema.org/BlogPosting" class="at-article ly-section">
<meta itemprop="dateCreated" content="2015-09-07T20:22:21+00:00" />
<meta itemprop="datePublished" content="2015-09-16T12:00:01+00:00" />
<meta itemprop="dateModified" content="2015-10-11T04:06:37+00:00" />
<meta itemprop="keywords" content="es6,proxies,traps,es6-in-depth" />

<section itemprop="articleBody" class="at-corpus">

<section itemprop="about" class="md-markdown at-introduction"><blockquote>

<p>As I did in previous articles on the series, I would love to point out that you should probably <a href="#universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That’ll make it so much easier for you to <strong>internalize the concepts</strong> discussed in the series. If you aren’t the <em>“install things on my computer”</em> kind of human, you might prefer to hop on <a href="http://codepen.io/">CodePen</a> and then click on the gear icon for JavaScript — <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em> Another alternative that’s also quite useful is to use Babel’s <a href="http://babeljs.io/repl/">online REPL</a> <em>— it’ll show you compiled ES5 code to the right of your ES6 code for quick comparison.</em></p>

<p>Note that <code class="md-code md-code-inline">Proxy</code> is harder to play around with as Babel doesn’t support it unless the underlying browser has support for it. You can check out the <a href="http://kangax.github.io/compat-table/es6/">ES6 compatibility table</a> for supporting browsers. At the time of this writing, you can use <em>Microsoft Edge</em> or <em>Mozilla Firefox</em> to try out <code class="md-code md-code-inline">Proxy</code>. Personally, I’ll be verifying my examples using <em>Firefox</em>.</p></blockquote>

<p>Before getting into it, let me <a href="https://www.patreon.com/bevacqua"><em>shamelessly ask for your support</em></a> if you’re enjoying my ES6 in Depth series. Your contributions will go towards helping me keep up with the schedule, server bills, keeping me fed, and maintaining <strong>Pony Foo</strong> as a veritable source of JavaScript goodies.</p>

<p>Thanks for reading that, and let’s go into even more <code class="md-code md-code-inline">Proxy</code> <em>traps</em> now! If you haven’t yet, I encourage you to read the previous article on <a href="#es6-proxies-in-depth">the <code class="md-code md-code-inline">Proxy</code> built-in</a> for an introduction to the subject and the one about the <a href="#es6-proxy-traps-in-depth">first few traps I covered</a>.</p></section>

<section class="md-markdown at-body">



<h2 id="but-wait-there-s-more-proxy-trap-handlers"><span class="md-heading">But Wait! There’s More… <em>(Proxy Trap Handlers)</em></span></h2>

<p>This article covers all the trap handlers that weren’t covered by the two previous articles on proxies. For the most part, the traps that we discussed yesterday had to do with property manipulation, while the first five traps we’ll dig into today have mostly to do with the object being proxied <em>itself</em>. The last two have to do with properties once again — but they’re a bit more involved than yesterday’s traps, which were much easier to “fall into” <em>(the trap — muahaha)</em> in your everyday code.</p><ul>
  <li><a href="#construct"><code class="md-code md-code-inline">construct</code></a> — traps usage of the <code class="md-code md-code-inline">new</code> operator</li>
  <li><a href="#getprototypeof"><code class="md-code md-code-inline">getPrototypeOf</code></a> — traps internal calls to <code class="md-code md-code-inline">[[GetPrototypeOf]]</code></li>
  <li><a href="#setprototypeof"><code class="md-code md-code-inline">setPrototypeOf</code></a> — traps calls to <code class="md-code md-code-inline">Object.setPrototypeOf</code></li>
  <li><a href="#isextensible"><code class="md-code md-code-inline">isExtensible</code></a> — traps calls to <code class="md-code md-code-inline">Object.isExtensible</code></li>
  <li><a href="#preventextensions"><code class="md-code md-code-inline">preventExtensions</code></a> — traps calls to <code class="md-code md-code-inline">Object.preventExtensions</code></li>
  <li><a href="#getownpropertydescriptor"><code class="md-code md-code-inline">getOwnPropertyDescriptor</code></a> — traps calls to <code class="md-code md-code-inline">Object.getOwnPropertyDescriptor</code></li></ul>



<h3 id="construct"><span class="md-heading"><code class="md-code md-code-inline">construct</code></span></h3>

<p>You can use the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/construct" aria-label="handler.construct() on MDN"><code class="md-code md-code-inline">handler.construct</code></a> method to trap usage of the <code class="md-code md-code-inline">new</code> operator. Here’s a quick <em>“default implementation”</em> that doesn’t alter the behavior of <code class="md-code md-code-inline">new</code> at all. <em>Remember our friend the <a href="#es6-spread-and-butter-in-depth" aria-label="ES6 Spread and Butter in Depth">spread operator</a>?</em></p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">handler</span> <span class="op">=</span> {
  <span class="fn">construct</span> <span class="params">(target, args)</span> {
    <span class="kw3">return</span> <span class="kw">new</span> <span class="param">target</span>(<mark class="md-mark md-code-mark"><span class="op">...</span><span class="param">args</span></mark>)
  }
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>If you use the <code class="md-code md-code-inline">handler</code> options above, the <code class="md-code md-code-inline">new</code> behavior you’re already used to would remain unchanged. That’s great because it means whatever you’re trying to accomplish you can still fall back to the <strong>default behavior</strong> <em>— and that’s always important.</em></p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">target</span> <span class="params">(a, b, c)</span> </span>{
  <span class="kw3">this</span>.a <span class="op">=</span> <span class="param">a</span>
  <span class="kw3">this</span>.b <span class="op">=</span> <span class="param">b</span>
  <span class="kw3">this</span>.c <span class="op">=</span> <span class="param">c</span>
}
<span class="kw">var</span> <span class="var">proxy</span> <span class="op">=</span> <span class="kw">new</span> <span class="cls">Proxy</span>(<span class="fn">target</span>, <span class="var">handler</span>)
<span class="kw4">console.log</span>(<span class="kw">new</span> <span class="var">proxy</span>(<span class="num">1</span>,<span class="num">2</span>,<span class="num">3</span>))
<span class="com">// &lt;- { a: 1, b: 2, c: 3 }</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Obvious use cases for <code class="md-code md-code-inline">construct</code> traps include data massaging in the arguments, doing things that should always be done around a call to <code class="md-code md-code-inline">new proxy()</code>, logging and tracking object creation, and swapping implementations entirely. Imagine a proxy like the following in situations where you have inheritance <em>“branching”</em>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">class</span> <span class="cls">Automobile</span> {}
<span class="kw">class</span> <span class="cls">Car</span> <span class="kw">extends</span> <span class="cls">Automobile</span> {}
<span class="kw">class</span> <span class="cls">SurveillanceVan</span> <span class="kw">extends</span> <span class="cls">Automobile</span> {}
<span class="kw">class</span> <span class="cls">SUV</span> <span class="kw">extends</span> <span class="cls">Automobile</span> {}
<span class="kw">class</span> <span class="cls">SportsCar</span> <span class="kw">extends</span> <span class="cls">Car</span> {}
<span class="md-code-function"><span class="kw">function</span> <span class="fn">target</span> <span class="params">()</span> </span>{}
<span class="kw">var</span> <span class="var">handler</span> <span class="op">=</span> {
  <span class="fn">construct</span> <span class="params">(target, args)</span> {
    <span class="kw">var</span> <mark class="md-mark md-code-mark">[<span class="var">status</span>]</mark> <span class="op">=</span> <span class="param">args</span>
    <span class="kw">if</span> (<span class="var">status</span> <span class="op">===</span> <span class="str">'nsa'</span>) {
      <span class="kw3">return</span> <mark class="md-mark md-code-mark"><span class="kw">new</span> <span class="cls">SurveillanceVan</span>(<span class="op">...</span><span class="param">args</span>)</mark>
    }
    <span class="kw">if</span> (<span class="var">status</span> <span class="op">===</span> <span class="str">'single'</span>) {
      <span class="kw3">return</span> <span class="kw">new</span> <span class="cls">SportsCar</span>(<span class="op">...</span><span class="param">args</span>)
    }
    <span class="kw3">return</span> <span class="kw">new</span> <span class="cls">SUV</span>(<span class="op">...</span><span class="param">args</span>) <span class="com">// family</span>
  }
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Naturally, you could’ve used a regular method for the branching part, but using the <code class="md-code md-code-inline">new</code> operator also makes sense in these types of situations, as you’ll end up creating a new object in all code branches anyways.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw4">console.log</span>(<span class="kw">new</span> <span class="var">proxy</span>(<span class="str">'nsa'</span>).<span class="built_in">constructor.name</span>)
<span class="com">// &lt;- `SurveillanceVan`</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The most common use case for <code class="md-code md-code-inline">construct</code> traps yet may be something simpler, and that’s extending the <code class="md-code md-code-inline">target</code> object right after creation, <em>— and before anything else happens –</em> in such a way that it better supports the <code class="md-code md-code-inline">proxy</code> gatekeeper. You might have to add a <code class="md-code md-code-inline">proxied</code> flag to the <code class="md-code md-code-inline">target</code> object, or something akin to that.</p>



<h3 id="getprototypeof"><span class="md-heading"><code class="md-code md-code-inline">getPrototypeOf</code></span></h3>

<p>You can use the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getPrototypeOf" aria-label="handler.getPrototypeOf() on MDN"><code class="md-code md-code-inline">handler.getPrototypeOf</code></a> method as a trap for all of the following.</p><ul>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto" aria-label="__proto__ on MDN"><code class="md-code md-code-inline">Object.prototype.__proto__</code></a> property</li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isPrototypeOf" aria-label="Object.prototype.isPrototypeOf() on MDN"><code class="md-code md-code-inline">Object.prototype.isPrototypeOf()</code></a> method</li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf" aria-label="Object.getPrototypeOf() on MDN"><code class="md-code md-code-inline">Object.getPrototypeOf()</code></a> method</li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/getPrototypeOf" aria-label="Reflect.getPrototypeOf() on MDN"><code class="md-code md-code-inline">Reflect.getPrototypeOf()</code></a> method</li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof" aria-label="instanceof on MDN"><code class="md-code md-code-inline">instanceof</code></a> operator</li></ul>

<p>You could use this <em>trap</em> to make an object pretend it’s an <code class="md-code md-code-inline">Array</code>, when accessed through the proxy. However, note that that on its own isn’t sufficient for the <code class="md-code md-code-inline">proxy</code> to be an actual <code class="md-code md-code-inline">Array</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">handler</span> <span class="op">=</span> {
  getPrototypeOf: <mark class="md-mark md-code-mark">target <span class="op">=&gt;</span> <span class="kw">Array</span>.<span class="built_in">prototype</span></mark>
}
<span class="kw">var</span> <span class="var">target</span> <span class="op">=</span> {}
<span class="kw">var</span> <span class="var">proxy</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-proxy">Proxy</span>(<span class="var">target</span>, <span class="var">handler</span>)
<span class="kw4">console.log</span>(<span class="var">proxy</span> <span class="kw">instanceof</span> <span class="kw">Array</span>)
<span class="com">// &lt;- true</span>
<span class="kw4">console.log</span>(<span class="var">proxy</span>.<span class="built_in">push</span>)
<span class="com">// &lt;- undefined</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Naturally, you could keep on patching your <code class="md-code md-code-inline">proxy</code> until you get the behavior you want. In this case, you may want to use a <code class="md-code md-code-inline">get</code> trap to mix the <code class="md-code md-code-inline">Array.prototype</code> with the actual back-end <code class="md-code md-code-inline">target</code>. Whenever a property isn’t found on the <code class="md-code md-code-inline">target</code>, we’ll use reflection to look it up on <code class="md-code md-code-inline">Array.prototype</code>. It turns out, this is <strong>good enough</strong> for most operations.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">handler</span> <span class="op">=</span> {
  getPrototypeOf: target <span class="op">=&gt;</span> <span class="kw">Array</span>.<span class="built_in">prototype</span>,
  <span class="built_in">get</span> <span class="params">(target, key)</span> {
    <span class="kw3">return</span> <span class="cls">Reflect</span>.<span class="built_in">get</span>(<span class="param">target</span>, <span class="param">key</span>) <span class="op">||</span> <mark class="md-mark md-code-mark"><span class="cls">Reflect</span>.<span class="built_in">get</span>(<span class="kw">Array</span>.<span class="built_in">prototype</span>, <span class="param">key</span>)</mark>
  }
}
<span class="kw">var</span> <span class="var">target</span> <span class="op">=</span> {}
<span class="kw">var</span> <span class="var">proxy</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-proxy">Proxy</span>(<span class="var">target</span>, <span class="var">handler</span>)
<span class="kw4">console.log</span>(<span class="var">proxy</span>.<span class="built_in">push</span>)
<span class="com">// &lt;- function push () { [native code] }</span>
<mark class="md-mark md-code-mark"><span class="var">proxy</span>.<span class="built_in">push</span>(<span class="str">'a'</span>, <span class="str">'b'</span>)</mark>
<span class="kw4">console.log</span>(<span class="var">proxy</span>)
<span class="com">// &lt;- { 0: 'a', 1: 'b', length: 2 }</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>I definitely see some advanced use cases for <code class="md-code md-code-inline">getPrototypeOf</code> traps in the future, but it’s too early to tell what patterns may come out of it.</p>



<h3 id="setprototypeof"><span class="md-heading"><code class="md-code md-code-inline">setPrototypeOf</code></span></h3>

<p>The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf" aria-label="Object.setPrototypeOf() on MDN"><code class="md-code md-code-inline">Object.setPrototypeOf</code></a> method does exactly what its name conveys: it sets the prototype of an object to a reference to another object. It’s considered the proper way of setting the prototype as opposed to using <code class="md-code md-code-inline">__proto__</code> which is a legacy feature <em>— and now standarized as such.</em></p>

<p>You can use the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/setPrototypeOf" aria-label="handler.setPrototypeOf() on MDN"><code class="md-code md-code-inline">handler.setPrototypeOf</code></a> method to set up a <em>trap</em> for <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf" aria-label="Object.setPrototypeOf() on MDN"><code class="md-code md-code-inline">Object.setPrototypeOf</code></a>. The snippet of code shown below doesn’t alter the default behavior of changing a prototype to the value of <code class="md-code md-code-inline">proto</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">handler</span> <span class="op">=</span> {
  <span class="fn">setPrototypeOf</span> <span class="params">(target, proto)</span> {
    <mark class="md-mark md-code-mark"><span class="cls">Object</span>.<span class="built_in">setPrototypeOf</span>(<span class="param">target</span>, <span class="param">proto</span>)</mark>
  }
}
<span class="kw">var</span> <span class="var">proto</span> <span class="op">=</span> {}
<span class="kw">var</span> <span class="var">target</span> <span class="op">=</span> <span class="md-code-function"><span class="kw">function</span> <span class="params">()</span> </span>{}
<span class="kw">var</span> <span class="var">proxy</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-proxy">Proxy</span>(<span class="var">target</span>, <span class="var">handler</span>)
<span class="var">proxy</span>.<span class="built_in">setPrototypeOf</span>(<span class="var">proxy</span>, <span class="var">proto</span>)
<span class="kw4">console.log</span>(<span class="var">proxy</span>.<span class="built_in">prototype</span> <span class="op">===</span> <span class="var">proto</span>)
<span class="com">// &lt;- true</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The field for <code class="md-code md-code-inline">setPrototypeOf</code> is pretty open. You could simply not call <code class="md-code md-code-inline">Object.setPrototypeOf</code> and the trap would sink the call into a <em>no-op</em>. You could <code class="md-code md-code-inline">throw</code> an exception making the failure more explicit — for instance if you deem the new prototype to be invalid or you don’t want consumers pulling the rug from under your feet.</p>

<p>This is a nice <em>trap</em> to have if you want proxies to have limited access to what they can do with your <code class="md-code md-code-inline">target</code> object. I would definitely implement a trap like the one below if I had any security concerns at all in a proxy I’m passing away to third party code.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">handler</span> <span class="op">=</span> {
  <span class="fn">setPrototypeOf</span> <span class="params">(target, proto)</span> {
    <mark class="md-mark md-code-mark"><span class="kw">throw</span> <span class="kw">new</span> <span class="md-code-error">Error</span>(<span class="str">'Changing the prototype is forbidden'</span>)</mark>
  }
}
<span class="kw">var</span> <span class="var">proto</span> <span class="op">=</span> {}
<span class="kw">var</span> <span class="var">target</span> <span class="op">=</span> <span class="md-code-function"><span class="kw">function</span> <span class="params">()</span> </span>{}
<span class="kw">var</span> <span class="var">proxy</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-proxy">Proxy</span>(<span class="var">target</span>, <span class="var">handler</span>)
<span class="var">proxy</span>.<span class="built_in">setPrototypeOf</span>(<span class="var">proxy</span>, <span class="var">proto</span>)
<span class="com">// &lt;- Error: Changing the prototype is forbidden</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->

<p>Then again, you may want to fail silently with no error being thrown at all if you’d rather confuse the consumer — and that may just make them go away.</p>



<h3 id="isextensible"><span class="md-heading"><code class="md-code md-code-inline">isExtensible</code></span></h3>

<p>The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/isExtensible" aria-label="handler.isExtensible() on MDN"><code class="md-code md-code-inline">handler.isExtensible</code></a> method can be mostly used for logging or auditing calls to <code class="md-code md-code-inline">Object.isExtensible</code>. This <em>trap</em> is subject to a harsh invariant that puts a hard limit to what you can do with it.</p><blockquote>

<p>If <code class="md-code md-code-inline">Object.isExtensible(proxy) !== Object.isExtensible(target)</code>, then a <code class="md-code md-code-inline">TypeError</code> is thrown.</p></blockquote>

<p>You could use the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/isExtensible" aria-label="handler.isExtensible() on MDN"><code class="md-code md-code-inline">handler.isExtensible</code></a> trap to <code class="md-code md-code-inline">throw</code> if you don’t want consumers to know whether the original object is extensible or not, but there seem to be limited situations that would warrant such an <strong>incarnation of evil</strong>. For completeness’ sake, the piece of code below shows a trap for <code class="md-code md-code-inline">isExtensible</code> that throws errors every once in a while, but otherwise behaves as expected.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">handler</span> <span class="op">=</span> {
  <span class="fn">isExtensible</span> <span class="params">(target)</span> {
    <span class="kw">if</span> (<span class="cls">Math</span>.<span class="built_in">random</span>() <span class="op">&gt;</span>
<span class="num">0.1</span>) {
      <span class="kw">throw</span> <span class="kw">new</span> <span class="md-code-error">Error</span>(<span class="str">'gotta love sporadic obscure errors!'</span>)
    }
    <span class="kw3">return</span> <mark class="md-mark md-code-mark"><span class="cls">Object</span>.<span class="built_in">isExtensible</span>(<span class="param">target</span>)</mark>
  }
}
<span class="kw">var</span> <span class="var">target</span> <span class="op">=</span> {}
<span class="kw">var</span> <span class="var">proxy</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-proxy">Proxy</span>(<span class="var">target</span>, <span class="var">handler</span>)
<span class="kw4">console.log</span>(<span class="cls">Object</span>.<span class="built_in">isExtensible</span>(<span class="var">proxy</span>))
<span class="com">// &lt;- true</span>
<span class="kw4">console.log</span>(<span class="cls">Object</span>.<span class="built_in">isExtensible</span>(<span class="var">proxy</span>))
<span class="com">// &lt;- true</span>
<span class="kw4">console.log</span>(<span class="cls">Object</span>.<span class="built_in">isExtensible</span>(<span class="var">proxy</span>))
<span class="com">// &lt;- true</span>
<span class="kw4">console.log</span>(<span class="cls">Object</span>.<span class="built_in">isExtensible</span>(<span class="var">proxy</span>))
<span class="com">// &lt;- <mark class="md-mark md-code-mark">Error: gotta love sporadic obscure errors!</mark></span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>While this <em>trap</em> is nearly useless other than for auditing purposes and to cover all your bases, the <em>hard-to-break</em> invariant makes sense because there’s also the <code class="md-code md-code-inline">preventExtensions</code> <em>trap</em>. <strong>That one is a little bit more useful!</strong></p>



<h3 id="preventextensions"><span class="md-heading"><code class="md-code md-code-inline">preventExtensions</code></span></h3>

<p>You can use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/preventExtensions" aria-label="handler.preventExtensions() on MDN"><code class="md-code md-code-inline">handler.preventExtensions</code></a> to <em>trap</em> the <code class="md-code md-code-inline">Object.preventExtensions</code> method. When extensions are prevented on an object, new properties can’t be added any longer <em>— it can’t be extended.</em></p>

<p>Imagine a scenario where you want to selectively be able to <code class="md-code md-code-inline">preventExtensions</code> on some objects — but not all of them. In this scenario, you could use a <code class="md-code md-code-inline">WeakSet</code> to keep track of the objects that should be extensible. If an object is in the set, then the <code class="md-code md-code-inline">preventExtensions</code> <em>trap</em> should be able to capture those requests and discard them. The snippet below does exactly that. Note that the <em>trap</em> always returns the opposite of <code class="md-code md-code-inline">Object.isExtensible(target)</code>, because it should report whether the object has been made non-extensible.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">mustExtend</span> <span class="op">=</span> <mark class="md-mark md-code-mark"><span class="kw">new</span> <span class="md-code-set">WeakSet</span>()</mark>
<span class="kw">var</span> <span class="var">handler</span> <span class="op">=</span> {
  <span class="fn">preventExtensions</span> <span class="params">(target)</span> {
    <span class="kw">if</span> (<mark class="md-mark md-code-mark"><span class="op">!</span><span class="var">mustExtend</span>.<span class="built_in">has</span>(<span class="param">target</span>)</mark>) {
      <span class="cls">Object</span>.<span class="method">preventExtensions</span>(<span class="param">target</span>)
    }
    <span class="kw3">return</span> <mark class="md-mark md-code-mark"><span class="op">!</span><span class="cls">Object</span>.<span class="built_in">isExtensible</span>(<span class="param">target</span>)</mark>
  }
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Now that we’ve set up the <code class="md-code md-code-inline">handler</code> and our <code class="md-code md-code-inline">WeakSet</code>, we can create a back-end object, a <code class="md-code md-code-inline">proxy</code>, and add the back-end to our set. Then, you can try <code class="md-code md-code-inline">Object.preventExtensions</code> on the proxy and you’ll notice it fails to prevent extensions to the object. This is the intended behavior as the <code class="md-code md-code-inline">target</code> can be found in the <code class="md-code md-code-inline">mustExtend</code> set.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">target</span> <span class="op">=</span> {}
<span class="kw">var</span> <span class="var">proxy</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-proxy">Proxy</span>(<span class="var">target</span>, <span class="var">handler</span>)
<mark class="md-mark md-code-mark"><span class="var">mustExtend</span>.<span class="built_in">add</span>(<span class="param">target</span>)</mark>
<span class="cls">Object</span>.<span class="method">preventExtensions</span>(<span class="var">proxy</span>)
<span class="com">// &lt;- TypeError: proxy preventExtensions handler returned false</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>If we removed the <code class="md-code md-code-inline">target</code> from the <code class="md-code md-code-inline">mustExtend</code> set before calling <code class="md-code md-code-inline">Object.preventExtensions</code>, then <code class="md-code md-code-inline">target</code> would be made non-extensible as originally intended.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">target</span> <span class="op">=</span> {}
<span class="kw">var</span> <span class="var">proxy</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-proxy">Proxy</span>(<span class="var">target</span>, <span class="var">handler</span>)
<span class="var">mustExtend</span>.<span class="built_in">add</span>(<span class="var">target</span>)
<mark class="md-mark md-code-mark"><span class="var">mustExtend</span>.<span class="built_in">delete</span>(<span class="var">target</span>)</mark>
<span class="cls">Object</span>.<span class="method">preventExtensions</span>(<span class="var">proxy</span>)
<span class="kw4">console.log</span>(<mark class="md-mark md-code-mark"><span class="cls">Object</span>.<span class="built_in">isExtensible</span>(<span class="var">proxy</span>)</mark>)
<span class="com">// &lt;- false</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Naturally, you could use this distinction to prevent <code class="md-code md-code-inline">proxy</code> consumers from making the proxy non-extensible in cases where that could lead to undesired behavior. In most cases, you probably won’t have to deal with this <em>trap</em>, though. That’s because you’re usually going to be working with the <em>back-end <code class="md-code md-code-inline">target</code></em> for the most part, and not so much with the <code class="md-code md-code-inline">proxy</code> object itself.</p>



<h3 id="getownpropertydescriptor"><span class="md-heading"><code class="md-code md-code-inline">getOwnPropertyDescriptor</code></span></h3>

<p>You can use the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor" aria-label="handler.getOwnPropertyDescriptor()"><code class="md-code md-code-inline">handler.getOwnPropertyDescriptor</code></a> method as a trap for <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor" aria-label="Object.getOwnPropertyDescriptor() on MDN"><code class="md-code md-code-inline">Object.getOwnPropertyDescriptor</code></a>. It may return a property descriptor, such as the result from <code class="md-code md-code-inline">Object.getOwnPropertyDescriptor(target, key)</code>; or <code class="md-code md-code-inline">undefined</code>, signaling that the property doesn’t exist. As usual, you also have the third option of throwing an exception, aborting the operation entirely.</p>

<p>If we go back to our canonical <em>“private property space”</em> example, we could implement a <em>trap</em> such as the one seen below to prevent consumers from learning about property descriptors of private properties.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">handler</span> <span class="op">=</span> {
  <mark class="md-mark md-code-mark"><span class="fn">getOwnPropertyDescriptor</span> <span class="params">(target, key)</span> {</mark>
    <span class="fn">invariant</span>(<span class="param">key</span>, <span class="str">'get property descriptor for'</span>)
    <span class="kw3">return</span> <span class="cls">Object</span>.<span class="built_in">getOwnPropertyDescriptor</span>(<span class="param">target</span>, <span class="param">key</span>)
  }
}
<span class="md-code-function"><span class="kw">function</span> <span class="fn">invariant</span> <span class="params">(key, action)</span> </span>{
  <span class="kw">if</span> (<span class="param">key</span>[<span class="num">0</span>] <span class="op">===</span> <span class="str">'_'</span>) {
    <span class="kw">throw</span> <span class="kw">new</span> <span class="md-code-error">Error</span>(<span class="str">`Invalid attempt to ${action} private "${key}" property`</span>)
  }
}
<span class="kw">var</span> <span class="var">target</span> <span class="op">=</span> {}
<span class="kw">var</span> <span class="var">proxy</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-proxy">Proxy</span>(<span class="var">target</span>, <span class="var">handler</span>)
<span class="cls">Object</span>.<span class="built_in">getOwnPropertyDescriptor</span>(<span class="var">proxy</span>, <span class="str">'_foo'</span>)
<span class="com">// &lt;- <mark class="md-mark md-code-mark">Error: Invalid attempt to get property descriptor for private "_foo" property</mark></span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The problem with that approach is that you’re effectively telling consumers that properties with the <code class="md-code md-code-inline">_</code> prefix are somehow off-limits. It might be best to conceal them entirely by returning <code class="md-code md-code-inline">undefined</code>. This way, your private properties will behave no differently than properties that are <em>actually absent</em> from the <code class="md-code md-code-inline">target</code> object.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">handler</span> <span class="op">=</span> {
  <span class="fn">getOwnPropertyDescriptor</span> <span class="params">(target, key)</span> {
    <span class="kw">if</span> (<span class="param">key</span>[<span class="num">0</span>] <span class="op">===</span> <span class="str">'_'</span>) {
      <mark class="md-mark md-code-mark"><span class="kw3">return</span></mark>
    }
    <span class="kw3">return</span> <span class="cls">Object</span>.<span class="built_in">getOwnPropertyDescriptor</span>(<span class="param">target</span>, <span class="param">key</span>)
  }
}
<span class="kw">var</span> <span class="var">target</span> <span class="op">=</span> { <mark class="md-mark md-code-mark">_foo</mark>: <span class="str">'bar'</span>, baz: <span class="str">'tar'</span> }
<span class="kw">var</span> <span class="var">proxy</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-proxy">Proxy</span>(<span class="var">target</span>, <span class="var">handler</span>)
<span class="kw4">console.log</span>(<span class="cls">Object</span>.<span class="built_in">getOwnPropertyDescriptor</span>(<span class="var">proxy</span>, <span class="str">'wat'</span>))
<span class="com">// &lt;- undefined</span>
<span class="kw4">console.log</span>(<mark class="md-mark md-code-mark"><span class="cls">Object</span>.<span class="built_in">getOwnPropertyDescriptor</span>(<span class="var">proxy</span>, <span class="str">'_foo'</span>)</mark>)
<span class="com">// &lt;- undefined</span>
<span class="kw4">console.log</span>(<span class="cls">Object</span>.<span class="built_in">getOwnPropertyDescriptor</span>(<span class="var">proxy</span>, <span class="str">'baz'</span>))
<span class="com">// &lt;- { value: 'tar', writable: true, enumerable: true, configurable: true }</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Usually when you’re trying to hide things it’s best to have them try and behave as if they fell in some other category than the category they’re actually in. Throwing, however, just sends the <em>“there’s something sketchy here, but we can’t quite tell you what that is…”</em> message — and the consumer will eventually find out why that is.</p><blockquote>

<p>Keep in mind that if debugging concerns outweight security concerns, you probably should go for the <code class="md-code md-code-inline">throw</code> statement.</p></blockquote>



<h1 id="conclusions"><span class="md-heading">Conclusions</span></h1>

<p>This has certainly been fun. I now have a much better understanding of what proxies can do for me, and I think they’ll be an instant hit once ES6 starts gaining more traction. I for one can’t be more excited about them becoming well-supported in more browsers soon. I wouldn’t hold out my hopes about proxies for Babel, as many of the traps are <strong>ridiculously hard</strong> <em>(or downright impossible)</em> to implement in ES5.</p>

<p>As we’ve learned over the last few days, there’s <strong>a myriad use cases</strong> for proxies. Off the top of my head, we can use <code class="md-code md-code-inline">Proxy</code> for all of the following.</p><ul>
  <li>Add validation rules <em>— and enforce them –</em> on plain old JavaScript objects</li>
  <li>Keep track of every interaction that goes through a proxy</li>
  <li>Decorate objects without changing them at all</li>
  <li>Make certain properties on an object completely invisible to the consumer of a proxy</li>
  <li>Revoke access <em>at will</em> when the consumer should no longer be able to use a proxy</li>
  <li>Modify the arguments passed to a proxied method</li>
  <li>Modify the result produced by a proxied method</li>
  <li>Prevent deletion of specific properties through the proxy</li>
  <li>Prevent new definitions from succeeding, according to the desired property descriptor</li>
  <li>Shuffle arguments around in a constructor</li>
  <li>Return a result other than the object being <code class="md-code md-code-inline">new</code>-ed up in a constructor</li>
  <li>Swap out the prototype of an object for something else</li></ul>

<p>I can say without a shadow of a doubt that there’s <strong>hundreds more of use cases</strong> for proxies. I’m sure many libraries will adopt a pattern we’ve discussed here in the series where a <em>“back-end”</em> <code class="md-code md-code-inline">target</code> object is created and used for storage purposes but the consumer is only provided with a <em>“front-end”</em> <code class="md-code md-code-inline">proxy</code> object with <em>limited and audited interaction</em> with the back-end.</p><blockquote>

<p>What would <em>you</em> use <code class="md-code md-code-inline">Proxy</code> for?</p></blockquote>

<p>Meet me tomorrow at… say — <em>same time?</em> We can talk about <code class="md-code md-code-inline">Reflect</code> then.</p></section></section>
</article>
</div>
<p><a href="#top" class="top"><img src="./auxi/glyphicons-214-up-arrow.png" alt="up-arrow" class="uparrow" /> <b>Back to top</b></a></p>
</section></main>


<!--  more-proxy-traps ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->
<!--  ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->









<!--  reflection ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->

<main class="ly-main"><header class="at-header">



<h1 itemprop="headline" class="dc-title" id="es6-reflection-in-depth">ES6 Reflection in Depth</h1></header>

<section class="at-teaser"><div class="at-teaser-markdown md-markdown">

<p>Oh hey — I was just casually getting ready, didn’t see you there! Welcome to another edition of ES6 — <em>“Oh. Good. We survived traps”</em> — in Depth. Never heard of it? Refer to <a href="#a-brief-history-of-es6-tooling">A Brief History of ES6 Tooling</a>. Then, make your way through <a href="#es6-destructuring-in-depth">destructuring</a>, <a href="#es6-template-strings-in-depth">template literals</a>, <a href="#es6-arrow-functions-in-depth">arrow functions</a>, the <a href="#es6-spread-and-butter-in-depth">spread operator and rest parameters</a>, improvements coming to <a href="#es6-object-literal-features-in-depth">object literals</a>, the new <a href="#es6-classes-in-depth"><em>classes</em></a> sugar on top of prototypes, <a href="#es6-let-const-and-temporal-dead-zone-in-depth"><code class="md-code md-code-inline">let</code>, <code class="md-code md-code-inline">const</code>, and the <em>“Temporal Dead Zone”</em></a>, <a href="#es6-iterators-in-depth">iterators</a>, <a href="#es6-generators-in-depth">generators</a>, <a href="#es6-symbols-in-depth">Symbols</a>, <a href="#es6-maps-in-depth">Maps</a>, <a href="#es6-weakmaps-sets-and-weaksets-in-depth">WeakMaps, Sets, and WeakSets</a>, <a href="#es6-proxies-in-depth">proxies</a>, <a href="#es6-proxy-traps-in-depth">proxy traps</a>, and <a href="#more-es6-proxy-traps-in-depth">more proxy traps</a>. We’ll be touching on the <code class="md-code md-code-inline">Reflect</code> API today.</p></div></section>

<section class="at-container de-host"><div class="de-column">

<article itemscope="itemscope" itemtype="http://schema.org/BlogPosting" class="at-article ly-section">
<meta itemprop="dateCreated" content="2015-09-08T21:08:48+00:00" />
<meta itemprop="datePublished" content="2015-09-17T13:42:01+00:00" />
<meta itemprop="dateModified" content="2015-10-11T04:06:37+00:00" />
<meta itemprop="keywords" content="es6,reflect,es6-in-depth" />

<section itemprop="articleBody" class="at-corpus">

<section itemprop="about" class="md-markdown at-introduction"><blockquote>

<p>As I did in previous articles on the series, I would love to point out that you should probably <a href="#universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That’ll make it so much easier for you to <strong>internalize the concepts</strong> discussed in the series. If you aren’t the <em>“install things on my computer”</em> kind of human, you might prefer to hop on <a href="http://codepen.io/">CodePen</a> and then click on the gear icon for JavaScript — <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em> Another alternative that’s also quite useful is to use Babel’s <a href="http://babeljs.io/repl/">online REPL</a> <em>— it’ll show you compiled ES5 code to the right of your ES6 code for quick comparison.</em></p></blockquote>

<p>Before getting into it, let me <a href="https://www.patreon.com/bevacqua"><em>shamelessly ask for your support</em></a> if you’re enjoying my ES6 in Depth series. Your contributions will go towards helping me keep up with the schedule, server bills, keeping me fed, and maintaining <strong>Pony Foo</strong> as a veritable source of JavaScript goodies.</p>

<p>Thanks for reading that, and let’s go into <code class="md-code md-code-inline">Reflect</code>. I suggest you read the articles on proxies: <a href="#es6-proxies-in-depth"><code class="md-code md-code-inline">Proxy</code> built-in</a>, <a href="#es6-proxy-traps-in-depth">traps</a>, and <a href="#more-es6-proxy-traps-in-depth">more traps</a>. These will help you wrap your head around some of the content we’ll go over today.</p></section>


<section class="md-markdown at-body">
<h1 id="why-reflection"><span class="md-heading">Why Reflection?</span></h1>

<p>Many statically typed languages have long offered a reflection API <em>(such as <a href="http://www.diveintopython.net/power_of_introspection/" aria-label="The Power of Introspection -- Dive Into Python">Python</a> or <a href="http://www.codeproject.com/Articles/17269/Reflection-in-C-Tutorial" aria-label="Reflection in C# Tutorial">C#</a>)</em>, whereas JavaScript hardly has a need for a reflection API — it <em>already being</em> a dynamic language. The introduction of ES6 features a few <strong>new extensibility points</strong> where the developer gets access to <em>previously internal aspects</em> of the language — yes, I’m talking about <a href="#es6-proxies-in-depth" aria-label="ES6 Proxies in Depth"><code class="md-code md-code-inline">Proxy</code></a>.</p>

<p>You could argue that <strong>JavaScript already has reflection features in ES5</strong>, even though they weren’t ever called that by either the specification or the community. Methods like <code class="md-code md-code-inline">Array.isArray</code>, <code class="md-code md-code-inline">Object.getOwnPropertyDescriptor</code>, and even <code class="md-code md-code-inline">Object.keys</code> are classical examples of what you’d find <strong>categorized as reflection</strong> in other languages. The <code class="md-code md-code-inline">Reflect</code> built-in is, going forward, is going to house future methods in the category. That makes a lot of sense, right? Why would you have <strong>super reflection<em>y</em> static methods</strong> like <code class="md-code md-code-inline">getOwnPropertyDescriptor</code> <em>(or even <code class="md-code md-code-inline">create</code>)</em> in <code class="md-code md-code-inline">Object</code>? After all, <code class="md-code md-code-inline">Object</code> is meant to be a base prototype, and not so much a repository of reflection methods. Having a dedicated interface that exposes most reflection methods makes more sense.</p>


<h1 id="reflect"><span class="md-heading"><code class="md-code md-code-inline">Reflect</code></span></h1>

<p>We’ve mentioned the <code class="md-code md-code-inline">Reflect</code> object in passing the past few days. Much like <code class="md-code md-code-inline">Math</code>, <code class="md-code md-code-inline">Reflect</code> is a static object you can’t <code class="md-code md-code-inline">new</code> up nor <em>call</em>, and all of its methods are static. The _traps in <a href="#es6-proxies-in-depth" aria-label="ES6 Proxies in Depth">ES6 proxies</a> <em>(covered <a href="#es6-proxy-traps-in-depth" aria-label="ES6 Proxy Traps in Depth">here</a> and <a href="#more-es6-proxy-traps-in-depth" aria-label="More ES6 Proxy Traps in Depth">here</a>)</em> are <strong>mapped one-to-one</strong> to the <code class="md-code md-code-inline">Reflect</code> API. For every <em>trap</em>, there’s a matching reflection method in <code class="md-code md-code-inline">Reflect</code>.</p>

<p>The reflection API in JavaScript has <em>a number of benefits</em> that are worth examining.</p>



<h2 id="return-values-in-reflect-vs-reflection-through-object"><span class="md-heading">Return Values in <code class="md-code md-code-inline">Reflect</code> vs Reflection Through <code class="md-code md-code-inline">Object</code></span></h2>

<p>The <code class="md-code md-code-inline">Reflect</code> equivalents to reflection methods on <code class="md-code md-code-inline">Object</code> also provide more <strong>meaningful</strong> <em>return values</em>. For instance, the <code class="md-code md-code-inline">Reflect.defineProperty</code> method returns a boolean value indicating whether the property was successfully defined. Meanwhile, its <code class="md-code md-code-inline">Object.defineProperty</code> counterpart returns the object it got as its first argument <em>— not very <strong>useful</strong>.</em></p>

<p>To illustrate, below is a code snippet showing how to verify <code class="md-code md-code-inline">Object.defineProperty</code> worked.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">try</span> {
  <span class="cls">Object</span>.<span class="built_in">defineProperty</span>(target, <span class="str">'foo'</span>, { value: <span class="str">'bar'</span> })
  <span class="com">// yay!</span>
} <span class="kw">catch</span> (e) {
  <span class="com">// oops.</span>
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>As opposed to a <em>much more natural</em> <code class="md-code md-code-inline">Reflect.defineProperty</code> experience.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">yay</span> <span class="op">=</span> <span class="cls">Reflect</span>.<span class="built_in">defineProperty</span>(target, <span class="str">'foo'</span>, { value: <span class="str">'bar'</span> })
<span class="kw">if</span> (<span class="var">yay</span>) {
  <span class="com">// yay!</span>
} <span class="kw">else</span> {
  <span class="com">// oops.</span>
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>This way we avoided a <code class="md-code md-code-inline">try</code>/<code class="md-code md-code-inline">catch</code> block and made our code a little more maintainable in the process.</p>


<h2 id="keyword-operators-as-first-class-citizens"><span class="md-heading">Keyword Operators as First Class Citizens</span></h2>

<p>Some of these reflection methods provide programmatic alternatives of doing things that were previously only possible through keywords. For example, <code class="md-code md-code-inline">Reflect.deleteProperty(target, key)</code> is equivalent to the <code class="md-code md-code-inline">delete target[key]</code> expression. Before ES6, if you wanted a method call to result in a <code class="md-code md-code-inline">delete</code> call, you’d have to create a dedicated utility method that wrapped <code class="md-code md-code-inline">delete</code> on your behalf.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">target</span> <span class="op">=</span> { foo: <span class="str">'bar'</span>, baz: <span class="str">'wat'</span> }
<span class="kw">delete</span> <span class="var">target</span>.foo
<span class="kw4">console.log</span>(<span class="var">target</span>)
<span class="com">// &lt;- { baz: 'wat' }</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Today, with ES6, you already have such a method in <code class="md-code md-code-inline">Reflect.deleteProperty</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">target</span> <span class="op">=</span> { foo: <span class="str">'bar'</span>, baz: <span class="str">'wat'</span> }
<span class="cls">Reflect</span>.<span class="built_in">deleteProperty</span>(<span class="var">target</span>, <span class="str">'foo'</span>)
<span class="kw4">console.log</span>(<span class="var">target</span>)
<span class="com">// &lt;- { baz: 'wat' }</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Just like <code class="md-code md-code-inline">deleteProperty</code>, there’s a few other methods that make it easy to do other things too.</p>



<h2 id="easier-to-mix-new-with-arbitrary-argument-lists"><span class="md-heading">Easier to mix <code class="md-code md-code-inline">new</code> with Arbitrary Argument Lists</span></h2>

<p>In ES5, this is a hard problem: How do you create a <code class="md-code md-code-inline">new Foo</code> passing an arbitrary number of arguments? You can’t do it directly, and it’s <a href="https://github.com/bevacqua/dominus/blob/master/src/apply.js#L4-L14" aria-label="Dominus on GitHub has an example where this was necessary">super verbose</a> if you need to do it anyways. You have to create an intermediary object that gets passed the arguments as an <code class="md-code md-code-inline">Array</code>. Then you have <em>that</em> object’s constructor return the result of applying the constructor of the object you originally intended to <code class="md-code md-code-inline">.apply</code>. Straightforward, right? <em>— What do you mean <strong>no</strong>?</em></p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">proto</span> <span class="op">=</span> <span class="clss">Dominus</span>.<span class="built_in">prototype</span>
<mark class="md-mark md-code-mark"><span class="fn">Applied</span>.<span class="built_in">prototype</span> <span class="op">=</span> <span class="var">proto</span></mark>
<span class="md-code-function"><span class="kw">function</span> <span class="fn">Applied</span> <span class="params">(args)</span> </span>{
  <span class="kw3">return</span> <span class="clss">Dominus</span><mark class="md-mark md-code-mark">.<span class="built_in">apply</span>(<span class="kw3">this</span>, args)</mark>
}
<span class="md-code-function"><span class="kw">function</span> <span class="fn">apply</span> <span class="params">(a)</span> </span>{
  <span class="kw3">return</span> <mark class="md-mark md-code-mark"><span class="kw">new</span></mark> <span class="clss">Applied</span>(<span class="param">a</span>)
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Using <code class="md-code md-code-inline">apply</code> is actually easy, thankfully.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="built_in">apply</span>([<span class="str">'.foo'</span>, <span class="str">'.bar'</span>])
<span class="built_in">apply.call</span>(<span class="md-code-null">null</span>, <span class="str">'.foo'</span>, <span class="str">'.bar'</span>)
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>But that was <em>insane</em>, right? <strong>Who does that?</strong> Well, in ES5, everyone who has a valid reason to do it! Luckily ES6 has less insane approaches to this problem. One of them is simply to use the <a href="http://www.diveintopython.net/power_of_introspection/" aria-label="The Power of Introspection -- Dive Into Python">spread operator</a>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">new</span> <span class="cls">Dominus</span>(<mark class="md-mark md-code-mark"><span class="op">...</span>args</mark>)
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Another alternative is to go the <code class="md-code md-code-inline">Reflect</code> route.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><mark class="md-mark md-code-mark"><span class="cls">Reflect</span>.<span class="built_in">construct</span></mark>(<span class="cls">Dominus</span>, args)
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Both of these are tremendously simpler than what I had to do in the <a href="https://github.com/bevacqua/dominus/blob/master/src/apply.js#L4-L14" aria-label="Dominus on GitHub has an example where this was necessary"><code class="md-code md-code-inline">dominus</code></a> codebase.</p>



<h2 id="function-application-the-right-way"><span class="md-heading">Function Application, The Right Way</span></h2>

<p>In ES5 if we want to call a method with an arbitrary number of arguments, we can use <code class="md-code md-code-inline">.apply</code> passing a <code class="md-code md-code-inline">this</code> context and our arguments.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">fn.<span class="built_in">apply</span>(ctx, [<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>])
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>If we fear <code class="md-code md-code-inline">fn</code> might shadow <code class="md-code md-code-inline">apply</code> with a property of their own, we can rely on a safer but way more verbose alternative.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="cls">Function</span>.<span class="built_in">prototype.apply.call</span>(fn, ctx, [<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>])
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>In ES6, you can use <a href="#es6-spread-and-butter-in-depth" aria-label="ES6 Spread and Butter in Depth">spread</a> as an alternative to <code class="md-code md-code-inline">.apply</code> for an arbitrary number of arguments.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">fn(<mark class="md-mark md-code-mark"><span class="op">...</span>[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>]</mark>)
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>That doesn’t solve your problems when you need to define a <code class="md-code md-code-inline">this</code> context, though. You could go back to the <code class="md-code md-code-inline">Function.prototype</code> way but that’s <em>way</em> too verbose. Here’s how <code class="md-code md-code-inline">Reflect</code> can help.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="cls">Reflect</span>.<span class="built_in">apply</span>(fn, ctx, args)
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Naturally, one of the most fitting use cases for <code class="md-code md-code-inline">Reflect</code> API methods is default behavior in <a href="#es6-proxies-in-depth" aria-label="ES6 Proxies in Depth"><code class="md-code md-code-inline">Proxy</code></a> <a href="#es6-proxy-traps-in-depth" aria-label="ES6 Proxy Traps in Depth">traps</a>.</p>



<h2 id="default-behavior-in-proxy-traps"><span class="md-heading">Default Behavior in <code class="md-code md-code-inline">Proxy</code> Traps</span></h2>

<p>We’ve already talked about how <em>traps</em> are mapped one-to-one to <code class="md-code md-code-inline">Reflect</code> methods. We haven’t yet touched on the fact that their interfaces match as well. That is to say, <em>both their arguments and their return values match</em>. In code, this means you could do something like this to get the default <code class="md-code md-code-inline">get</code> <em>trap</em> behavior in your <a href="#es6-proxies-in-depth" aria-label="ES6 Proxies in Depth">proxy handlers</a>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">handler</span> <span class="op">=</span> {
  <span class="built_in">get</span> () {
    <span class="kw3">return</span> <mark class="md-mark md-code-mark"><span class="cls">Reflect</span>.<span class="built_in">get</span>(<span class="op">...</span>arguments)</mark>
  }
}
<span class="kw">var</span> <span class="var">target</span> <span class="op">=</span> { a: <span class="str">'b'</span> }
<span class="kw">var</span> <span class="var">proxy</span> <span class="op">=</span> <span class="kw">new</span> <span class="md-code-proxy">Proxy</span>(<span class="var">target</span>, <span class="var">handler</span>)
<span class="kw4">console.log</span>(<span class="var">proxy</span>.a)
<span class="com">// &lt;- 'b'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>There is, in fact, nothing stopping you from making that <code class="md-code md-code-inline">handler</code> even simpler. Of course, at this point you’d be better off leaving the <em>trap</em> out entirely.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">handler</span> <span class="op">=</span> {
  get: <span class="cls">Reflect</span>.<span class="built_in">get</span>
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The important take-away here is that you could set up a trap in your proxy handlers, wire up some custom functionality that ends up throwing or logging a console statement, and then in the default case you could just use the one-liner recipe found below.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw3">return</span> <span class="cls">Reflect</span>[trapName](<span class="op">...</span>arguments)
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Certainly puts me at ease when it comes to demystifying <a href="#es6-proxies-in-depth" aria-label="ES6 Proxies in Depth"><code class="md-code md-code-inline">Proxy</code></a>.</p>



<h2 id="lastly-there-s-proto"><span class="md-heading">Lastly, There’s <code class="md-code md-code-inline">__proto__</code></span></h2>

<p>Yesterday we talked about how the <a href="#more-es6-proxy-traps-in-depth" aria-label="More ES6 Proxy Traps in Depth">legacy <code class="md-code md-code-inline">__proto__</code> is part of the ES6 specification</a> but still strongly advised against and how you should use <code class="md-code md-code-inline">Object.setPrototypeOf</code> and <code class="md-code md-code-inline">Object.getPrototypeOf</code> instead. Turns out, there’s also <code class="md-code md-code-inline">Reflect</code> counterparts to those methods you could use. Think of these methods as <em>getter and setters</em> for <code class="md-code md-code-inline">__proto__</code> but without the cross-browser discrepancies.</p><blockquote>

<p>I wouldn’t just hop onto the "<code class="md-code md-code-inline">setPrototypeOf</code> all the things" bandwagon just yet. In fact, I hope there never is a train pulling that wagon to begin with.</p></blockquote></section></section>
</article>
</div>
<p><a href="#top" class="top"><img src="./auxi/glyphicons-214-up-arrow.png" alt="up-arrow" class="uparrow" /> <b>Back to top</b></a></p>
</section></main>

<!--  reflection ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->
<!--  ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->









<!--  number ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->

<main class="ly-main"><header class="at-header">



<h1 itemprop="headline" class="dc-title" id="es6-number-improvements-in-depth">ES6 Number Improvements in Depth</h1></header>

<section class="at-teaser"><div class="at-teaser-markdown md-markdown">

<p>Hey there! Glad you’re here in time for ES6 — <em>“Back to School”</em> — in Depth. Never heard of it? Refer to <a href="#a-brief-history-of-es6-tooling">A Brief History of ES6 Tooling</a>. Then, make your way through <a href="#es6-destructuring-in-depth">destructuring</a>, <a href="#es6-template-strings-in-depth">template literals</a>, <a href="#es6-arrow-functions-in-depth">arrow functions</a>, the <a href="#es6-spread-and-butter-in-depth">spread operator and rest parameters</a>, improvements coming to <a href="#es6-object-literal-features-in-depth">object literals</a>, the new <a href="#es6-classes-in-depth"><em>classes</em></a> sugar on top of prototypes, <a href="#es6-let-const-and-temporal-dead-zone-in-depth"><code class="md-code md-code-inline">let</code>, <code class="md-code md-code-inline">const</code>, and the <em>“Temporal Dead Zone”</em></a>, <a href="#es6-iterators-in-depth">iterators</a>, <a href="#es6-generators-in-depth">generators</a>, <a href="#es6-symbols-in-depth">Symbols</a>, <a href="#es6-maps-in-depth">Maps</a>, <a href="#es6-weakmaps-sets-and-weaksets-in-depth">WeakMaps, Sets, and WeakSets</a>, <a href="#es6-proxies-in-depth">proxies</a>, <a href="#es6-proxy-traps-in-depth">proxy traps</a>, <a href="#more-es6-proxy-traps-in-depth">more proxy traps</a>, and <a href="#es6-reflection-in-depth">reflection</a>. Today we’ll learn about <code class="md-code md-code-inline">Number</code> improvements.</p></div></section>

<section class="at-container de-host"><div class="de-column">

<article itemscope="itemscope" itemtype="http://schema.org/BlogPosting" class="at-article ly-section">
<meta itemprop="dateCreated" content="2015-09-10T04:56:19+00:00" />
<meta itemprop="datePublished" content="2015-09-18T10:30:47+00:00" />
<meta itemprop="dateModified" content="2015-10-11T04:06:38+00:00" />
<meta itemprop="keywords" content="es6,number,es6-in-depth" />

<section itemprop="articleBody" class="at-corpus">

<section itemprop="about" class="md-markdown at-introduction"><blockquote>

<p>As I did in previous articles on the series, I would love to point out that you should probably <a href="#universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That’ll make it so much easier for you to <strong>internalize the concepts</strong> discussed in the series. If you aren’t the <em>“install things on my computer”</em> kind of human, you might prefer to hop on <a href="http://codepen.io/">CodePen</a> and then click on the gear icon for JavaScript — <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em> Another alternative that’s also quite useful is to use Babel’s <a href="http://babeljs.io/repl/">online REPL</a> <em>— it’ll show you compiled ES5 code to the right of your ES6 code for quick comparison.</em></p></blockquote>

<p>Before getting into it, let me <a href="https://www.patreon.com/bevacqua"><em>shamelessly ask for your support</em></a> if you’re enjoying my ES6 in Depth series. Your contributions will go towards helping me keep up with the schedule, server bills, keeping me fed, and maintaining <strong>Pony Foo</strong> as a veritable source of JavaScript goodies.</p>

<p>Thanks for reading that, and let’s go into <code class="md-code md-code-inline">Number</code> improvements. These changes don’t really depend on anything we’ve covered so far <em>— although I would strongly recommend you skim over articles in the series if you haven’t done so yet.</em> Time to dig into <code class="md-code md-code-inline">Number</code>.</p></section>

<section class="md-markdown at-body">



<h1 id="number-improvements-in-es6"><span class="md-heading"><code class="md-code md-code-inline">Number</code> Improvements in ES6</span></h1>

<p>There’s a number of changes coming to <code class="md-code md-code-inline">Number</code> in ES6 <em>— see what I did there?</em> First off, let’s raise the curtain with a summary of the features we’ll be talking about. We’ll go over all of the following changes to <code class="md-code md-code-inline">Number</code> today.</p><ul>
  <li><a href="#binary-and-octal-literals">Binary and Octal Literals</a> <em>— using <code class="md-code md-code-inline">0b</code> and <code class="md-code md-code-inline">0o</code></em></li>
  <li><a href="#numberisnan"><code class="md-code md-code-inline">Number.isNaN</code></a></li>
  <li><a href="#numberisfinite"><code class="md-code md-code-inline">Number.isFinite</code></a></li>
  <li><a href="#numberparseint"><code class="md-code md-code-inline">Number.parseInt</code></a></li>
  <li><a href="#numberparsefloat"><code class="md-code md-code-inline">Number.parseFloat</code></a></li>
  <li><a href="#numberisinteger"><code class="md-code md-code-inline">Number.isInteger</code></a></li>
  <li><a href="#numberepsilon"><code class="md-code md-code-inline">Number.EPSILON</code></a></li>
  <li><a href="#numbermax-safe-integer"><code class="md-code md-code-inline">Number.MAX_SAFE_INTEGER</code></a></li>
  <li><a href="#numbermin-safe-integer"><code class="md-code md-code-inline">Number.MIN_SAFE_INTEGER</code></a></li>
  <li><a href="#numberissafeinteger"><code class="md-code md-code-inline">Number.isSafeInteger</code></a></li></ul>

<p><img alt="The curtain is rising…" class="js-only" src="auxi/rising_curtain.jpg"></p>



<h2 id="binary-and-octal-literals"><span class="md-heading">Binary and Octal Literals</span></h2>

<p>Before ES6, your best bet when it comes to binary representation of integers was to just pass them to <code class="md-code md-code-inline">parseInt</code> with a radix of <code class="md-code md-code-inline">2</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="built_in">parseInt</span>(<span class="str">'101'</span>, <mark class="md-mark md-code-mark"><span class="num">2</span></mark>)
<span class="com">// &lt;- 5</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>In ES6 you could also use the <code class="md-code md-code-inline">0b</code> prefix to represent binary integer literals. You could also use <code class="md-code md-code-inline">0B</code> but I suggest you stick with the lower-case option.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw4">console.log</span>(<span class="num"><mark class="md-mark md-code-mark">0b</mark>001</span>)
<span class="com">// &lt;- 1</span>
<span class="kw4">console.log</span>(<span class="num">0b010</span>)
<span class="com">// &lt;- 2</span>
<span class="kw4">console.log</span>(<span class="num">0b011</span>)
<span class="com">// &lt;- 3</span>
<span class="kw4">console.log</span>(<span class="num">0b100</span>)
<span class="com">// &lt;- 4</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Same goes for octal literals. In ES3, <code class="md-code md-code-inline">parseInt</code> interpreted strings of digits starting with a <code class="md-code md-code-inline">0</code> as an octal value. That meant things got weird quickly when you forgot to specify a radix of <code class="md-code md-code-inline">10</code> <em>— and that soon became a best practice.</em></p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="built_in">parseInt</span>(<span class="str">'01'</span>)
<span class="com">// &lt;- 1</span>
<span class="built_in">parseInt</span>(<span class="str">'08'</span>)
<span class="com">// &lt;- 0</span>
<span class="built_in">parseInt</span>(<span class="str">'8'</span>)
<span class="com">// &lt;- 8</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>When ES5 came around, it got rid of the octal interpretation in <code class="md-code md-code-inline">parseInt</code> — although <strong>it’s still recommended</strong> you specify a <code class="md-code md-code-inline">radix</code> for backwards compatibility purposes. If you actually wanted octal, you could get those using a radix of <code class="md-code md-code-inline">8</code>, anyways.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="built_in">parseInt</span>(<span class="str">'100'</span>, <span class="str">'8'</span>)
<span class="com">// &lt;- 64</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>When it comes to ES6, you can now use the <code class="md-code md-code-inline">0o</code> prefix for octal literals. You could also use <code class="md-code md-code-inline">0O</code>, but that’s going to look very confusing in some typefaces, so I suggest you stick with the <code class="md-code md-code-inline">0o</code> notation.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw4">console.log</span>(<span class="num">0o010</span>)
<span class="com">// &lt;- 8</span>
<span class="kw4">console.log</span>(<span class="num">0o100</span>)
<span class="com">// &lt;- 64</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Keep in mind that octal literals aren’t actually going to crop up everywhere in your front-end applications anytime soon, so you shouldn’t worry too much about the seemingly odd choice <em>(font clarity wise)</em> of a <code class="md-code md-code-inline">0o</code> prefix. Besides, most of us use editors that have no trouble at all differentiating between <code class="md-code md-code-inline">0o</code>, <code class="md-code md-code-inline">0O</code>, <code class="md-code md-code-inline">00</code>, <code class="md-code md-code-inline">OO</code>, and <code class="md-code md-code-inline">oo</code>.</p>

<p><img alt="Those characters render just fine in Sublime Text 3" class="js-only" src="auxi/zeroes_ohs.png"></p>

<p>If you’re now perplexed and left wondering <em>“what about hexadecimal?”</em>, don’t you worry, those were already part of the language in ES5, and you can still use them. The prefix for literal <em>hexadecimal</em> notation is either <code class="md-code md-code-inline">0x</code>, or <code class="md-code md-code-inline">0X</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw4">console.log</span>(<span class="num">0x0ff</span>)
<span class="com">// &lt;- 255</span>
<span class="kw4">console.log</span>(<span class="num">0xf00</span>)
<span class="com">// &lt;- 3840</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Enough with number literals, let’s talk about something else. The first four additions to <code class="md-code md-code-inline">Numer</code> that we’ll be discussing — <code class="md-code md-code-inline">Number.isNaN</code>, <code class="md-code md-code-inline">Number.isFinite</code>, <code class="md-code md-code-inline">Number.parseInt</code>, and <code class="md-code md-code-inline">Number.parseFloat</code> — already existed in ES5, but in the global namespace. In addition, the methods in <code class="md-code md-code-inline">Number</code> are slightly different in that they don’t coerce non-numeric values into numbers before producing a result.</p>



<h2 id="numberisnan"><span class="md-heading"><code class="md-code md-code-inline">Number.isNaN</code></span></h2>

<p>This method is almost identical to ES5 global <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/isNaN" aria-label="Global isNaN() on MDN"><code class="md-code md-code-inline">isNaN</code></a> method. <code class="md-code md-code-inline">Number.isNaN</code> returns whether the provided <code class="md-code md-code-inline">value</code> equals <code class="md-code md-code-inline">NaN</code>. This is a very different question from <em>“is this not a number?”</em>.</p>

<p>The snippet shown below quickly shows that anything that’s not <code class="md-code md-code-inline">NaN</code> when passed to <code class="md-code md-code-inline">Number.isNaN</code> will return <code class="md-code md-code-inline">false</code>, while passing <code class="md-code md-code-inline">NaN</code> into it will yield <code class="md-code md-code-inline">true</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="cls">Number</span>.<span class="built_in">isNaN</span>(<span class="num">123</span>)
<span class="com">// &lt;- false, integers are not NaN</span>
<span class="cls">Number</span>.<span class="built_in">isNaN</span>(<span class="num">Infinity</span>)
<span class="com">// &lt;- false, Infinity is not NaN</span>
<span class="cls">Number</span>.<span class="built_in">isNaN</span>(<mark class="md-mark md-code-mark"><span class="str">'ponyfoo'</span></mark>)
<span class="com">// &lt;- <mark class="md-mark md-code-mark">false</mark>, 'ponyfoo' is not NaN</span>
<span class="cls">Number</span>.<span class="built_in">isNaN</span>(<mark class="md-mark md-code-mark"><span class="md-code-nan">NaN</span></mark>)
<span class="com">// &lt;- true, NaN is NaN</span>
<span class="cls">Number</span>.<span class="built_in">isNaN</span>(<mark class="md-mark md-code-mark"><span class="str">'pony'</span>/<span class="str">'foo'</span></mark>)
<span class="com">// &lt;- <mark class="md-mark md-code-mark">true</mark>, 'pony'/'foo' is NaN, NaN is NaN</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The ES5 <code class="md-code md-code-inline">global.isNaN</code> method, in contrast, casts non-numeric values passed to it <em>before evaluating them against <code class="md-code md-code-inline">NaN</code></em>. That produces significantly different results. The example below produces incosistent results because, unlike <code class="md-code md-code-inline">Number.isNaN</code>, <code class="md-code md-code-inline">isNaN</code> casts the <code class="md-code md-code-inline">value</code> passed to it through <code class="md-code md-code-inline">Number</code> first.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="built_in">isNaN</span>(<span class="str">'ponyfoo'</span>)
<span class="com">// &lt;- <mark class="md-mark md-code-mark">true</mark>, because Number('ponyfoo') is NaN</span>
<span class="built_in">isNaN</span>(<span class="kw">new</span> <span class="date">Date</span>())
<span class="com">// &lt;- true</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>While <code class="md-code md-code-inline">Number.isNaN</code> is more precise than its global <code class="md-code md-code-inline">isNaN</code> counterpart because it doesn’t incur in casting, it’s still going to confuse people <strong>because reasons.</strong></p><ol>
  <li><code class="md-code md-code-inline">global.isNaN</code> casts input through <code class="md-code md-code-inline">Number(value)</code> before comparison</li>
  <li><code class="md-code md-code-inline">Number.isNaN</code> <em>doesn’t</em></li>
  <li>Neither <code class="md-code md-code-inline">Number.isNaN</code> nor <code class="md-code md-code-inline">global.isNaN</code> answer the <em>“is this not a number?”</em> question</li>
  <li>They answer whether <code class="md-code md-code-inline">value</code> <em>— or <code class="md-code md-code-inline">Number(value)</code> –</em> is <code class="md-code md-code-inline">NaN</code></li></ol>

<p>In most cases, what you actually want is to know whether a value identifies as a number <em>— <code class="md-code md-code-inline">typeof NaN === 'number'</code> –</em> and <em>is</em> a number. The method below does just that. Note that it’d work with both <code class="md-code md-code-inline">global.isNaN</code> and <code class="md-code md-code-inline">Number.isNaN</code> due to type checking. Everything that reports a <code class="md-code md-code-inline">typeof</code> value of <code class="md-code md-code-inline">'number'</code> is a number, except <code class="md-code md-code-inline">NaN</code>, so we <em>weed those out</em> to avoid false positives!</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">isNumber</span> <span class="params">(value)</span> </span>{
  <span class="kw3">return</span> <span class="kw">typeof</span> <span class="param">value</span> <span class="op">===</span> <span class="str">'number'</span> <span class="op">&amp;&amp; !</span><span class="cls">Number</span>.<span class="built_in">isNaN</span>(<span class="param">value</span>)
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>You can use that method to figure out whether anything is <strong>an actual number</strong> or not. Here’s some examples of what constitutes actual JavaScript numbers or not.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="fn">isNumber</span>(<span class="num">1</span>)
<span class="com">// &lt;- true</span>
<span class="fn">isNumber</span>(<span class="md-code-nan">Infinity</span>)
<span class="com">// &lt;- true</span>
<span class="fn">isNumber</span>(<span class="md-code-nan">NaN</span>)
<span class="com">// &lt;- false</span>
<span class="fn">isNumber</span>(<span class="str">'ponyfoo'</span>)
<span class="com">// &lt;- false</span>
<span class="fn">isNumber</span>(<span class="kw">new</span> <span class="date">Date</span>())
<span class="com">// &lt;- false</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Speaking of <code class="md-code md-code-inline">isNumber</code>, isn’t there something like that in the language already? <em>Sort of.</em></p>



<h2 id="numberisfinite"><span class="md-heading"><code class="md-code md-code-inline">Number.isFinite</code></span></h2>

<p>The <em>rarely-advertised</em> <code class="md-code md-code-inline">isFinite</code> method has been available since ES3 and it returns whether the provided <code class="md-code md-code-inline">value</code> <strong>matches none of</strong>: <code class="md-code md-code-inline">Infinity</code>, <code class="md-code md-code-inline">-Infinity</code>, and <code class="md-code md-code-inline">NaN</code>.</p>

<p>Want to take a guess about the difference between <code class="md-code md-code-inline">global.isFinite</code> and <code class="md-code md-code-inline">Number.isFinite</code>?</p><blockquote>

<p>Correct! the <code class="md-code md-code-inline">global.isFinite</code> method coerces values through <code class="md-code md-code-inline">Number(value)</code>, while <code class="md-code md-code-inline">Number.isFinite</code> doesn’t. Here are a few examples using <code class="md-code md-code-inline">global.isFinite</code>. This means that values that can be coerced into <em>non-<code class="md-code md-code-inline">NaN</code></em> numbers will be considered finite numbers by <code class="md-code md-code-inline">global.isNumber</code> <em>— even though they’re aren’t actually numbers!</em></p></blockquote>

<p>In most cases <code class="md-code md-code-inline">isFinite</code> will be good enough, just like <code class="md-code md-code-inline">isNaN</code>, but when it comes to non-numeric values it’ll start acting up and producing unexpected results due to its <code class="md-code md-code-inline">value</code> coercion into numbers.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="built_in">isFinite</span>(<span class="md-code-nan">NaN</span>)
<span class="com">// &lt;- false</span>
<span class="built_in">isFinite</span>(<span class="num">Infinity</span>)
<span class="com">// &lt;- false</span>
<span class="built_in">isFinite</span>(<span class="op">-</span><span class="num">Infinity</span>)
<span class="com">// &lt;- false</span>
<span class="built_in">isFinite</span>(<mark class="md-mark md-code-mark"><span class="md-code-null">null</span></mark>)
<span class="com">// &lt;- <mark class="md-mark md-code-mark">true</mark>, because Number(null) is 0</span>
<span class="built_in">isFinite</span>(<span class="str">'10'</span>)
<span class="com">// &lt;- true, because Number('10') is 10</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Using <code class="md-code md-code-inline">Number.isFinite</code> is just an all-around safer bet as it doesn’t incur in unwanted casting. You could always do <code class="md-code md-code-inline">Number.isFinite(Number(value))</code> if you did want the <code class="md-code md-code-inline">value</code> to be casted into its numeric representation.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="cls">Number</span>.<span class="built_in">isFinite</span>(<span class="md-code-nan">NaN</span>)
<span class="com">// &lt;- false</span>
<span class="cls">Number</span>.<span class="built_in">isFinite</span>(<span class="num">Infinity</span>)
<span class="com">// &lt;- false</span>
<span class="cls">Number</span>.<span class="built_in">isFinite</span>(<span class="op">-</span><span class="num">Infinity</span>)
<span class="com">// &lt;- false</span>
<span class="cls">Number</span>.<span class="built_in">isFinite</span>(<mark class="md-mark md-code-mark"><span class="md-code-null">null</span></mark>)
<span class="com">// &lt;- <mark class="md-mark md-code-mark">false</mark></span>
<span class="cls">Number</span>.<span class="built_in">isFinite</span>(<span class="num">0</span>)
<span class="com">// &lt;- true</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Once again, the discrepancy doesn’t do any good to the language, but <code class="md-code md-code-inline">Number.isFinite</code> is consistently more useful than <code class="md-code md-code-inline">isFinite</code>. Creating a polyfill for the <code class="md-code md-code-inline">Number.isFinite</code> version is mostly a matter of type-checking.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="cls">Number</span>.<span class="built_in">isFinite</span> <span class="op">=</span> <span class="md-code-function"><span class="kw">function</span> <span class="params">(value)</span> </span>{
  <span class="kw3">return</span> <span class="kw">typeof</span> <span class="param">value</span> <span class="op">===</span> <span class="str">'number'</span> <span class="op">&amp;&amp;</span> <span class="built_in">isFinite</span>(<span class="param">value</span>)
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->



<h2 id="numberparseint"><span class="md-heading"><code class="md-code md-code-inline">Number.parseInt</code></span></h2>

<p>This method works the same as <code class="md-code md-code-inline">parseInt</code>. In fact, it is the same.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw4">console.log</span>(<span class="cls">Number</span>.<span class="built_in">parseInt</span> <span class="op">===</span> <span class="built_in">parseInt</span>)
<span class="com">// &lt;- true</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The <code class="md-code md-code-inline">parseInt</code> method keeps producing inconsistencies, though — even if it didn’t even change, <strong>that’s the problem</strong>. Before ES6, <code class="md-code md-code-inline">parseInt</code> had support for hexadecimal literal notation in strings. Specifying the <code class="md-code md-code-inline">radix</code> is not even necessary, <code class="md-code md-code-inline">parseInt</code> infers that based on the <code class="md-code md-code-inline">0x</code> prefix.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="built_in">parseInt</span>(<span class="str">'0xf00'</span>)
<span class="com">// &lt;- 3840</span>
<span class="built_in">parseInt</span>(<span class="str">'0xf00'</span>, <mark class="md-mark md-code-mark"><span class="num">16</span></mark>)
<span class="com">// &lt;- 3840</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>If you hardcoded another <code class="md-code md-code-inline">radix</code>, <em>— and this is <strong>yet another reason</strong> for doing so –</em> <code class="md-code md-code-inline">parseInt</code> would bail after the first non-digit character.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="built_in">parseInt</span>(<span class="str">'0xf00'</span>, <mark class="md-mark md-code-mark"><span class="num">10</span></mark>)
<span class="com">// &lt;- 0</span>
<span class="built_in">parseInt</span>(<span class="str">'5xf00'</span>, <span class="num">10</span>)
<span class="com">// &lt;- <mark class="md-mark md-code-mark">5</mark>, illustrating there's no special treatment here</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>So far, it’s all good. Why wouldn’t I want <code class="md-code md-code-inline">parseInt</code> to drop <code class="md-code md-code-inline">0x</code> from hexadecimal strings? It sounds good, although you may argue that <strong>that’s doing too much</strong>, and you’d be <em>probably right</em>.</p>

<p>The aggravating issue, however, is that <code class="md-code md-code-inline">parseInt</code> hasn’t changed at all. Therefore, binary and octal literal notation in strings won’t work.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="built_in">parseInt</span>(<span class="str">'0b011'</span>)
<span class="com">// &lt;- 0</span>
<span class="built_in">parseInt</span>(<span class="str">'0b011'</span>, <span class="num">2</span>)
<span class="com">// &lt;- 0</span>
<span class="built_in">parseInt</span>(<span class="str">'0o800'</span>)
<span class="com">// &lt;- 0</span>
<span class="built_in">parseInt</span>(<span class="str">'0o800'</span>, <span class="num">8</span>)
<span class="com">// &lt;- 0</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>It’ll be up to you to get rid of the prefix before <code class="md-code md-code-inline">parseInt</code>. Remember to <em>hard-code</em> the <code class="md-code md-code-inline">radix</code>, though!</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="built_in">parseInt</span>(<span class="str">'0b011'</span><mark class="md-mark md-code-mark">.<span class="built_in">slice</span>(<span class="num">2</span>)</mark>, <span class="num">2</span>)
<span class="com">// &lt;- 3</span>
<span class="built_in">parseInt</span>(<span class="str">'0o110'</span><mark class="md-mark md-code-mark">.<span class="built_in">slice</span>(<span class="num">2</span>)</mark>, <span class="num">8</span>)
<span class="com">// &lt;- 72</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>What’s <em>even weirder</em> is that the <code class="md-code md-code-inline">Number</code> method is <strong>perfectly able to cast</strong> these strings into the correct numbers.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="cls">Number</span>(<span class="str">'0b011'</span>)
<span class="com">// &lt;- 3</span>
<span class="cls">Number</span>(<span class="str">'0o110'</span>)
<span class="com">// &lt;- 72</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>I’m not sure what drove them to keep <code class="md-code md-code-inline">Number.parseInt</code> identical to <code class="md-code md-code-inline">parseInt</code>. If it were up to me, I would’ve made it different so that it worked just like <code class="md-code md-code-inline">Number</code> — which <em>is</em> able to <strong>coerce octal and binary</strong> number literal strings into the appropriate <em>base ten</em> numbers.</p>

<p>It might be that this was a more involved <em>“fork”</em> of <code class="md-code md-code-inline">parseInt</code> than just <em>“not coercing <code class="md-code md-code-inline">input</code> into a numeric representation”</em> as we observed in <code class="md-code md-code-inline">Number.isNaN</code> and <code class="md-code md-code-inline">Number.isFinite</code>, but I’m just guessing here.</p>



<h2 id="numberparsefloat"><span class="md-heading"><code class="md-code md-code-inline">Number.parseFloat</code></span></h2>

<p>Just like <code class="md-code md-code-inline">parseInt</code>, <code class="md-code md-code-inline">parseFloat</code> was just added to <code class="md-code md-code-inline">Number</code> without any modifications whatsoever.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="cls">Number</span>.<span class="built_in">parseFloat</span> <span class="op">===</span> <span class="built_in">parseFloat</span>
<span class="com">// &lt;- true</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>In this case, however, <code class="md-code md-code-inline">parseFloat</code> already didn’t have any special behavior with regard to hexadecimal literal strings, meaning that this is in fact the only method that won’t introduce any confusion, other than it being ported over to <code class="md-code md-code-inline">Number</code> for <em>completeness’ sake</em>.</p>



<h2 id="numberisinteger"><span class="md-heading"><code class="md-code md-code-inline">Number.isInteger</code></span></h2>

<p>This is a new method coming in ES6. It returns <code class="md-code md-code-inline">true</code> if the provided <code class="md-code md-code-inline">value</code> is <strong>a finite number</strong> that <em>doesn’t have a decimal part</em>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw4">console.log</span>(<span class="cls">Number</span>.<span class="built_in">isInteger</span>(<span class="num">Infinity</span>))
<span class="com">// &lt;- false</span>
<span class="kw4">console.log</span>(<span class="cls">Number</span>.<span class="built_in">isInteger</span>(-<span class="num">Infinity</span>))
<span class="com">// &lt;- false</span>
<span class="kw4">console.log</span>(<span class="cls">Number</span>.<span class="built_in">isInteger</span>(<span class="md-code-nan">NaN</span>))
<span class="com">// &lt;- false</span>
<span class="kw4">console.log</span>(<span class="cls">Number</span>.<span class="built_in">isInteger</span>(<span class="md-code-null">null</span>))
<span class="com">// &lt;- false</span>
<span class="kw4">console.log</span>(<span class="cls">Number</span>.<span class="built_in">isInteger</span>(<span class="num">0</span>))
<span class="com">// &lt;- true</span>
<span class="kw4">console.log</span>(<span class="cls">Number</span>.<span class="built_in">isInteger</span>(-<span class="num">10</span>))
<span class="com">// &lt;- true</span>
<span class="kw4">console.log</span>(<span class="cls">Number</span>.<span class="built_in">isInteger</span>(<span class="num">10.3</span>))
<span class="com">// &lt;- false</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>If you want to look at a a polyfill for <code class="md-code md-code-inline">isInteger</code>, you might want to consider the following code snippet. The modulus operator returns the remainder of dividing the same operands <em>— effectively: the decimal part.</em> If that’s <code class="md-code md-code-inline">0</code>, that means the number is an integer.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="cls">Number</span>.<span class="built_in">isInteger</span> <span class="op">=</span> <span class="md-code-function"><span class="kw">function</span> <span class="params">(value)</span> </span>{
  <span class="kw3">return</span> <mark class="md-mark md-code-mark"><span class="cls">Number</span>.<span class="built_in">isFinite</span>(<span class="param">value</span>)</mark> <span class="op">&amp;&amp;</span> <mark class="md-mark md-code-mark"><span class="param">value</span> <span class="op">%</span> <span class="num">1</span></mark> <span class="op">===</span> <span class="num">0</span>
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Floating point arithmetic is well-documented as being kind of ridiculous. What is this <code class="md-code md-code-inline">Number.EPSILON</code> thing?</p>



<h2 id="numberepsilon"><span class="md-heading"><code class="md-code md-code-inline">Number.EPSILON</code></span></h2>

<p>Let me answer that question with a piece of code.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="cls">Number</span>.<span class="built_in">EPSILON</span>
<span class="com">// &lt;- <mark class="md-mark md-code-mark">2.220446049250313e-16</mark>, wait what?</span>
<span class="cls">Number</span>.<span class="built_in">EPSILON</span>.<span class="built_in">toFixed</span>(<span class="num">20</span>)
<span class="com">// &lt;- <mark class="md-mark md-code-mark">'0.00000000000000022204'</mark>, got it</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Ok, so <code class="md-code md-code-inline">Number.EPSILON</code> is <strong>a terribly small number</strong>. What good is it for? Remember that thing about how floating point sum makes no sense? Here’s the canonical example, I’m sure you remember it — <em>Yeah, I know.</em></p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="num">0.1</span> <span class="op">+</span> <span class="num">0.2</span>
<span class="com">// &lt;- <mark class="md-mark md-code-mark">0.30000000000000004</mark></span>
<span class="num">0.1</span> <span class="op">+</span> <span class="num">0.2</span> <span class="op">===</span> <span class="num">0.3</span>
<span class="com">// &lt;- <mark class="md-mark md-code-mark">false</mark></span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Let’s try that one more time.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="num">0.1</span> <span class="op">+</span> <span class="num">0.2</span> - <span class="num">0.3</span>
<span class="com">// &lt;- <mark class="md-mark md-code-mark">5.551115123125783e-17</mark>, what the hell?</span>
<span class="num">5.551115123125783e-17</span>.<span class="built_in">toFixed</span>(<span class="num">20</span>)
<span class="com">// &lt;- <mark class="md-mark md-code-mark">'0.00000000000000005551'</mark>, got it</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p><em>So what?</em> You can use <code class="md-code md-code-inline">Number.EPSILON</code> to figure out whether the difference is small enough to fall under the <em>“floating point arithmetic is ridiculous and the difference is negligible”</em> category.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="num">5.551115123125783e-17</span> &lt; <span class="cls">Number</span>.<span class="built_in">EPSILON</span>
<span class="com">// &lt;- <mark class="md-mark md-code-mark">true</mark></span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Can we trust that? Well, <code class="md-code md-code-inline">0.00000000000000005551</code> is indeed smaller than <code class="md-code md-code-inline">0.00000000000000022204</code>. What do you mean you don’t trust me? Here they are side by side.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="num">0.00000000000000005551</span>
<span class="num">0.00000000000000022204</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>See? <code class="md-code md-code-inline">Number.EPSILON</code> is <em>larger</em> than the difference. We can use <code class="md-code md-code-inline">Number.EPSILON</code> as an acceptable margin of error due to floating point arithmetic rounding operations.</p>

<p>Thus, the following piece of code figures out whether the result of a floating point operation is within the expected margin of error. We use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/abs" aria-label="Math.abs() on MDN"><code class="md-code md-code-inline">Math.abs</code></a> because that way the order of <code class="md-code md-code-inline">left</code> and <code class="md-code md-code-inline">right</code> won’t matter. In other words, <code class="md-code md-code-inline">withinErrorMargin(left, right)</code> will produce the same result as <code class="md-code md-code-inline">withinErrorMargin(right, left)</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">withinErrorMargin</span> <span class="params">(left, right)</span> </span>{
  <span class="kw3">return</span> <mark class="md-mark md-code-mark"><span class="cls">Math</span>.<span class="built_in">abs</span>(<span class="param">left</span> <span class="op">-</span> <span class="param">right</span>)</mark> &lt; <span class="cls">Number</span>.<span class="built_in">EPSILON</span>
}
<span class="fn">withinErrorMargin</span>(<span class="num">0.1</span> <span class="op">+</span> <span class="num">0.2</span>, <span class="num">0.3</span>)
<span class="com">// &lt;- true</span>
<span class="fn">withinErrorMargin</span>(<span class="num">0.2</span> <span class="op">+</span> <span class="num">0.2</span>, <span class="num">0.3</span>)
<span class="com">// &lt;- false</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->
<blockquote>

<p>While, yes, you <strong>could</strong> do this, it’s probably unnecessarily complicated unless you have to deal with very low-level mathematics. You’ll be better of pulling a library like <a href="https://github.com/josdejong/mathjs" aria-label="josdejong/mathjs on GitHub"><code class="md-code md-code-inline">mathjs</code></a> into your project.</p></blockquote>

<p>Last but not least, there’s the other weird aspect of number representation in JavaScript. <strong>Not every integer</strong> can be represented <em>precisely</em>, either.</p>



<h2 id="numbermax-safe-integer"><span class="md-heading"><code class="md-code md-code-inline">Number.MAX_SAFE_INTEGER</code></span></h2>

<p>This is the largest integer that can be safely and precisely represented in JavaScript, or any language that represents integers using <em>floating point</em> as specified by <a href="https://en.wikipedia.org/wiki/IEEE_floating_point" aria-label="IEEE Floating Point Standard on Wikipedia">IEEE-754</a> for that matter. The code below show just how large that number is. If we need to be able to deal with numbers larger than that, then I would once again point you to <a href="https://github.com/josdejong/mathjs" aria-label="josdejong/mathjs on GitHub"><code class="md-code md-code-inline">mathjs</code></a>, or maybe <strong>try another language</strong> for your computationally intensive services.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="cls">Number</span>.<span class="built_in">MAX_SAFE_INTEGER</span> <span class="op">===</span> <span class="cls">Math</span>.<span class="built_in">pow</span>(<span class="num">2</span>, <span class="num">53</span>) - <span class="num">1</span>
<span class="com">// &lt;- true</span>
<span class="cls">Number</span>.<span class="built_in">MAX_SAFE_INTEGER</span> <span class="op">===</span> <span class="num">9007199254740991</span>
<span class="com">// &lt;- true</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>And you know what they say — <em>If there’s a maximum…</em></p>



<h2 id="numbermin-safe-integer"><span class="md-heading"><code class="md-code md-code-inline">Number.MIN_SAFE_INTEGER</code></span></h2>

<p>Right, nobody says that. However, there’s a <code class="md-code md-code-inline">Number.MIN_SAFE_INTEGER</code> regardless, and it’s the negative value of <code class="md-code md-code-inline">Number.MAX_SAFE_INTEGER</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="cls">Number</span>.<span class="built_in">MIN_SAFE_INTEGER</span> <span class="op">===</span> -<span class="cls">Number</span>.<span class="built_in">MAX_SAFE_INTEGER</span>
<span class="com">// &lt;- true</span>
<span class="cls">Number</span>.<span class="built_in">MIN_SAFE_INTEGER</span> <span class="op">===</span> -<span class="num">9007199254740991</span>
<span class="com">// &lt;- true</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>How exactly can you leverage these two constants, I hear you say? In the case of the overflow problem, you don’t have to implement your own <code class="md-code md-code-inline">withinErrorMargin</code> method like you had to do for floating point precision. Instead, a <code class="md-code md-code-inline">Number.isSafeInteger</code> is provided to you.</p>



<h2 id="numberissafeinteger"><span class="md-heading"><code class="md-code md-code-inline">Number.isSafeInteger</code></span></h2>

<p>This method returns <code class="md-code md-code-inline">true</code> for any integer in the <code class="md-code md-code-inline">[MIN_SAFE_INTEGER, MAX_SAFE_INTEGER]</code> range. There’s no type coercion here either. The input must be numeric, an integer, and within the aforementioned bounds in order for the method to return <code class="md-code md-code-inline">true</code>. Here’s a quite comprehensive set of examples for you to stare at.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="cls">Number</span>.<span class="built_in">isSafeInteger</span>(<span class="str">'a'</span>)
<span class="com">// &lt;- false</span>
<span class="cls">Number</span>.<span class="built_in">isSafeInteger</span>(<span class="md-code-null">null</span>)
<span class="com">// &lt;- false</span>
<span class="cls">Number</span>.<span class="built_in">isSafeInteger</span>(<span class="md-code-nan">NaN</span>)
<span class="com">// &lt;- false</span>
<span class="cls">Number</span>.<span class="built_in">isSafeInteger</span>(<span class="num">Infinity</span>)
<span class="com">// &lt;- false</span>
<span class="cls">Number</span>.<span class="built_in">isSafeInteger</span>(<span class="op">-</span><span class="num">Infinity</span>)
<span class="com">// &lt;- false</span>
<span class="cls">Number</span>.<span class="built_in">isSafeInteger</span>(<span class="cls">Number</span>.<span class="built_in">MIN_SAFE_INTEGER</span> <span class="op">-</span> <span class="num">1</span>)
<span class="com">// &lt;- <mark class="md-mark md-code-mark">false</mark></span>
<span class="cls">Number</span>.<span class="built_in">isSafeInteger</span>(<span class="cls">Number</span>.<span class="built_in">MIN_SAFE_INTEGER</span>)
<span class="com">// &lt;- <mark class="md-mark md-code-mark">true</mark></span>
<span class="cls">Number</span>.<span class="built_in">isSafeInteger</span>(<span class="num">1</span>)
<span class="com">// &lt;- true</span>
<span class="cls">Number</span>.<span class="built_in">isSafeInteger</span>(<span class="num">1.2</span>)
<span class="com">// &lt;- false</span>
<span class="cls">Number</span>.<span class="built_in">isSafeInteger</span>(<span class="cls">Number</span>.<span class="built_in">MAX_SAFE_INTEGER</span>)
<span class="com">// &lt;- <mark class="md-mark md-code-mark">true</mark></span>
<span class="cls">Number</span>.<span class="built_in">isSafeInteger</span>(<span class="cls">Number</span>.<span class="built_in">MAX_SAFE_INTEGER</span> <span class="op">+</span> <span class="num">1</span>)
<span class="com">// &lt;- <mark class="md-mark md-code-mark">false</mark></span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>As <a href="http://www.2ality.com/2015/04/numbers-math-es6.html" aria-label="New number and Math features in ES6 — 2ality.com">Dr. Axel Rauschmayer points out</a> in his article about ES6 numbers, when we want to verify if the result of an operation is within bounds, we must verify not only the result but also both operands. The reason for that is one <em>(or both)</em> of the operands may be out of bounds, while the result is <em>“safe”</em> <strong>(but incorrect)</strong>. Similarly, the result may be out of bounds itself, so checking all of <code class="md-code md-code-inline">left</code>, <code class="md-code md-code-inline">right</code>, and the result of <code class="md-code md-code-inline">left op right</code> is necessary to verify that we can indeed trust the result.</p>

<p>In all of the examples below, <strong>the result is incorrect</strong>. Here’s the first example, where both operands are safe even though the result is not.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="cls">Number</span>.<span class="built_in">isSafeInteger</span>(<span class="num">9007199254740000</span>)
<span class="com">// &lt;- true</span>
<span class="cls">Number</span>.<span class="built_in">isSafeInteger</span>(<span class="num">993</span>)
<span class="com">// &lt;- true</span>
<span class="cls">Number</span>.<span class="built_in">isSafeInteger</span>(<span class="num">9007199254740000</span> <span class="op">+</span> <span class="num">993</span>)
<span class="com">// &lt;- false</span>
<span class="num">9007199254740000</span> <span class="op">+</span> <span class="num">993</span>
<span class="com">// &lt;- <mark class="md-mark md-code-mark">9007199254740992</mark>, should be 9007199254740993</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>In this example one of the operands wasn’t within range, so we can’t trust the result to be accurate.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="cls">Number</span>.<span class="built_in">isSafeInteger</span>(<span class="num">9007199254740993</span>)
<span class="com">// &lt;- false</span>
<span class="cls">Number</span>.<span class="built_in">isSafeInteger</span>(<span class="num">990</span>)
<span class="com">// &lt;- true</span>
<span class="cls">Number</span>.<span class="built_in">isSafeInteger</span>(<span class="num">9007199254740993</span> <span class="op">+</span> <span class="num">990</span>)
<span class="com">// &lt;- false</span>
<span class="num">9007199254740993</span> <span class="op">+</span> <span class="num">990</span>
<span class="com">// &lt;-  <mark class="md-mark md-code-mark">9007199254741982</mark>, should be 9007199254741983</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Note that in the example above, a subtraction would produce a result within bounds, and that result would <em>also</em> be inaccurate.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="cls">Number</span>.<span class="built_in">isSafeInteger</span>(<span class="num">9007199254740993</span>)
<span class="com">// &lt;- false</span>
<span class="cls">Number</span>.<span class="built_in">isSafeInteger</span>(<span class="num">990</span>)
<span class="com">// &lt;- true</span>
<span class="cls">Number</span>.<span class="built_in">isSafeInteger</span>(<span class="num">9007199254740993</span> <span class="op">-</span> <span class="num">990</span>)
<span class="com">// &lt;- true</span>
<span class="num">9007199254740993</span> <span class="op">-</span> <span class="num">990</span>
<span class="com">// &lt;-  <mark class="md-mark md-code-mark">9007199254740002</mark>, should be 9007199254740003</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>It doesn’t take a genius to figure out the case where both operands are out of bounds but the result is <em>deemed “safe”</em>, even though the result is incorrect.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="cls">Number</span>.<span class="built_in">isSafeInteger</span>(<span class="num">9007199254740993</span>)
<span class="com">// &lt;- false</span>
<span class="cls">Number</span>.<span class="built_in">isSafeInteger</span>(<span class="num">9007199254740995</span>)
<span class="com">// &lt;- false</span>
<span class="cls">Number</span>.<span class="built_in">isSafeInteger</span>(<span class="num">9007199254740993</span> <span class="op">-</span> <span class="num">9007199254740995</span>)
<span class="com">// &lt;- true</span>
<span class="num">9007199254740993</span> <span class="op">-</span> <span class="num">9007199254740995</span>
<span class="com">// &lt;- <mark class="md-mark md-code-mark">-4</mark>, should be -2</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Thus, as you can see, we can conclude that the only safe way to assert whether an operation is correct is with a method like the one below. If we can’t ascertain that the operation and both its operands are within bounds, then the result may be inaccurate, and that’s a problem. It’s best to <code class="md-code md-code-inline">throw</code> in those situations and have a way to error-correct, but that’s specific to your programs. The important part is to actually catch these kinds of difficult bugs to deal with.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">trusty</span> <span class="params">(left, right, result)</span> </span>{
  <span class="kw">if</span> (
    <span class="cls">Number</span>.<span class="built_in">isSafeInteger</span>(<span class="param">left</span>) <span class="op">&amp;&amp;</span>
    <span class="cls">Number</span>.<span class="built_in">isSafeInteger</span>(<span class="param">right</span>) <span class="op">&amp;&amp;</span>
    <span class="cls">Number</span>.<span class="built_in">isSafeInteger</span>(<span class="param">result</span>)
  ) {
    <span class="kw3">return</span> <span class="param">result</span>
  }
  <span class="kw">throw</span> <span class="kw">new</span> <span class="built_in">RangeError</span>(<span class="str">'Operation cannot be trusted!'</span>)
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>You could then use that every step of the way to ensure all operands remain safely within bounds. I’ve highlighted the unsafe values in the examples below. Note that even though none of the operations in my examples return accurate results, certain operations and numbers <em>may do so</em> even when operands are out of bounds. The problem is that that <strong>can’t be guaranteed</strong> <em>— therefore the operation can’t be trusted.</em></p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="fn">trusty</span>(<span class="num">9007199254740000</span>, <span class="num">993</span>, <mark class="md-mark md-code-mark"><span class="num">9007199254740000</span> <span class="op">+</span> <span class="num">993</span></mark>)
<span class="com">// &lt;- RangeError: Operation cannot be trusted!</span>
<span class="fn">trusty</span>(<mark class="md-mark md-code-mark"><span class="num">9007199254740993</span></mark>, <span class="num">990</span>, <mark class="md-mark md-code-mark"><span class="num">9007199254740993</span> <span class="op">+</span> <span class="num">990</span></mark>)
<span class="com">// &lt;- RangeError: Operation cannot be trusted!</span>
<span class="fn">trusty</span>(<mark class="md-mark md-code-mark"><span class="num">9007199254740993</span></mark>, <span class="num">990</span>, <span class="num">9007199254740993</span> <span class="op">-</span> <span class="num">990</span>)
<span class="com">// &lt;- RangeError: Operation cannot be trusted!</span>
<span class="fn">trusty</span>(<mark class="md-mark md-code-mark"><span class="num">9007199254740993</span></mark>, <mark class="md-mark md-code-mark"><span class="num">9007199254740995</span></mark>, <span class="num">9007199254740993</span> <span class="op">-</span> <span class="num">9007199254740995</span>)
<span class="com">// &lt;- RangeError: Operation cannot be trusted!</span>
<span class="fn">trusty</span>(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>)
<span class="com">// &lt;- 3</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>I don’t think I want to write about floating point again for a while. <em>Time to scrub myself up.</em></p>



<h1 id="conclusions"><span class="md-heading">Conclusions</span></h1>

<p>While some of the hacks to guard against rounding errors and overflow safety are <em>nice to have</em>, they don’t attack the heart of the problem: <em>math with the <a href="https://en.wikipedia.org/wiki/IEEE_floating_point" aria-label="IEEE Floating Point Standard on Wikipedia">IEEE-754</a> standard is hard.</em></p>

<p>These days JavaScript runs on all the things, so it’d be nice if a better standard were to be <em>implemented alongside <a href="https://en.wikipedia.org/wiki/IEEE_floating_point" aria-label="IEEE Floating Point Standard on Wikipedia">IEEE-754</a></em>. Roughly a year ago, <em>Douglas Crockford</em> came up with <a href="http://dec64.com/" aria-label="DEC64 number type">DEC64</a>, but opinions on its merits range from <em>“this is genius!”</em> to <em>“this is the work of a madman”</em> — I guess that’s the norm when it comes to most of the stuff Crockford publishes, though.</p>

<p>It’d be nice, to eventually see the day where JavaScript is able to <em>precisely</em> compute decimal arithmetic as well as able to represent large integers safely. That day we’ll probably have something <strong>alongside</strong> <em>floating point</em>.</p></section></section>
</article>
</div>
<p><a href="#top" class="top"><img src="./auxi/glyphicons-214-up-arrow.png" alt="up-arrow" class="uparrow" /> <b>Back to top</b></a></p>
</section></main>

<!--  number ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->
<!--  ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->









<!--  math ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->

<main class="ly-main"><header class="at-header">



<h1 itemprop="headline" class="dc-title" id="es6-math-additions-in-depth">ES6 Math Additions in Depth</h1></header>

<section class="at-teaser"><div class="at-teaser-markdown md-markdown">

<p>You’ve made it! Here’s another article in the ES6 — <em>“What? I’d rather develop for IE6”</em> — in Depth series. If you’ve never been around here before, start with <a href="#a-brief-history-of-es6-tooling">A Brief History of ES6 Tooling</a>. Then, make your way through <a href="#es6-destructuring-in-depth">destructuring</a>, <a href="#es6-template-strings-in-depth">template literals</a>, <a href="#es6-arrow-functions-in-depth">arrow functions</a>, the <a href="#es6-spread-and-butter-in-depth">spread operator and rest parameters</a>, improvements coming to <a href="#es6-object-literal-features-in-depth">object literals</a>, the new <a href="#es6-classes-in-depth"><em>classes</em></a> sugar on top of prototypes, <a href="#es6-let-const-and-temporal-dead-zone-in-depth"><code class="md-code md-code-inline">let</code>, <code class="md-code md-code-inline">const</code>, and the <em>“Temporal Dead Zone”</em></a>, <a href="#es6-iterators-in-depth">iterators</a>, <a href="#es6-generators-in-depth">generators</a>, <a href="#es6-symbols-in-depth">Symbols</a>, <a href="#es6-maps-in-depth">Maps</a>, <a href="#es6-weakmaps-sets-and-weaksets-in-depth">WeakMaps, Sets, and WeakSets</a>, <a href="#es6-proxies-in-depth">proxies</a>, <a href="#es6-proxy-traps-in-depth">proxy traps</a>, <a href="#more-es6-proxy-traps-in-depth">more proxy traps</a>, <a href="#es6-reflection-in-depth">reflection</a>, and <a href="#es6-number-improvements-in-depth"><code class="md-code md-code-inline">Number</code></a>. Today we’ll learn about new <code class="md-code md-code-inline">Math</code> methods.</p></div></section>

<section class="at-container de-host"><div class="de-column">

<article itemscope="itemscope" itemtype="http://schema.org/BlogPosting" class="at-article ly-section">
<meta itemprop="dateCreated" content="2015-09-11T08:13:24+00:00" />
<meta itemprop="datePublished" content="2015-09-21T11:29:11+00:00" />
<meta itemprop="dateModified" content="2015-10-11T04:06:38+00:00" />
<meta itemprop="keywords" content="es6,math,es6-in-depth" />

<section itemprop="articleBody" class="at-corpus">

<section itemprop="about" class="md-markdown at-introduction"><blockquote>

<p>As I did in previous articles on the series, I would love to point out that you should probably <a href="#universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That’ll make it so much easier for you to <strong>internalize the concepts</strong> discussed in the series. If you aren’t the <em>“install things on my computer”</em> kind of human, you might prefer to hop on <a href="http://codepen.io/">CodePen</a> and then click on the gear icon for JavaScript — <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em> Another alternative that’s also quite useful is to use Babel’s <a href="http://babeljs.io/repl/">online REPL</a> <em>— it’ll show you compiled ES5 code to the right of your ES6 code for quick comparison.</em></p></blockquote>

<p>Before getting into it, let me <a href="https://www.patreon.com/bevacqua"><em>shamelessly ask for your support</em></a> if you’re enjoying my ES6 in Depth series. Your contributions will go towards helping me keep up with the schedule, server bills, keeping me fed, and maintaining <strong>Pony Foo</strong> as a veritable source of JavaScript goodies.</p>

<p>Thanks for reading that, and let’s go into <code class="md-code md-code-inline">Math</code> improvements. For a bit of context you may want to look at the <a href="#es6-number-improvements-in-depth">extensive article on <code class="md-code md-code-inline">Number</code> improvements</a> from last week. Time to dig into <code class="md-code md-code-inline">Math</code>.</p></section>

<section class="md-markdown at-body">



<h1 id="math-additions-in-es6"><span class="md-heading"><code class="md-code md-code-inline">Math</code> Additions in ES6</span></h1>

<p>There’s <em>heaps</em> of additions to <code class="md-code md-code-inline">Math</code> in ES6. Just like you’re used to, these are <strong>static</strong> methods on the <code class="md-code md-code-inline">Math</code> built-in. Some of these methods were specifically engineered towards making it easier to compile C into JavaScript, and you may never come across a need for them in day-to-day development — particularly not when it comes to front-end development. Other methods are complements to the existing rounding, exponentiation, and trigonometry API surface.</p>

<p>Below is a full list of methods added to <code class="md-code md-code-inline">Math</code>. They are grouped by functionality and sorted by relevance.</p><ul>
  <li><strong>Utility</strong><ul>
  <li><a href="#mathsign"><code class="md-code md-code-inline">Math.sign</code></a> — sign function of a number</li>
  <li><a href="#mathtrunc"><code class="md-code md-code-inline">Math.trunc</code></a> — integer part of a number</li></ul></li>
  <li><strong>Exponentiation and Logarithmic</strong><ul>
  <li><a href="#mathcbrt"><code class="md-code md-code-inline">Math.cbrt</code></a> — cubic root of value, or <code class="md-code md-code-inline">∛‾value</code></li>
  <li><a href="#mathexpm1"><code class="md-code md-code-inline">Math.expm1</code></a> — <code class="md-code md-code-inline">e</code> to the <code class="md-code md-code-inline">value</code> minus <code class="md-code md-code-inline">1</code>, or <code class="md-code md-code-inline">e<sup>value</sup> - 1</code></li>
  <li><a href="#mathlog1p"><code class="md-code md-code-inline">Math.log1p</code></a> — natural logarithm of <code class="md-code md-code-inline">value + 1</code>, or <code class="md-code md-code-inline"><em>ln</em>(value + 1)</code></li>
  <li><a href="#mathlog10"><code class="md-code md-code-inline">Math.log10</code></a> — base 10 logarithm of <code class="md-code md-code-inline">value</code>, or <code class="md-code md-code-inline"><em>log</em><sub>10</sub>(value)</code></li>
  <li><a href="#mathlog2"><code class="md-code md-code-inline">Math.log2</code></a> — base 2 logarithm of <code class="md-code md-code-inline">value</code>, or <code class="md-code md-code-inline"><em>log</em><sub>2</sub>(value)</code></li></ul></li>
  <li><strong>Trigonometry</strong><ul>
  <li><a href="#mathsinh"><code class="md-code md-code-inline">Math.sinh</code></a> — hyperbolic sine of a number</li>
  <li><a href="#mathcosh"><code class="md-code md-code-inline">Math.cosh</code></a> — hyperbolic cosine of a number</li>
  <li><a href="#mathtanh"><code class="md-code md-code-inline">Math.tanh</code></a> — hyperbolic tangent of a number</li>
  <li><a href="#mathasinh"><code class="md-code md-code-inline">Math.asinh</code></a> — hyperbolic arc-sine of a number</li>
  <li><a href="#mathacosh"><code class="md-code md-code-inline">Math.acosh</code></a> — hyperbolic arc-cosine of a number</li>
  <li><a href="#mathatanh"><code class="md-code md-code-inline">Math.atanh</code></a> — hyperbolic arc-tangent of a number</li>
  <li><a href="#mathhypot"><code class="md-code md-code-inline">Math.hypot</code></a> — square root of the sum of squares</li></ul></li>
  <li><strong>Bitwise</strong><ul>
  <li><a href="#mathclz32"><code class="md-code md-code-inline">Math.clz32</code></a> — leading zero bits in the 32-bit representation of a number</li></ul></li>
  <li><strong>Compile-to-JavaScript</strong><ul>
  <li><a href="#mathimul"><code class="md-code md-code-inline">Math.imul</code></a> — <em>C-like</em> 32-bit multiplication</li>
  <li><a href="#mathfround"><code class="md-code md-code-inline">Math.fround</code></a> — nearest single-precision float representation of a number</li></ul></li></ul>

<p>Let’s get right into it.</p>



<h1 id="mathsign"><span class="md-heading"><code class="md-code md-code-inline">Math.sign</code></span></h1>

<p>Many languages have a <a href="https://msdn.microsoft.com/en-us/library/ywb0xks3(v=vs.110).aspx" aria-label="C#, for instance"><code class="md-code md-code-inline">Math.Sign</code></a> method <em>(or equivalent)</em> that returns a vector like <code class="md-code md-code-inline">-1</code>, <code class="md-code md-code-inline">0</code>, or <code class="md-code md-code-inline">1</code>, depending on the sign of the provided input. Surely then, you would think JavaScript’s <code class="md-code md-code-inline">Math.sign</code> method does the same. Well, sort of. The JavaScript flavor of this method has two more alternatives: <code class="md-code md-code-inline">-0</code>, and <code class="md-code md-code-inline">NaN</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="cls">Math</span>.<span class="built_in">sign</span>(<span class="num">1</span>)
<span class="com">// &lt;- 1</span>
<span class="cls">Math</span>.<span class="built_in">sign</span>(<span class="num">0</span>)
<span class="com">// &lt;- 0</span>
<span class="cls">Math</span>.<span class="built_in">sign</span>(-<span class="num">0</span>)
<span class="com">// &lt;- <mark class="md-mark md-code-mark">-0</mark></span>
<span class="cls">Math</span>.<span class="built_in">sign</span>(-<span class="num">30</span>)
<span class="com">// &lt;- -1</span>
<span class="cls">Math</span>.<span class="built_in">sign</span>(<span class="md-code-nan">NaN</span>)
<span class="com">// &lt;- <mark class="md-mark md-code-mark">NaN</mark></span>
<span class="cls">Math</span>.<span class="built_in">sign</span>(<span class="str">'foo'</span>)
<span class="com">// &lt;- NaN, because Number('foo') is NaN</span>
<span class="cls">Math</span>.<span class="built_in">sign</span>(<span class="str">'0'</span>)
<span class="com">// &lt;- <mark class="md-mark md-code-mark">0</mark>, because Number('0') is 0</span>
<span class="cls">Math</span>.<span class="built_in">sign</span>(<span class="str">'-1'</span>)
<span class="com">// &lt;- <mark class="md-mark md-code-mark">-1</mark>, because Number('-1') is -1</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>This is just one of those methods. It <strong>grinds my gears.</strong> After all the trouble we went through to document how methods ported over to <code class="md-code md-code-inline">Number</code>, such as <code class="md-code md-code-inline">Number.isNaN</code>, don’t indulge in <a href="#es6-number-improvements-in-depth" aria-label="ES6 Number Improvements in Depth">unnecessary type coercion</a>, why is it that <code class="md-code md-code-inline">Math.sign</code> <em>does</em> coerce its input? I have no idea. Most of the methods in <code class="md-code md-code-inline">Math</code> share this trait, though. The methods that were added to <code class="md-code md-code-inline">Number</code> don’t.</p>

<p><img alt="‘What really grinds my gears’, on Family Guy" class="js-only" src="auxi/family_guy.png">/p>

<p>Sure, we’re not a statically typed language, we dislike throwing exceptions, and we’re <a href="http://blog.codinghorror.com/javascript-and-html-forgiveness-by-default/" aria-label="JavaScript and HTML: Forgiveness by Default">fault tolerant</a> — after all, this is one of the founding languages of the web. But was not coercing everything into a <code class="md-code md-code-inline">Number</code> too much to ask? Couldn’t we just return <code class="md-code md-code-inline">NaN</code> for <em>non-numeric</em> values?</p>

<p>I’d love for us to get over implicit casting, but it seems we’re <em>not quite there yet</em> for the time being.</p>



<h1 id="mathtrunc"><span class="md-heading"><code class="md-code md-code-inline">Math.trunc</code></span></h1>

<p>One of the oddities in <code class="md-code md-code-inline">Math</code> methods is how abruptly they were named. It’s like they were trying to save keystrokes or something. After all, it’s not like we stopped adding <em>super-precise</em> method names like <a href="#es6-symbols-in-depth" aria-label="ES6 Symbols in Depth"><code class="md-code md-code-inline">Object.getOwnPropertySymbols()</code></a>. Why <code class="md-code md-code-inline">trunc</code> instead of <code class="md-code md-code-inline">truncate</code>, then? Who knows.</p>

<p>Anyways, <code class="md-code md-code-inline">Math.trunc</code> is a simple alternative to <code class="md-code md-code-inline">Math.floor</code> and <code class="md-code md-code-inline">Math.ceil</code> where we simply discard the decimal part of a number. Once again, the input is coerced into a numeric value through <code class="md-code md-code-inline">Number(value)</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="cls">Math</span>.<span class="built_in">trunc</span>(<span class="num">12.34567</span>)
<span class="com">// &lt;- 12</span>
<span class="cls">Math</span>.<span class="built_in">trunc</span>(-<span class="num">13.58</span>)
<span class="com">// &lt;- -13</span>
<span class="cls">Math</span>.<span class="built_in">trunc</span>(-<span class="num">0.1234</span>)
<span class="com">// &lt;- <mark class="md-mark md-code-mark">-0</mark></span>
<span class="cls">Math</span>.<span class="built_in">trunc</span>(<span class="md-code-nan">NaN</span>)
<span class="com">// &lt;- NaN</span>
<span class="cls">Math</span>.<span class="built_in">trunc</span>(<span class="str">'foo'</span>)
<span class="com">// &lt;- <mark class="md-mark md-code-mark">NaN</mark>, because Number('foo') is NaN</span>
<span class="cls">Math</span>.<span class="built_in">trunc</span>(<span class="str">'123.456'</span>)
<span class="com">// &lt;- <mark class="md-mark md-code-mark">123</mark>, because Number('123.456') is 123.456</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>While it still coerces any values into numbers, at least it stayed consistent with <code class="md-code md-code-inline">Math.floor</code> and <code class="md-code md-code-inline">Math.ceil</code>, enough that you could use them to create a simple polyfill for <code class="md-code md-code-inline">Math.trunc</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="cls">Math</span>.<span class="built_in">trunc</span> <span class="op">=</span> <span class="md-code-function"><span class="kw">function</span> <span class="fn">truncate</span> <span class="params">(value)</span> </span>{
  <span class="kw3">return</span> <span class="param">value</span> <span class="op">&gt;</span>
<span class="num">0</span> <span class="op">?</span> <span class="cls">Math</span>.<span class="built_in">floor</span>(<span class="param">value</span>) <span class="op">:</span> <span class="cls">Math</span>.<span class="built_in">ceil</span>(<span class="param">value</span>)
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Another apt example of how <em>“succintly”</em> <code class="md-code md-code-inline">Math</code> methods have been named in ES6 can be found in <code class="md-code md-code-inline">Math.cbrt</code> <em>— although this one matches the pre-existing <code class="md-code md-code-inline">Math.sqrt</code> method, to be fair.</em></p>



<h1 id="mathcbrt"><span class="md-heading"><code class="md-code md-code-inline">Math.cbrt</code></span></h1>

<p>As hinted above, <code class="md-code md-code-inline">Math.cbrt</code> is short for <em>“cubic root”</em>. The examples below show the sorts of output it produces.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="cls">Math</span>.<span class="built_in">cbrt</span>(-<span class="num">1</span>)
<span class="com">// &lt;- -1</span>
<span class="cls">Math</span>.<span class="built_in">cbrt</span>(<span class="num">3</span>)
<span class="com">// &lt;- 1.4422495703074083</span>
<span class="cls">Math</span>.<span class="built_in">cbrt</span>(<span class="num">8</span>)
<span class="com">// &lt;- 2</span>
<span class="cls">Math</span>.<span class="built_in">cbrt</span>(<span class="num">27</span>)
<span class="com">// &lt;- 3</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Not much explaining to do here. Note that this method <em>also</em> coerces non-numerical values into numbers.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="cls">Math</span>.<span class="built_in">cbrt</span>(<span class="str">'8'</span>)
<span class="com">// &lt;- <mark class="md-mark md-code-mark">2</mark>, because Number('8') is 8</span>
<span class="cls">Math</span>.<span class="built_in">cbrt</span>(<span class="str">'ponyfoo'</span>)
<span class="com">// &lt;- <mark class="md-mark md-code-mark">NaN</mark>, because Number('ponyfoo') is NaN</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Let’s move onto something else.</p>



<h1 id="mathexpm1"><span class="md-heading"><code class="md-code md-code-inline">Math.expm1</code></span></h1>

<p>This operation is the result of computing <code class="md-code md-code-inline">e</code> to the <code class="md-code md-code-inline">value</code> minus <code class="md-code md-code-inline">1</code>. In JavaScript, the <code class="md-code md-code-inline">e</code> constant is defined as <code class="md-code md-code-inline">Math.E</code>. The method below is a rough equivalent of <code class="md-code md-code-inline">Math.expm1</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">expm1</span> <span class="params">(value)</span> </span>{
  <span class="kw3">return</span> <span class="cls">Math</span>.<span class="built_in">pow</span>(<span class="cls">Math</span>.<span class="built_in">E</span>, <span class="param">value</span>) <span class="op">-</span> <span class="num">1</span>
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The <code class="md-code md-code-inline">e<sup>value</sup></code> operation can be expressed as <code class="md-code md-code-inline">Math.exp(value)</code> as well.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">expm1</span> <span class="params">(value)</span> </span>{
  <span class="kw3">return</span> <span class="cls">Math</span>.<span class="built_in">exp</span>(<span class="param">value</span>) <span class="op">-</span> <span class="num">1</span>
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Note that this method has higher precision than merely doing <code class="md-code md-code-inline">Math.exp(value) - 1</code>, and should be the preferred alternative.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="fn">expm1</span>(<span class="num">1e-20</span>)
<span class="com">// &lt;- 0</span>
<span class="cls">Math</span>.<span class="built_in">expm1</span>(<span class="num">1e-20</span>)
<span class="com">// &lt;- 1e-20</span>
<span class="fn">expm1</span>(<span class="num">1e-10</span>)
<span class="com">// &lt;- 1.000000082740371e-10</span>
<span class="cls">Math</span>.<span class="built_in">expm1</span>(<span class="num">1e-10</span>)
<span class="com">// &lt;- 1.00000000005e-10</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The inverse function of <code class="md-code md-code-inline">Math.expm1</code> is <code class="md-code md-code-inline">Math.log1p</code>.</p>



<h1 id="mathlog1p"><span class="md-heading"><code class="md-code md-code-inline">Math.log1p</code></span></h1>

<p>This is the natural logarithm of <code class="md-code md-code-inline">value</code> plus <code class="md-code md-code-inline">1</code>, — <code class="md-code md-code-inline"><em>ln</em>(value + 1)</code> — and the inverse function of <code class="md-code md-code-inline">Math.expm1</code>. The base <code class="md-code md-code-inline">e</code> logarithm of a number can be expressed as <code class="md-code md-code-inline">Math.log</code> in JavaScript.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">log1p</span> <span class="params">(value)</span> </span>{
 <span class="kw3">return</span> <span class="cls">Math</span>.<span class="built_in">log</span>(<span class="param">value</span> <span class="op">+</span> <span class="num">1</span>)
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>This method is <strong>more precise</strong> than executing the <code class="md-code md-code-inline">Math.log(value + 1)</code> operation by hand, just like the <a href="#mathexpm1"><code class="md-code md-code-inline">Math.expm1</code></a> case.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="fn">log1p</span>(<span class="num">1.00000000005e-10</span>)
<span class="com">// &lt;- 1.000000082690371e-10</span>
<span class="cls">Math</span>.<span class="built_in">log1p</span>(<span class="num">1.00000000005e-10</span>)
<span class="com">// &lt;- <mark class="md-mark md-code-mark">1e-10</mark>, exactly the inverse of Math.expm1(1e-10)</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->

<p>Next up is <code class="md-code md-code-inline">Math.log10</code>.</p>



<h1 id="mathlog10"><span class="md-heading"><code class="md-code md-code-inline">Math.log10</code></span></h1>

<p>Base ten logarithm of a number — <code class="md-code md-code-inline"><em>log</em><sub>10</sub>(value)</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="cls">Math</span>.<span class="built_in">log10</span>(<span class="num">1000</span>)
<span class="com">// &lt;- 3</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>You could polyfill <code class="md-code md-code-inline">Math.log10</code> using the <code class="md-code md-code-inline">Math.LN10</code> constant.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">log10</span> <span class="params">(value)</span> </span>{
  <span class="kw3">return</span> <span class="cls">Math</span>.<span class="built_in">log</span>(x) <span class="op">/</span> <span class="cls">Math</span>.<span class="built_in">LN10</span>
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>And then there’s <code class="md-code md-code-inline">Math.log2</code>.</p>



<h1 id="mathlog2"><span class="md-heading"><code class="md-code md-code-inline">Math.log2</code></span></h1>

<p>Base two logarithm of a number — <code class="md-code md-code-inline"><em>log</em><sub>2</sub>(value)</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="cls">Math</span>.<span class="built_in">log2</span>(<span class="num">1024</span>)
<span class="com">// &lt;- 10</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>You could polyfill <code class="md-code md-code-inline">Math.log2</code> using the <code class="md-code md-code-inline">Math.LN2</code> constant.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">log2</span> <span class="params">(value)</span> </span>{
  <span class="kw3">return</span> <span class="cls">Math</span>.<span class="built_in">log</span>(x) <span class="op">/</span> <span class="cls">Math</span>.<span class="built_in">LN2</span>
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Note that the polyfilled version won’t be as precise as <code class="md-code md-code-inline">Math.log2</code> in some cases. Remember that the <code class="md-code md-code-inline">&lt;&lt;</code> operator means <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Left_shift" aria-label="Bitwise left shift operator on MDN"><em>“bitwise left shift”</em></a>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="cls">Math</span>.<span class="built_in">log2</span>(<span class="num">1</span> <span class="op">&lt;&lt;</span> <span class="num">29</span>)
<span class="com">// &lt;- 29</span>
<span class="fn">log2</span>(<span class="num">1</span> <span class="op">&lt;&lt;</span> <span class="num">29</span>)
<span class="com">// &lt;- 29.000000000000004</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Naturally, you could use <code class="md-code md-code-inline">Math.round</code> or <a href="#es6-number-improvements-in-depth#numberepsilon" aria-label="Number.EPSILON, ES6 Number Improvements in Depth"><code class="md-code md-code-inline">Number.EPSILON</code></a> to get around rounding issues.</p>



<h1 id="mathsinh"><span class="md-heading"><code class="md-code md-code-inline">Math.sinh</code></span></h1>

<p>Returns the hyperbolic sine of <code class="md-code md-code-inline">value</code>.</p>


<h1 id="mathcosh"><span class="md-heading"><code class="md-code md-code-inline">Math.cosh</code></span></h1>

<p>Returns the hyperbolic cosine of <code class="md-code md-code-inline">value</code>.</p>


<h1 id="mathtanh"><span class="md-heading"><code class="md-code md-code-inline">Math.tanh</code></span></h1>

<p>Returns the hyperbolic tangent of <code class="md-code md-code-inline">value</code>.</p>


<h1 id="mathasinh"><span class="md-heading"><code class="md-code md-code-inline">Math.asinh</code></span></h1>

<p>Returns the hyperbolic arc-sine of <code class="md-code md-code-inline">value</code>.</p>


<h1 id="mathacosh"><span class="md-heading"><code class="md-code md-code-inline">Math.acosh</code></span></h1>

<p>Returns the hyperbolic arc-cosine of <code class="md-code md-code-inline">value</code>.</p>


<h1 id="mathatanh"><span class="md-heading"><code class="md-code md-code-inline">Math.atanh</code></span></h1>

<p>Returns the hyperbolic arc-tangent of <code class="md-code md-code-inline">value</code>.</p>


<h1 id="mathhypot"><span class="md-heading"><code class="md-code md-code-inline">Math.hypot</code></span></h1>

<p>Returns the square root of the sum of the squares of the arguments.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="cls">Math</span>.<span class="built_in">hypot</span>(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>)
<span class="com">// &lt;- 3.741657386773941</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>We could polyfill <code class="md-code md-code-inline">Math.hypot</code> by doing the operations manually. We can use <code class="md-code md-code-inline">Math.sqrt</code> to compute the square root and <a href="#fun-with-native-arrays" aria-label="Fun with Native Arrays on Pony Foo"><code class="md-code md-code-inline">Array.prototype.reduce</code></a> combined with the <a href="#es6-spread-and-butter-in-depth" aria-label="ES6 Spread and Butter in Depth">spread operator</a> to sum the squares. I’ll throw in <a href="#es6-arrow-functions-in-depth" aria-label="ES6 Arrow Functions in Depth">an arrow function</a> for good measure!</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">hypot</span> <span class="params">(<mark class="md-mark md-code-mark"><span class="op">...</span></mark>values)</span> </span>{
  <span class="kw3">return</span> <span class="cls">Math</span>.<span class="built_in">sqrt</span>(<span class="param">values</span><mark class="md-mark md-code-mark">.<span class="built_in">reduce</span></mark>((sum, value) <span class="op">=&gt;</span> sum <span class="op">+</span> <mark class="md-mark md-code-mark">value <span class="op">*</span> value</mark>, <span class="num">0</span>))
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Surprisingly, our handmade method is more precise than the native one <em>(at least on Chrome 45)</em> for <strong>this case in particular</strong>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="cls">Math</span>.<span class="built_in">hypot</span>(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>)
<span class="com">// &lt;- 3.741657386773941</span>
<span class="fn">hypot</span>(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>)
<span class="com">// &lt;- <mark class="md-mark md-code-mark">3.7416573867739413</mark></span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>And now for the <strong>"<em>really</em> fun"</strong> methods!</p>



<h1 id="mathclz32"><span class="md-heading"><code class="md-code md-code-inline">Math.clz32</code></span></h1>

<p>Definitely not immediately obvious, but the name for this method is an acronym for <em>“count leading zero bits in 32-bit binary representations of a number”</em>. Remember that the <code class="md-code md-code-inline">&lt;&lt;</code> operator means <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Left_shift" aria-label="Bitwise left shift operator on MDN"><em>“bitwise left shift”</em></a>, and thus…</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="cls">Math</span>.<span class="built_in">clz32</span>(<span class="num">0</span>)
<span class="com">// &lt;- 32</span>
<span class="cls">Math</span>.<span class="built_in">clz32</span>(<span class="num">1</span>)
<span class="com">// &lt;- 31</span>
<span class="cls">Math</span>.<span class="built_in">clz32</span>(<span class="num">1</span> <span class="op">&lt;&lt;</span> <span class="num">1</span>)
<span class="com">// &lt;- 30</span>
<span class="cls">Math</span>.<span class="built_in">clz32</span>(<span class="num">1</span> <span class="op">&lt;&lt;</span> <span class="num">2</span>)
<span class="com">// &lt;- 29</span>
<span class="cls">Math</span>.<span class="built_in">clz32</span>(<span class="num">1</span> <span class="op">&lt;&lt;</span> <span class="num">29</span>)
<span class="com">// &lt;- 2</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Cool, and also probably the last time you’re going to see that method in use for the foreseeable future. For completeness’ sake, I’ll add a sentence about the pair of methods that were added mostly to aid with <code class="md-code md-code-inline">asm.js</code> compilation of C programs. <em>I doubt you’ll be using these directly, ever.</em></p>



<h1 id="mathimul"><span class="md-heading"><code class="md-code md-code-inline">Math.imul</code></span></h1>

<p>Returns the result of a C-like 32-bit multiplication.</p>



<h1 id="mathfround"><span class="md-heading"><code class="md-code md-code-inline">Math.fround</code></span></h1>

<p>Rounds <code class="md-code md-code-inline">value</code> to the nearest 32-bit float representation of a number.</p>



<h1 id="conclusions"><span class="md-heading">Conclusions</span></h1>

<p>Some nice methods rounding out the <code class="md-code md-code-inline">Math</code> API. It would’ve been nice to see additions to the tune of more flavors of <code class="md-code md-code-inline">Math.random</code> and similar utilities that end up being implemented by libraries in almost every large-enough application, such as Lodash’es <a href="https://lodash.com/docs#random" aria-label="_.random([min=0], [max=1], [floating]) on Lodash documentation"><code class="md-code md-code-inline">_.random</code></a> and <a href="https://lodash.com/docs#shuffle" aria-label="_.shuffle(collection) on Lodash documentation"><code class="md-code md-code-inline">_.shuffle</code></a>.</p>

<p>That being said, any help towards making <a href="http://asmjs.org/faq.html" aria-label="asm.js frequently asked questions"><code class="md-code md-code-inline">asm.js</code></a> faster and more of a reality are desperately welcome additions to the language.</p></section></section>
</article>
</div>
<p><a href="#top" class="top"><img src="./auxi/glyphicons-214-up-arrow.png" alt="up-arrow" class="uparrow" /> <b>Back to top</b></a></p>
</section></main>

<!--  math ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->
<!--  ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->









<!--  array ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->

<main class="ly-main"><header class="at-header">



<h1 itemprop="headline" class="dc-title" id="es6-array-extensions-in-depth">ES6 Array Extensions in Depth</h1></header>

<section class="at-teaser"><div class="at-teaser-markdown md-markdown">

<p>Hello, traveler! This is ES6 — <em>“Oh cool, I like <code class="md-code md-code-inline">Array</code>”</em> — in Depth series. If you’ve never been around here before, start with <a href="#a-brief-history-of-es6-tooling">A Brief History of ES6 Tooling</a>. Then, make your way through <a href="#es6-destructuring-in-depth">destructuring</a>, <a href="#es6-template-strings-in-depth">template literals</a>, <a href="#es6-arrow-functions-in-depth">arrow functions</a>, the <a href="#es6-spread-and-butter-in-depth">spread operator and rest parameters</a>, improvements coming to <a href="#es6-object-literal-features-in-depth">object literals</a>, the new <a href="#es6-classes-in-depth"><em>classes</em></a> sugar on top of prototypes, <a href="#es6-let-const-and-temporal-dead-zone-in-depth"><code class="md-code md-code-inline">let</code>, <code class="md-code md-code-inline">const</code>, and the <em>“Temporal Dead Zone”</em></a>, <a href="#es6-iterators-in-depth">iterators</a>, <a href="#es6-generators-in-depth">generators</a>, <a href="#es6-symbols-in-depth">Symbols</a>, <a href="#es6-maps-in-depth">Maps</a>, <a href="#es6-weakmaps-sets-and-weaksets-in-depth">WeakMaps, Sets, and WeakSets</a>, <a href="#es6-proxies-in-depth">proxies</a>, <a href="#es6-proxy-traps-in-depth">proxy traps</a>, <a href="#more-es6-proxy-traps-in-depth">more proxy traps</a>, <a href="#es6-reflection-in-depth">reflection</a>, <a href="#es6-number-improvements-in-depth"><code class="md-code md-code-inline">Number</code></a>, and <a href="#es6-math-additions-in-depth"><code class="md-code md-code-inline">Math</code></a>. Today we’ll learn about new <code class="md-code md-code-inline">Array</code> extensions.</p></div></section>

<section class="at-container de-host"><div class="de-column">

<article itemscope="itemscope" itemtype="http://schema.org/BlogPosting" class="at-article ly-section">
<meta itemprop="dateCreated" content="2015-09-11T22:24:55+00:00" />
<meta itemprop="datePublished" content="2015-09-22T13:24:02+00:00" />
<meta itemprop="dateModified" content="2015-10-11T04:06:38+00:00" />
<meta itemprop="keywords" content="es6,array,es6-in-depth" />

<section itemprop="articleBody" class="at-corpus">

<section itemprop="about" class="md-markdown at-introduction"><blockquote>

<p>As I did in previous articles on the series, I would love to point out that you should probably <a href="#universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That’ll make it so much easier for you to <strong>internalize the concepts</strong> discussed in the series. If you aren’t the <em>“install things on my computer”</em> kind of human, you might prefer to hop on <a href="http://codepen.io/">CodePen</a> and then click on the gear icon for JavaScript — <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em> Another alternative that’s also quite useful is to use Babel’s <a href="http://babeljs.io/repl/">online REPL</a> <em>— it’ll show you compiled ES5 code to the right of your ES6 code for quick comparison.</em></p></blockquote>

<p>Before getting into it, let me <a href="https://www.patreon.com/bevacqua"><em>shamelessly ask for your support</em></a> if you’re enjoying my ES6 in Depth series. Your contributions will go towards helping me keep up with the schedule, server bills, keeping me fed, and maintaining <strong>Pony Foo</strong> as a veritable source of JavaScript goodies.</p>

<p>Thanks for reading that, and let’s go into <code class="md-code md-code-inline">Array</code> extensions. For a bit of context you may want to look at the articles on <a href="#es6-iterators-in-depth">iterators</a>, <a href="#es6-generators-in-depth">generators</a>, <a href="#es6-arrow-functions-in-depth">arrow functions</a> and <a href="#es6-maps-in-depth">collections</a>.</p></section>

<section class="md-markdown at-body">



<h1 id="upcoming-array-methods"><span class="md-heading">Upcoming <code class="md-code md-code-inline">Array</code> Methods</span></h1>

<p>There’s plenty to choose from. Over the years, libraries like Underscore and Lodash spoke loudly about features we were missing in the language, and now we have a ton more tools in the <a href="#fun-with-native-arrays" aria-label="Fun with Native Arrays on Pony Foo">functional array</a> arsenal at our disposal.</p>

<p>First off, there’s a couple of static methods being added.</p><ul>
  <li><a href="#arrayfrom"><code class="md-code md-code-inline">Array.from</code></a> — create <code class="md-code md-code-inline">Array</code> instances from arraylike objects like <code class="md-code md-code-inline">arguments</code> or iterables</li>
  <li><a href="#arrayof"><code class="md-code md-code-inline">Array.of</code></a></li></ul>

<p>Then there’s a few methods that help you manipulate, fill, and filter arrays.</p><ul>
  <li><a href="#arrayprototypecopywithin"><code class="md-code md-code-inline">Array.prototype.copyWithin</code></a></li>
  <li><a href="#arrayprototypefill"><code class="md-code md-code-inline">Array.prototype.fill</code></a></li>
  <li><a href="#arrayprototypefind"><code class="md-code md-code-inline">Array.prototype.find</code></a></li>
  <li><a href="#arrayprototypefindindex"><code class="md-code md-code-inline">Array.prototype.findIndex</code></a></li></ul>

<p>There’s also the methods <a href="#es6-iterators-in-depth" aria-label="ES6 Iterators in Depth">related to the iterator protocol</a>.</p><ul>
  <li><a href="#arrayprototypekeys"><code class="md-code md-code-inline">Array.prototype.keys</code></a></li>
  <li><a href="#arrayprototypevalues"><code class="md-code md-code-inline">Array.prototype.values</code></a></li>
  <li><a href="#arrayprototypeentries"><code class="md-code md-code-inline">Array.prototype.entries</code></a></li>
  <li><a href="#arrayprototype-symboliterator"><code class="md-code md-code-inline">Array.prototype[Symbol.iterator]</code></a></li></ul>

<p>There’s a few more methods coming in ES2016 <em>(ES7)</em> as well, but we won’t be covering those today.</p><ul>
  <li><code class="md-code md-code-inline">Array.prototype.includes</code></li>
  <li><code class="md-code md-code-inline">Array.observe</code></li>
  <li><code class="md-code md-code-inline">Array.unobserve</code></li></ul>

<p>Let’s get to work!</p>


<h1 id="arrayfrom"><span class="md-heading"><code class="md-code md-code-inline">Array.from</code></span></h1>

<p>This method has been long overdue. Remember the quintessential example of converting an arraylike into an actual array?</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">function</span> <span class="fn">cast</span> ()
  <span class="kw3">return</span> <mark class="md-mark md-code-mark"><span class="kw">Array</span>.<span class="built_in">prototype.slice.call</span></mark>(arguments)
}
<span class="fn">cast</span>(<span class="str">'a'</span>, <span class="str">'b'</span>)
<span class="comment">// &lt;- ['a', 'b']</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Or a shorter form perhaps?</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">function</span> <span class="fn">cast</span> ()
  <span class="kw3">return</span> <mark class="md-mark md-code-mark">[].<span class="built_in">slice.call</span></mark>(arguments)
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>To be fair, we’ve already explored even more terse ways of doing this at some point during the ES6 in depth series. For instance you could use the <a href="#es6-spread-and-butter-in-depth" aria-label="ES6 Spread and Butter in Depth">spread operator</a>. As you probably remember, the spread operator leverages the <a href="#es6-iterators-in-depth" aria-label="ES6 Iterators in Depth">iterator protocol</a> to produce a sequence of values in arbitrary objects. The downside is that the objects we want to cast with spread <strong>must implement</strong> <code class="md-code md-code-inline">@@iterator</code> through <code class="md-code md-code-inline">Symbol.iterator</code>. Luckily for us, <code class="md-code md-code-inline">arguments</code> does implement the iterator protocol in ES6.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">function</span> <span class="fn">cast</span> ()
  <span class="kw3">return</span> [<mark class="md-mark md-code-mark"><span class="op">...</span></mark>arguments]
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Another thing you could be casting through the spread operator is DOM element collections like those returned from <code class="md-code md-code-inline">document.querySelectorAll</code>. Once again, this is made possible thanks to ES6 adding conformance to the iterator protocol to <code class="md-code md-code-inline">NodeList</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">[<mark class="md-mark md-code-mark"><span class="op">...</span></mark><span class="kw">document</span>.querySelectorAll(<span class="str">'div'</span>)]
<span class="com">// &lt;- [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;, ...]</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>What happens when we try to cast a jQuery collection through the spread operator? Actually, you’ll <strong>get an exception</strong> because they haven’t implemented <a href="#es6-iterators-in-depth" aria-label="ES6 Iterators in Depth"><code class="md-code md-code-inline">Symbol.iterator</code></a> quite yet. You can try this one on <a href="http://jquery.com" aria-label="jQuery: Do less, bloat more">jquery.com</a> in Firefox.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="op">...</span>$(<span class="str">'div'</span>)]
<span class="com">// &lt;- <mark class="md-mark md-code-mark">TypeError: $(<span class="op">...</span>)[<span class="md-code-symbol">Symbol</span>.<span class="built_in">iterator</span>] is not a function</mark>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The new <code class="md-code md-code-inline">Array.from</code> method is different, though. It doesn’t <em>only</em> rely on iterator protocol to figure out how to pull values from an object. It also has support for arraylikes out the box.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">Array</span>.<span class="built_in">from</span>(<mark class="md-mark md-code-mark">$(<span class="str">'div'</span>)</mark>)
<span class="com">// &lt;- [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;, ...]</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The one thing you cannot do with either <code class="md-code md-code-inline">Array.from</code> nor the spread operator is to pick a start index. Suppose you wanted to pull every <code class="md-code md-code-inline">&lt;div&gt;</code> after the first one. With <code class="md-code md-code-inline">.slice.call</code>, you could do it like so:</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">[].<span class="built_in">slice.call</span>(<span class="kw">document</span>.<span class="built_in">querySelectorAll</span>(<span class="str">'div'</span>)<mark class="md-mark md-code-mark">, <span class="num">1</span></mark>)
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Of course, there’s nothing stopping you from using <code class="md-code md-code-inline">.slice</code> <em>after</em> casting. This is probably way easier to read, and looks more like functional programming, so there’s that.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">Array</span>.<span class="built_in">from</span>(<span class="kw">document</span>.<span class="built_in">querySelectorAll</span>(<span class="str">'div'</span>))<mark class="md-mark md-code-mark">.<span class="built_in">slice</span>(<span class="num">1</span>)</mark>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p><code class="md-code md-code-inline">Array.from</code> actually has three arguments, <em>but only the <code class="md-code md-code-inline">input</code> is required</em>. To wit:</p><ul>
  <li><code class="md-code md-code-inline">input</code> — the arraylike or iterable object you want to cast</li>
  <li><code class="md-code md-code-inline">map</code> — a mapping function that’s executed on every item of <code class="md-code md-code-inline">input</code></li>
  <li><code class="md-code md-code-inline">context</code> — the <code class="md-code md-code-inline">this</code> binding to use when calling <code class="md-code md-code-inline">map</code></li></ul>

<p>With <code class="md-code md-code-inline">Array.from</code> we cannot slice, but we can dice!</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">typesOf</span> <span class="params">()</span> </span>{
  <span class="kw3">return</span> <span class="kw">Array</span>.<span class="built_in">from</span>(arguments, value <span class="op">=&gt;</span> <span class="kw">typeof</span> value)
}
<span class="fn">typesOf</span>(<span class="md-code-null">null</span>, [], <span class="md-code-nan">NaN</span>)
<span class="com">// &lt;- ['object', 'object', 'number']</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Do note that you could also just combine <a href="#es6-spread-and-butter-in-depth" aria-label="ES6 Spread and Butter in Depth">rest parameters</a> and <code class="md-code md-code-inline">.map</code> if you were just dealing with <code class="md-code md-code-inline">arguments</code>. In this case in particular, we may be better off just doing something like the snippet of code found below.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">typesOf</span> <span class="params">(<mark class="md-mark md-code-mark"><span class="op">...</span></mark>all)</span> </span>{
  <span class="kw3">return</span> all.<span class="built_in">map</span>(<span class="param">value</span> <span class="op">=&gt;</span> <span class="kw">typeof</span> <span class="param">value</span>)
}
<span class="fn">typesOf</span>(<span class="md-code-null">null</span>, [], <span class="md-code-nan">NaN</span>)
<span class="com">// &lt;- ['object', 'object', 'number']</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>In some cases, like the case of jQuery we saw earlier, it makes sense to use <code class="md-code md-code-inline">Array.from</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">Array</span>.<span class="built_in">from</span>($(<span class="str">'div'</span>))
<span class="com">// &lt;- [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;, ...]</span>
<span class="kw">Array</span>.<span class="built_in">from</span>($(<span class="str">'div'</span>), el <span class="op">=&gt;</span> el.id)
<span class="com">// &lt;- ['', 'container', 'logo-events', 'broadcast', ...]</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>I guess you get the idea.</p>



<h1 id="arrayof"><span class="md-heading"><code class="md-code md-code-inline">Array.of</code></span></h1>

<p>This method is exactly like the first incarnation of <code class="md-code md-code-inline">cast</code> we played with in our analysis of <a href="#arrayfrom"><code class="md-code md-code-inline">Array.from</code></a>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">Array</span>.<span class="built_in">of</span> <span class="op">=</span> <span class="md-code-function"><span class="kw">function</span> <span class="fn">of</span> <span class="params">()</span> </span>{
  <span class="kw3">return</span> <span class="kw">Array</span>.<span class="built_in">prototype.slice.call</span>(arguments)
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>You can’t just replace <code class="md-code md-code-inline">Array.prototype.slice.call</code> with <code class="md-code md-code-inline">Array.of</code>. They’re different animals.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">Array</span>.<span class="built_in">prototype.slice.call</span>(<mark class="md-mark md-code-mark">[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>]</mark>)
<span class="com">// &lt;- [1, 2, 3]</span>
<span class="kw">Array</span>.<span class="built_in">of</span>(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>)
<span class="com">// &lt;- [1, 2, 3]</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>You can think of <code class="md-code md-code-inline">Array.of</code> as an alternative for <code class="md-code md-code-inline">new Array</code> that doesn’t have the <code class="md-code md-code-inline">new Array(length)</code> overload. Below you’ll find some of the strange ways in which <code class="md-code md-code-inline">new Array</code> behaves thanks to its single-argument <code class="md-code md-code-inline">length</code> overloaded constructor. If you’re confused about the <code class="md-code md-code-inline">undefined x ${number}</code> notation in the browser console, that’s indicating there are <a href="http://www.2ality.com/2013/07/array-iteration-holes.html" aria-label="Array iteration and holes in JavaScript on 2ality.com">array holes</a> in those positions.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">new</span> <span class="kw">Array</span>()
<span class="com">// &lt;- []</span>
<span class="kw">new</span> <span class="kw">Array</span>(<span class="literal">undefined</span>)
<span class="com">// &lt;- [undefined]</span>
<span class="kw">new</span> <span class="kw">Array</span>(<span class="num">1</span>)
<span class="com">// &lt;- <mark class="md-mark md-code-mark">[undefined x 1]</mark></span>
<span class="kw">new</span> <span class="kw">Array</span>(<span class="num">3</span>)
<span class="com">// &lt;- <mark class="md-mark md-code-mark">[undefined x 3]</mark></span>
<span class="kw">new</span> <span class="kw">Array</span>(<span class="num">1</span>, <span class="num">2</span>)
<span class="com">// &lt;- [1, 2]</span>
<span class="kw">new</span> <span class="kw">Array</span>(<span class="op">-</span><span class="num">1</span>)
<span class="com">// &lt;- <mark class="md-mark md-code-mark">RangeError: Invalid array length</mark></span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>In contrast, <code class="md-code md-code-inline">Array.of</code> has more consistent behavior because it doesn’t have the special <code class="md-code md-code-inline">length</code> case.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">Array</span>.<span class="built_in">of</span>()
<span class="com">// &lt;- []</span>
<span class="kw">Array</span>.<span class="built_in">of</span>(<span class="md-code-null">undefined</span>)
<span class="com">// &lt;- [undefined]</span>
<span class="kw">Array</span>.<span class="built_in">of</span>(<span class="num">1</span>)
<span class="com">// &lt;- [1]</span>
<span class="kw">Array</span>.<span class="built_in">of</span>(<span class="num">3</span>)
<span class="com">// &lt;- [3]</span>
<span class="kw">Array</span>.<span class="built_in">of</span>(<span class="num">1</span>, <span class="num">2</span>)
<span class="com">// &lt;- [1, 2]</span>
<span class="kw">Array</span>.<span class="built_in">of</span>(<span class="op">-</span><span class="num">1</span>)
<span class="com">// &lt;- [-1]</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>There’s not a lot to add here — let’s move on.</p>



<h1 id="arrayprototypecopywithin"><span class="md-heading"><code class="md-code md-code-inline">Array.prototype.copyWithin</code></span></h1>

<p>This is the most obscure method that got added to <code class="md-code md-code-inline">Array.prototype</code>. I suspect use cases lie around <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Typed_arrays" aria-label="JavaScript typed arrays on MDN">buffers and typed arrays</a> <em>— which we’ll cover at some point, later in the series.</em> The method copies a sequence of array elements <em>within the array</em> to the <em>“paste position”</em> starting at <code class="md-code md-code-inline">target</code>. The elements that should be copied are taken from the <code class="md-code md-code-inline">[start, end)</code> range.</p>

<p>Here’s the signature of the <code class="md-code md-code-inline">copyWithin</code> method. The <code class="md-code md-code-inline">target</code> <em>“paste position”</em> <strong>is required</strong>. The <code class="md-code md-code-inline">start</code> index where to take elements from defaults to <code class="md-code md-code-inline">0</code>. The <code class="md-code md-code-inline">end</code> position defaults to the length of the array.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">Array</span>.<span class="built_in">prototype.copyWithin</span>(target, start <span class="op">=</span> <span class="num">0</span>, end <span class="op">=</span> <span class="kw3">this</span>.<span class="built_in">length</span>)
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Let’s start with a simple example. Consider the <code class="md-code md-code-inline">items</code> array in the snippet below.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">items</span> <span class="op">=</span> [<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, ,,,,,,,]
<span class="com">// &lt;- [1, 2, 3, undefined x 7]</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The method below takes the <code class="md-code md-code-inline">items</code> array and determines that it’ll start <em>“pasting”</em> items in the <strong>sixth position</strong>. It further determines that the items to be copied will be taken starting in the <strong>second position</strong> <em>(zero-based)</em>, until the <strong>third position</strong> <em>(also zero-based)</em>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="var">items</span>.<span class="built_in">copyWithin</span>(<span class="num">6</span>, <span class="num">1</span>, <span class="num">3</span>)
<span class="com">// &lt;- [1, 2, 3, <mark class="md-mark md-code-mark">undefined × 3</mark>, 2, 3, <mark class="md-mark md-code-mark">undefined × 2</mark>]</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->
<blockquote>

<p>Reasoning about this method can be pretty hard. <em>Let’s break it down.</em></p></blockquote>

<p>If we consider that the items to be copied were taken from the <code class="md-code md-code-inline">[start, end)</code> range, then we can express that using the <code class="md-code md-code-inline">.slice</code> operation. These are the items that were <em>“pasted”</em> at the <code class="md-code md-code-inline">target</code> position. We can use <code class="md-code md-code-inline">.slice</code> to <em>“copy”</em> them.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="var">items</span>.<span class="built_in">slice</span>(<span class="num">1</span>, <span class="num">3</span>)
<span class="com">// &lt;- [<mark class="md-mark md-code-mark">2, 3</mark>]</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>We could then consider the “pasting” part of the operation as an advanced usage of <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/splice" aria-label="Array.prototype.splice on MDN"><code class="md-code md-code-inline">.splice</code></a> — one of those lovely methods that can do just about anything. The method below does just that, and then returns <code class="md-code md-code-inline">items</code>, because <code class="md-code md-code-inline">.splice</code> returns the items that were spliced from an Array, and in our case this is no good. Note that we also had to use the <a href="#es6-spread-and-butter-in-depth" aria-label="ES6 Spread and Butter in Depth">spread operator</a> so that elements are inserted individually through <code class="md-code md-code-inline">.splice</code>, and not as an array.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">copyWithin</span> <span class="params">(items, target, start <span class="op">=</span> <span class="num">0</span>, end <span class="op">=</span> items.<span class="built_in">length</span>)</span> </span>{
  <span class="param">items</span>.<span class="built_in">splice</span>(<span class="param">target</span>, <span class="param">end</span> <span class="op">-</span> <span class="param">start</span>, <mark class="md-mark md-code-mark"><span class="op">...</span></mark><span class="param">items</span>.<span class="built_in">slice</span>(<span class="param">start</span>, <span class="param">end</span>))
  <span class="kw3">return</span> <span class="param">items</span>
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Our example would still work the same with this method.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="fn">copyWithin</span>([<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, ,,,,,,,], <span class="num">6</span>, <span class="num">1</span>, <span class="num">3</span>)
<span class="com">// &lt;- [1, 2, 3, undefined × 3, 2, 3, undefined × 2]</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The <code class="md-code md-code-inline">copyWithin</code> method accepts negative <code class="md-code md-code-inline">start</code> indices, negative <code class="md-code md-code-inline">end</code> indices, and negative <code class="md-code md-code-inline">target</code> indices. Let’s try something using that.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, ,,,,,,,].<span class="built_in">copyWithin</span>(-<span class="num">3</span>)
<span class="com">// &lt;- [1, 2, 3, undefined x 4, 1, 2, 3]</span>
<span class="fn">copyWithin</span>([<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, ,,,,,,,], -<span class="num">3</span>)
<span class="com">// &lt;- [1, 2, 3, undefined x 4, 1, 2, 3, <mark class="md-mark md-code-mark">undefined x 7</mark>]</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Turns out, that thought exercise was useful for understanding <code class="md-code md-code-inline">Array.prototype.copyWithin</code>, but it wasn’t actually correct. Why are we seeing <code class="md-code md-code-inline">undefined x 7</code> at the end? Why the discrepancy? The problem is that we are seeing the array holes at the end of <code class="md-code md-code-inline">items</code> when we do <code class="md-code md-code-inline">...items.slice(start, end)</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, ,,,,,,,]
<span class="com">// &lt;- [1, 2, 3, undefined x 7]</span>
[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, ,,,,,,,].<span class="built_in">slice</span>(<span class="num">0</span>, <span class="num">10</span>)
<span class="com">// &lt;- [1, 2, 3, undefined x 7]</span>
<span class="kw4">console.log</span>(<mark class="md-mark md-code-mark"><span class="op">...</span>[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, ,,,,,,,].<span class="built_in">slice</span>(<span class="num">0</span>, <span class="num">10</span>)</mark>)
<span class="com">// &lt;- 1, 2, 3, undefined, undefined, undefined, undefined, undefined, undefined, undefined</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Thus, we <em>end up splicing the holes</em> onto <code class="md-code md-code-inline">items</code>, while the original solution is not. We could get rid of the holes using <code class="md-code md-code-inline">.filter</code>, which conveniently discards array holes.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">
[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, ,,,,,,,].<span class="built_in">slice</span>(<span class="num">0</span>, <span class="num">10</span>)
<span class="com">// &lt;- [1, 2, 3, undefined x 7]</span>
[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, ,,,,,,,].<span class="built_in">slice</span>(<span class="num">0</span>, <span class="num">10</span>)<mark class="md-mark md-code-mark">.<span class="built_in">filter</span>(el <span class="op">=&gt;</span> <span class="md-code-boolean">true</span>)</mark>
<span class="com">// &lt;- [1, 2, 3]</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>With that, we can update our <code class="md-code md-code-inline">copyWithin</code> method. We’ll stop using <code class="md-code md-code-inline">end - start</code> as the splice position and instead use the amount of <code class="md-code md-code-inline">replacements</code> that we have, as those numbers may be different now that we’re discarding array holes.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">copyWithin</span> <span class="params">(items, target, start <span class="op">=</span> <span class="num">0</span>, end <span class="op">=</span> items.<span class="built_in">length</span>)</span> </span>{
  <span class="kw">var</span> <span class="var">replacements</span> <span class="op">=</span> <span class="param">items</span>.<span class="built_in">slice</span>(<span class="param">start</span>, <span class="param">end</span>)<mark class="md-mark md-code-mark">.<span class="built_in">filter</span>(el <span class="op">=&gt;</span> <span class="md-code-boolean">true</span>)</mark>
  <span class="param">items</span>.<span class="built_in">splice</span>(<span class="param">target</span>, <mark class="md-mark md-code-mark"><span class="var">replacements</span>.<span class="built_in">length</span></mark>, <span class="op">...</span><span class="var">replacements</span>)
  <span class="kw3">return</span> <span class="param">items</span>
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The case where we previously added extra holes now works as expected. Woo!</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, ,,,,,,,].<span class="built_in">copyWithin</span>(-<span class="num">3</span>)
<span class="com">// &lt;- [1, 2, 3, undefined x 4, 1, 2, 3]</span>
<span class="fn">copyWithin</span>([<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, ,,,,,,,], -<span class="num">3</span>)
<span class="com">// &lt;- [1, 2, 3, undefined x 4, 1, 2, 3]</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Furthermore, our polyfill seems to work correctly <em>across the board</em> now. I wouldn’t rely on it for anything other than educational purposes, though.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, ,,,,,,,].<span class="built_in">copyWithin</span>(-<span class="num">3</span>, <span class="num">1</span>)
<span class="com">// &lt;- [1, 2, 3, undefined x 4, 2, 3, undefined x 1]</span>
<span class="fn">copyWithin</span>([<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, ,,,,,,,], -<span class="num">3</span>, <span class="num">1</span>)
<span class="com">// &lt;- [1, 2, 3, undefined x 4, 2, 3, undefined x 1]</span>
[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, ,,,,,,,].<span class="built_in">copyWithin</span>(-<span class="num">6</span>, -<span class="num">8</span>)
<span class="com">// &lt;- [1, 2, 3, undefined x 1, 3, undefined x 5]</span>
<span class="fn">copyWithin</span>([<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, ,,,,,,,], -<span class="num">6</span>, -<span class="num">8</span>)
<span class="com">// &lt;- [1, 2, 3, undefined x 1, 3, undefined x 5]</span>
[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, ,,,,,,,].<span class="built_in">copyWithin</span>(-<span class="num">3</span>, <span class="num">1</span>, <span class="num">2</span>)
<span class="com">// &lt;- [1, 2, 3, undefined x 4, 2, undefined x 2]</span>
<span class="fn">copyWithin</span>([<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, ,,,,,,,], -<span class="num">3</span>, <span class="num">1</span>, <span class="num">2</span>)
<span class="com">// &lt;- [1, 2, 3, undefined x 4, 2, undefined x 2]</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>It’s decidedly better to just use the actual implementation, but at least now we have <strong>a better idea of how the hell it works!</strong></p>



<h1 id="arrayprototypefill"><span class="md-heading"><code class="md-code md-code-inline">Array.prototype.fill</code></span></h1>

<p>Convenient utility method to fill all places in an <code class="md-code md-code-inline">Array</code> with the provided <code class="md-code md-code-inline">value</code>. Note that array holes will be filled as well.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="str">'a'</span>, <span class="str">'b'</span>, <span class="str">'c'</span>].<span class="built_in">fill</span>(<span class="num">0</span>)
<span class="com">// &lt;- [0, 0, 0]</span>
<span class="kw">new</span> <span class="kw">Array</span>(<span class="num">3</span>).<span class="built_in">fill</span>(<span class="num">0</span>)
<span class="com">// &lt;- [0, 0, 0]</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>You could also determine a start index and an end index in the second and third parameters respectively.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="str">'a'</span>, <span class="str">'b'</span>, <span class="str">'c'</span>,,,].<span class="built_in">fill</span>(<span class="num">0</span>, <span class="num">2</span>)
<span class="com">// &lt;- ['a', 'b', 0, 0, 0]</span>
<span class="kw">new</span> <span class="kw">Array</span>(<span class="num">5</span>).<span class="built_in">fill</span>(<span class="num">0</span>, <span class="num">0</span>, <span class="num">3</span>)
<span class="com">// &lt;- [0, 0, 0, <mark class="md-mark md-code-mark">undefined x 2</mark>]</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The provided value can be arbitrary, and not necessarily a number or even a primitive type.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">new</span> <span class="kw">Array</span>(<span class="num">3</span>).<span class="built_in">fill</span>({})
<span class="com">// &lt;- [{}, {}, {}]</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Unfortunately, you can’t fill arrays using a mapping method that takes an <code class="md-code md-code-inline">index</code> parameter or anything like that.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">new</span> <span class="kw">Array</span>(<span class="num">3</span>).<span class="built_in">fill</span>(<span class="md-code-function"><span class="kw">function</span> <span class="fn">foo</span> <span class="params">()</span> </span>{})
<span class="com">// &lt;- [function foo () {}, function foo () {}, function foo () {}]</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->

<p><em>Moving along…</em></p>



<h1 id="arrayprototypefind"><span class="md-heading"><code class="md-code md-code-inline">Array.prototype.find</code></span></h1>

<p>Ah. One of those methods that JavaScript desperately wanted but didn’t get in ES5. The <code class="md-code md-code-inline">.find</code> method returns the <em>first</em> <code class="md-code md-code-inline">item</code> that matches <code class="md-code md-code-inline">callback(item, i, array)</code> for an <code class="md-code md-code-inline">array</code> Array. You can also optionally pass in a <code class="md-code md-code-inline">context</code> binding for <code class="md-code md-code-inline">this</code>. You can think of it as an equivalent of <a href="http://ponyfoo.com/articles/fun-with-native-arrays#asserting-with-some-and-every" aria-label="Asserting with .some and .every on Pony Foo"><code class="md-code md-code-inline">.some</code></a> that returns the matching element <em>(or <code class="md-code md-code-inline">undefined</code>)</em> instead of merely <code class="md-code md-code-inline">true</code> or <code class="md-code md-code-inline">false</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>].<span class="built_in">find</span>(item <span class="op">=&gt;</span> item <span class="op">&gt;</span> <span class="num">2</span>)
<span class="com">// &lt;- 3</span>
[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>].<span class="built_in">find</span>((item, i) <span class="op">=&gt;</span> i <span class="op">===</span> <span class="num">3</span>)
<span class="com">// &lt;- 4</span>
[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>].<span class="built_in">find</span>(item <span class="op">=&gt;</span> item <span class="op">===</span> <span class="num">Infinity</span>)
<span class="com">// &lt;- undefined</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>There’s really not much else to say about this method. It’s just that simple! We did want this method a lot, as evidenced in libraries like Lodash and Underscore. Speaking of those libraries… — <code class="md-code md-code-inline">.findIndex</code> was also born there.</p>



<h1 id="arrayprototypefindindex"><span class="md-heading"><code class="md-code md-code-inline">Array.prototype.findIndex</code></span></h1>

<p>This method is also an equivalent of <a href="http://ponyfoo.com/articles/fun-with-native-arrays#asserting-with-some-and-every" aria-label="Asserting with .some and .every on Pony Foo"><code class="md-code md-code-inline">.some</code></a> and <a href="#arrayprototypefind"><code class="md-code md-code-inline">.find</code></a>. Instead of returning <code class="md-code md-code-inline">true</code>, like <code class="md-code md-code-inline">.some</code>; or <code class="md-code md-code-inline">item</code>, like <code class="md-code md-code-inline">.find</code>; this method returns the <code class="md-code md-code-inline">index</code> position so that <code class="md-code md-code-inline">array[index] === item</code>. If none of the elements in the collection match the <code class="md-code md-code-inline">callback(item, i, array)</code> criteria, the return value is <code class="md-code md-code-inline">-1</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>].<span class="built_in">findIndex</span>(item <span class="op">=&gt;</span> item <span class="op">&gt;</span> <span class="num">2</span>)
<span class="com">// &lt;- 2</span>
[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>].<span class="built_in">findIndex</span>((item, i) <span class="op">=&gt;</span> i <span class="op">===</span> <span class="num">3</span>)
<span class="com">// &lt;- 3</span>
[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>].<span class="built_in">findIndex</span>(item <span class="op">=&gt;</span> item <span class="op">===</span> <span class="num">Infinity</span>)
<span class="com">// &lt;- -1</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->

<p>Again, quite straightforward.</p>



<h1 id="arrayprototypekeys"><span class="md-heading"><code class="md-code md-code-inline">Array.prototype.keys</code></span></h1>

<p>Returns an iterator that yields a sequence holding the keys for the array. The returned value is an iterator, meaning you can use it with all of the usual suspects like <a href="#es6-iterators-in-depth" aria-label="ES6 Iterators in Depth"><code class="md-code md-code-inline">for..of</code></a>, the <a href="#es6-spread-and-butter-in-depth" aria-label="ES6 Spread and Butter in Depth">spread operator</a>, or by hand by manually calling <code class="md-code md-code-inline">.next()</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>].<span class="built_in">keys</span>()
<span class="com">// &lt;- ArrayIterator {}</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Here’s an example using <code class="md-code md-code-inline">for..of</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw3">for</span> (<span class="kw">let</span> <span class="var">key</span> <span class="kw">of</span> [<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>].<span class="built_in">keys</span>()) {
  <span class="kw4">console.log</span>(<span class="var">key</span>)
  <span class="com">// &lt;- 0</span>
  <span class="com">// &lt;- 1</span>
  <span class="com">// &lt;- 2</span>
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Unlike <code class="md-code md-code-inline">Object.keys</code> and most methods that iterate over arrays, this sequence doesn’t ignore holes.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">[<mark class="md-mark md-code-mark">...</mark><span class="kw">new</span> <span class="kw">Array</span>(<span class="num">3</span>)<mark class="md-mark md-code-mark">.<span class="built_in">keys</span>()</mark>]
<span class="com">// &lt;- [0, 1, 2]</span>
<span class="cls">Object</span>.<span class="built_in">keys</span>(<span class="kw">new</span> <span class="kw">Array</span>(<span class="num">3</span>))
<span class="com">// &lt;- []</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->

<p>Now onto values.</p>



<h1 id="arrayprototypevalues"><span class="md-heading"><code class="md-code md-code-inline">Array.prototype.values</code></span></h1>

<p>Same thing as <code class="md-code md-code-inline">.keys()</code>, but the returned iterator is a sequence of values instead of indices. In practice, you’ll probably just iterate over the array itself, but sometimes getting an iterator can come in handy.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>].<span class="built_in">values</span>()
<span class="com">// &lt;- ArrayIterator {}</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Then you can use <code class="md-code md-code-inline">for..of</code> or any other methods like a spread operator to pull out the sequence. The example below shows how using the spread operator on an array’s <code class="md-code md-code-inline">.values()</code> doesn’t really make a lot of sense <em>— you already had that collection to begin with!</em></p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">[<mark class="md-mark md-code-mark">...</mark>[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>]<mark class="md-mark md-code-mark">.<span class="built_in">values</span>()</mark>]
<span class="com">// &lt;- [1, 2, 3]</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Do note that the returned array in the example above is <em>a different array</em> and not a reference to the original one.</p><blockquote>

<p>Time for <code class="md-code md-code-inline">.entries</code>.</p></blockquote>



<h1 id="arrayprototypeentries"><span class="md-heading"><code class="md-code md-code-inline">Array.prototype.entries</code></span></h1>

<p>Similar to both preceding methods, but this one returns an iterator with a sequence of key-value pairs.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="str">'a'</span>, <span class="str">'b'</span>, <span class="str">'c'</span>].<span class="built_in">entries</span>()
<span class="com">// &lt;- ArrayIterator {}</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Each entry contains a two dimensional array element with the key and the value for an item in the array.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="op">...</span>[<span class="str">'a'</span>, <span class="str">'b'</span>, <span class="str">'c'</span>].<span class="built_in">entries</span>()]
<span class="com">// &lt;- [[0, 'a'], [1, 'b'], [2, 'c']]</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Great, last one to go!</p>



<h1 id="arrayprototype-symboliterator"><span class="md-heading"><code class="md-code md-code-inline">Array.prototype[Symbol.iterator]</code></span></h1>

<p>This is <del>basically</del> <ins><strong>exactly</strong></ins> the same as the <a href="#arrayprototypevalues"><code class="md-code md-code-inline">.values</code></a> method. The example below combines a spread operator, an array, and <code class="md-code md-code-inline">Symbol.iterator</code> to iterate over its values.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">[<mark class="md-mark md-code-mark">...</mark>[<span class="str">'a'</span>, <span class="str">'b'</span>, <span class="str">'c'</span>]<mark class="md-mark md-code-mark">[<span class="md-code-symbol">Symbol</span>.<span class="built_in">iterator</span>]()</mark>]
<span class="com">// &lt;- ['a', 'b', 'c']</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Of course, you should probably just omit the spread operator and the <code class="md-code md-code-inline">[Symbol.iterator]</code> part in most use cases. Same time tomorrow? We’ll cover changes to the <code class="md-code md-code-inline">Object</code> API.</p></section></section>
</article>
</div>
<p><a href="#top" class="top"><img src="./auxi/glyphicons-214-up-arrow.png" alt="up-arrow" class="uparrow" /> <b>Back to top</b></a></p>
</section></main>

<!--  array ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->
<!--  ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->









<!--  object ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->

<main class="ly-main"><header class="at-header">



<h1 itemprop="headline" class="dc-title" id="es6-object-changes-in-depth">ES6 Object Changes in Depth</h1></header>

<section class="at-teaser"><div class="at-teaser-markdown md-markdown">

<p>Howdy. You’re reading ES6 — <em>“I vehemently <code class="md-code md-code-inline">Object</code> to come up with a better tagline”</em> — in Depth series. If you’ve never been around here before, start with <a href="#a-brief-history-of-es6-tooling">A Brief History of ES6 Tooling</a>. Then, make your way through <a href="#es6-destructuring-in-depth">destructuring</a>, <a href="#es6-template-strings-in-depth">template literals</a>, <a href="#es6-arrow-functions-in-depth">arrow functions</a>, the <a href="#es6-spread-and-butter-in-depth">spread operator and rest parameters</a>, improvements coming to <a href="#es6-object-literal-features-in-depth">object literals</a>, the new <a href="#es6-classes-in-depth"><em>classes</em></a> sugar on top of prototypes, <a href="#es6-let-const-and-temporal-dead-zone-in-depth"><code class="md-code md-code-inline">let</code>, <code class="md-code md-code-inline">const</code>, and the <em>“Temporal Dead Zone”</em></a>, <a href="#es6-iterators-in-depth">iterators</a>, <a href="#es6-generators-in-depth">generators</a>, <a href="#es6-symbols-in-depth">Symbols</a>, <a href="#es6-maps-in-depth">Maps</a>, <a href="#es6-weakmaps-sets-and-weaksets-in-depth">WeakMaps, Sets, and WeakSets</a>, <a href="#es6-proxies-in-depth">proxies</a>, <a href="#es6-proxy-traps-in-depth">proxy traps</a>, <a href="#more-es6-proxy-traps-in-depth">more proxy traps</a>, <a href="#es6-reflection-in-depth">reflection</a>, <a href="#es6-number-improvements-in-depth"><code class="md-code md-code-inline">Number</code></a>, <a href="#es6-math-additions-in-depth"><code class="md-code md-code-inline">Math</code></a>, and <a href="#es6-array-extensions-in-depth"><code class="md-code md-code-inline">Array</code></a>. Today we’ll learn about changes to <code class="md-code md-code-inline">Object</code>.</p></div></section>

<section class="at-container de-host"><div class="de-column">

<article itemscope="itemscope" itemtype="http://schema.org/BlogPosting" class="at-article ly-section">
<meta itemprop="dateCreated" content="2015-09-12T16:14:44+00:00" />
<meta itemprop="datePublished" content="2015-09-23T13:12:01+00:00" />
<meta itemprop="dateModified" content="2015-10-11T04:06:38+00:00" />
<meta itemprop="keywords" content="es6,object,es6-in-depth" />

<section itemprop="articleBody" class="at-corpus">

<section itemprop="about" class="md-markdown at-introduction"><blockquote>

<p>As I did in previous articles on the series, I would love to point out that you should probably <a href="#universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That’ll make it so much easier for you to <strong>internalize the concepts</strong> discussed in the series. If you aren’t the <em>“install things on my computer”</em> kind of human, you might prefer to hop on <a href="http://codepen.io/">CodePen</a> and then click on the gear icon for JavaScript — <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em> Another alternative that’s also quite useful is to use Babel’s <a href="http://babeljs.io/repl/">online REPL</a> <em>— it’ll show you compiled ES5 code to the right of your ES6 code for quick comparison.</em></p></blockquote>

<p>Before getting into it, let me <a href="https://www.patreon.com/bevacqua"><em>shamelessly ask for your support</em></a> if you’re enjoying my ES6 in Depth series. Your contributions will go towards helping me keep up with the schedule, server bills, keeping me fed, and maintaining <strong>Pony Foo</strong> as a veritable source of JavaScript goodies.</p>

<p>Thanks for reading that, and let’s go into changes to <code class="md-code md-code-inline">Object</code>. Make sure to read some of the articles from earlier in the series to get comfortable with ES6 syntax changes.</p></section>

<section class="md-markdown at-body">



<h1 id="upcoming-object-changes"><span class="md-heading">Upcoming <code class="md-code md-code-inline">Object</code> Changes</span></h1>

<p>Objects didn’t get as many new methods in ES6 as <a href="#es6-array-extensions-in-depth" aria-label="ES6 Array Extensions in Depth">arrays did</a>. In the case of objects, we get four new static methods, and no new instance methods or properties.</p><ul>
  <li><a href="#objectassign"><code class="md-code md-code-inline">Object.assign</code></a></li>
  <li><a href="#objectis"><code class="md-code md-code-inline">Object.is</code></a></li>
  <li><a href="#objectgetownpropertysymbols"><code class="md-code md-code-inline">Object.getOwnPropertySymbols</code></a></li>
  <li><a href="#objectsetprototypeof"><code class="md-code md-code-inline">Object.setPrototypeOf</code></a></li></ul>

<p>And just like arrays, objects are slated to get a few more static methods in ES2016 <em>(ES7)</em>. We’re not going to cover these today.</p><ul>
  <li><code class="md-code md-code-inline">Object.observe</code></li>
  <li><code class="md-code md-code-inline">Object.unobserve</code></li></ul>

<p><em>Shall we?</em></p>



<h1 id="objectassign"><span class="md-heading"><code class="md-code md-code-inline">Object.assign</code></span></h1>

<p>This is another example of the kind of helper method that has been beaten to death by libraries like Underscore and Lodash. I even wrote my own implementation that’s <a href="https://github.com/bevacqua/assignment/blob/master/assignment.js" aria-label="bevacqua/assignment on GitHub">around 20 lines of code</a>. You can use <code class="md-code md-code-inline">Object.assign</code> to recursively overwrite properties on an object with properties from other objects. The first argument passed to <code class="md-code md-code-inline">Object.assign</code>, <code class="md-code md-code-inline">target</code>, will be <em>used as the return value as well.</em> Subsequent values are <em>“applied”</em> onto that object.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="cls">Object</span>.<span class="built_in">assign</span>(<mark class="md-mark md-code-mark">{}</mark>, { a: <span class="num">1</span> })
<span class="com">// &lt;- <mark class="md-mark md-code-mark">{ a: 1 }</mark></span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>If you already had a property, it’s overwritten.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="cls">Object</span>.<span class="built_in">assign</span>(<mark class="md-mark md-code-mark">{ a: <span class="num">1</span> }</mark>, { a: <span class="num">2</span> })
<span class="com">// &lt;- <mark class="md-mark md-code-mark">{ a: 2 }</mark></span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Properties that aren’t present in the object being assigned are left untouched.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="cls">Object</span>.<span class="built_in">assign</span>(<mark class="md-mark md-code-mark">{ a: <span class="num">1</span>, b: <span class="num">2</span> }</mark>, { a: <span class="num">3</span> })
<span class="com">// &lt;- <mark class="md-mark md-code-mark">{ a: 3, b: 2 }</mark></span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>You can assign as many objects as you want. You can think of <code class="md-code md-code-inline">Object.assign(a, b, c)</code> as the equivalent of doing <code class="md-code md-code-inline">Object.assign(Object.assign(a, b), c)</code>, if that makes it easier for you to reason about it. I like to reason about it as a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" aria-label="Array.prototype.reduce on MDN">reduce</a> operation.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="cls">Object</span>.<span class="built_in">assign</span>(<mark class="md-mark md-code-mark">{ a: <span class="num">1</span>, b: <span class="num">2</span> }</mark>, { a: <span class="num">3</span> }, { c: <span class="num">4</span> })
<span class="com">// &lt;- <mark class="md-mark md-code-mark">{ a: 3, b: 2, c: 4 }</mark></span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Note that only enumerable own properties are copied over <em>— think <code class="md-code md-code-inline">Object.keys</code> plus <code class="md-code md-code-inline">Object.getOwnPropertySymbols</code>.</em> The example below shows an <code class="md-code md-code-inline">invisible</code> property that didn’t get copied over. Properties from the prototype chain aren’t taken into account either.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">a</span> <span class="op">=</span> { b: <span class="str">'c'</span> }
<span class="cls">Object</span>.<span class="built_in">defineProperty</span>(<span class="var">a</span>, <span class="str">'invisible'</span>, { <mark class="md-mark md-code-mark">enumerable: <span class="bool">false</span></mark>, value: <span class="str">'boo! ahhh!'</span> })
<span class="cls">Object</span>.<span class="built_in">assign</span>(<mark class="md-mark md-code-mark">{}</mark>, <span class="var">a</span>)
<span class="com">// &lt;- <mark class="md-mark md-code-mark">{ b: 'c' }</mark></span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>You can use this API against arrays as well.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="cls">Object</span>.<span class="built_in">assign</span>(<mark class="md-mark md-code-mark">[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>]</mark>, [<span class="num">4</span>, <span class="num">5</span>])
<span class="com">// &lt;- <mark class="md-mark md-code-mark">[4, 5, 3]</mark></span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Properties using symbols as their keys are also copied over.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="cls">Object</span>.<span class="built_in">assign</span>(<mark class="md-mark md-code-mark">{ a: <span class="str">'b'</span> }</mark>, { [<span class="md-code-symbol">Symbol</span>(<span class="str">'c'</span>)]: <span class="str">'d'</span> })
<span class="com">// &lt;- <mark class="md-mark md-code-mark">{ a: 'b', Symbol(c): 'd' }</mark></span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>As long as they’re enumerable and found directly on the object, that is.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">a</span> <span class="op">=</span> {}
<span class="cls">Object</span>.<span class="built_in">defineProperty</span>(<span class="var">a</span>, <mark class="md-mark md-code-mark"><span class="symbol">Symbol</span>(<span class="str">'b'</span>)</mark>, { <mark class="md-mark md-code-mark">enumerable: <span class="bool">false</span></mark>, value: <span class="str">'c'</span> })
<span class="cls">Object</span>.<span class="built_in">assign</span>(<mark class="md-mark md-code-mark">{}</mark>, <span class="var">a</span>)
<span class="com">// &lt;- <mark class="md-mark md-code-mark">{}</mark></span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>There’s a problem with <code class="md-code md-code-inline">Object.assign</code>. It doesn’t allow you to control how deep you want to go. You may be hoping for a way to do the following while preserving the <code class="md-code md-code-inline">target.a.d</code> property, but <code class="md-code md-code-inline">Object.assign</code> replaces <code class="md-code md-code-inline">target.a</code> entirely with <code class="md-code md-code-inline">source.a</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">target</span> <span class="op">=</span> { a: { b: <span class="str">'c'</span>, d: <span class="str">'e'</span> } }
<span class="kw">var</span> <span class="var">source</span> <span class="op">=</span> { a: { b: <span class="str">'ahh!'</span> } }
<span class="cls">Object</span>.<span class="built_in">assign</span>(<span class="var">target</span>, <span class="var">source</span>)
<span class="com">// &lt;- <mark class="md-mark md-code-mark">{ a: { b: 'ahh!' } }</mark></span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Most implementations in the wild work differently, at least giving you <em>the option</em> to make a <em>“deep assign”</em>. Take <code class="md-code md-code-inline">assignment</code> for instance. If it finds an object reference in <code class="md-code md-code-inline">target</code> for a given property, it has two options.</p><ul>
  <li>If the value in <code class="md-code md-code-inline">source[key]</code> is an object, it goes recursive with an <code class="md-code md-code-inline">assignment(target[key], source[key])</code> call</li>
  <li>If the value is not an object, it just replaces it: <code class="md-code md-code-inline">target[key] <span class="op">=</span> source[key]</code></li></ul>

<p>This means that the last example we saw would work differently with <code class="md-code md-code-inline">assignment</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">target</span> <span class="op">=</span> { a: { b: <span class="str">'c'</span>, d: <span class="str">'e'</span> } }
<span class="kw">var</span> <span class="var">source</span> <span class="op">=</span> { a: { b: <span class="str">'ahh!'</span> } }
assignment(target, source)
<span class="com">// &lt;- { a: { b: 'ahh!', <mark class="md-mark md-code-mark">d: 'e'</mark> } }</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>This is <strong>usually preferred</strong> when it comes to the most common use case of this type of method: providing sensible defaults that can be overwritten by the user. Consider the following example. It uses the well-known pattern of providing your <em>“assign”</em> method with an empty object, that’s then filled with default values, and then poured user preferences for good measure. Note that it doesn’t change the defaults object directly because those are supposed to stay the same across invocations.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">markdownEditor</span> <span class="params">(user)</span> </span>{
  <span class="kw">var</span> <span class="var">defaults</span> <span class="op">=</span> {
    height: <span class="num">400</span>,
    markdown: {
      githubFlavored: <span class="md-code-boolean">true</span>,
      tables: <span class="md-code-boolean">false</span>
    }
  }
  <span class="kw">var</span> <span class="var">options</span> <span class="op">=</span> <mark class="md-mark md-code-mark"><span class="cls">Object</span>.<span class="built_in">assign</span>({}, <span class="var">defaults</span>, <span class="var">user</span>)</mark>
  <span class="kw4">console.log</span>(<span class="var">options</span>)
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The problem with <code class="md-code md-code-inline">Object.assign</code> is that if the <code class="md-code md-code-inline">markdownEditor</code> consumer wants to change <code class="md-code md-code-inline">markdown.tables</code> to <code class="md-code md-code-inline">true</code>, all of the other defaults in <code class="md-code md-code-inline">markdown</code> will be lost!</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">markdownEditor({ markdown: { tables: <span class="md-code-boolean">true</span> } })
<span class="com">// &lt;- {</span>
<span class="com">//      height: 400,</span>
<span class="com">//      markdown: {</span>
<span class="com">//        tables: true</span>
<span class="com">//      }</span>
<span class="com">//    }</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>From both the library author’s perspective and the library’s user perspective, this is just unacceptable and weird. If we were to use <code class="md-code md-code-inline">assignment</code> we wouldn’t be having those issues, because <code class="md-code md-code-inline">assignment</code> is built with this particular use case in mind. Libraries like Lodash usually provide <a href="https://lodash.com/docs#defaultsDeep" aria-label="See .assign, .defaults, and .defaultsDeep on their documentation">many different flavors</a> of this method.</p>

<p>Note that when it comes to nested arrays, <strong>replacement</strong> <em>probably is</em> the behavior you want most of the time. Given defaults like <code class="md-code md-code-inline">{ extensions: ['css', 'js', 'html'] }</code>, the following would be quite weird.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">markdownEditor({ extensions: [<span class="str">'js'</span>] })
<span class="com">// &lt;- { extensions: ['js', <mark class="md-mark md-code-mark">'js', 'html'</mark>] }</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>For that reason, <a href="https://github.com/bevacqua/assignment/blob/master/assignment.js" aria-label="bevacqua/assignment on GitHub"><code class="md-code md-code-inline">assignment</code></a> replaces arrays entirely, just like <code class="md-code md-code-inline">Object.assign</code> would. This difference <strong>doesn’t</strong> make <code class="md-code md-code-inline">Object.assign</code> useless, but it’s still necessary to know about the difference between shallow and deep assignment.</p>



<h1 id="objectis"><span class="md-heading"><code class="md-code md-code-inline">Object.is</code></span></h1>

<p>This method is pretty much a programmatic way to use the <code class="md-code md-code-inline">===</code> operator. You pass in two arguments and it tells you whether they’re the same reference or the same primitive value.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="cls">Object</span>.<span class="built_in">is</span>(<span class="str">'foo'</span>, <span class="str">'foo'</span>)
<span class="com">// &lt;- true</span>
<span class="cls">Object</span>.<span class="built_in">is</span>({}, {})
<span class="com">// &lt;- false</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>There are <strong>two important differences</strong>, however. First off, <code class="md-code md-code-inline">-0</code> and <code class="md-code md-code-inline">+0</code> are considered unequal by this method, even though <code class="md-code md-code-inline">===</code> returns <code class="md-code md-code-inline">true</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="op">-</span><span class="num">0</span> <span class="op">===</span> <span class="op">+</span><span class="num">0</span>
<span class="com">// &lt;- true</span>
<span class="cls">Object</span>.<span class="built_in">is</span>(<span class="op">-</span><span class="num">0</span>, <span class="op">+</span><span class="num">0</span>)
<span class="com">// &lt;- <mark class="md-mark md-code-mark">false</mark></span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The other difference is when it comes to <code class="md-code md-code-inline">NaN</code>. The <code class="md-code md-code-inline">Object.is</code> method treats <code class="md-code md-code-inline">NaN</code> as equal to <code class="md-code md-code-inline">NaN</code>. This is a behavior we’ve <a href="#es6-maps-in-depth" aria-label="ES6 Maps in Depth">already observed in maps and sets</a>, which also treats <code class="md-code md-code-inline">NaN</code> as being the same value as <code class="md-code md-code-inline">NaN</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-nan">NaN</span> <span class="op">===</span> <span class="md-code-nan">NaN</span>
<span class="com">// &lt;- false</span>
<span class="cls">Object</span>.<span class="built_in">is</span>(<span class="md-code-nan">NaN</span>, <span class="md-code-nan">NaN</span>)
<span class="com">// &lt;- <mark class="md-mark md-code-mark">true</mark></span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>While this may be convenient in some cases, I’d probably go for the more explicit <a href="#es6-number-improvements-in-depth#numberisnan" aria-label="ES6 Number Improvements in Depth"><code class="md-code md-code-inline">Number.isNaN</code></a> most of the time.</p>



<h1 id="objectgetownpropertysymbols"><span class="md-heading"><code class="md-code md-code-inline">Object.getOwnPropertySymbols</code></span></h1>

<p>This method returns all own property symbols found on an object.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">a</span> <span class="op">=</span> {
  [<span class="md-code-symbol">Symbol</span>(<span class="str">'b'</span>)]: <span class="str">'c'</span>,
  [<span class="md-code-symbol">Symbol</span>(<span class="str">'d'</span>)]: <span class="str">'e'</span>,
  <span class="str">'f'</span>: <span class="str">'g'</span>,
  <span class="str">'h'</span>: <span class="str">'i'</span>
}
<span class="cls">Object</span>.<span class="built_in">getOwnPropertySymbols</span>(a)
<span class="com">// &lt;- <mark class="md-mark md-code-mark">[<span class="md-code-symbol">Symbol</span>(b), Symbol(d)]</mark></span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>We’ve already covered <code class="md-code md-code-inline">Object.getOwnPropertySymbols</code> in depth in the <a href="#es6-symbols-in-depth" aria-label="ES6 Symbols in Depth">symbols dossier</a>. If I were you, I’d read it!</p>



<h1 id="objectsetprototypeof"><span class="md-heading"><code class="md-code md-code-inline">Object.setPrototypeOf</code></span></h1>

<p>Again, something we’ve covered earlier in the series. One of the articles about <a href="#more-es6-proxy-traps-in-depth#setprototypeof" aria-label=".setPrototypeOf is in the More ES6 Proxy Traps in Depth article on Pony Foo">proxy traps</a> covers this method tangentially. You can use <code class="md-code md-code-inline">Object.setPrototypeOf</code> to change the prototype of an object.</p>

<p>It is, in fact, the equivalent of setting <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto" aria-label="Object.prototype.__proto__ on MDN"><code class="md-code md-code-inline">__proto__</code></a> on runtimes that have that property.</p></section></section>
</article>
</div>
<p><a href="#top" class="top"><img src="./auxi/glyphicons-214-up-arrow.png" alt="up-arrow" class="uparrow" /> <b>Back to top</b></a></p>
</section></main>

<!--  object ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->
<!--  ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->









<!--  strings ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->

<main class="ly-main"><header class="at-header">



<h1 itemprop="headline" class="dc-title"id="es6-strings-and-unicode-in-depth">ES6 Strings (and Unicode, ❤) in Depth</h1></header>

<section class="at-teaser"><div class="at-teaser-markdown md-markdown">

<p>Yo. Here’s another edition of ES6 — <em>“I can’t believe they killed off Stringer Bell”</em> — in Depth series. If you’ve never been around here before, start with <a href="#a-brief-history-of-es6-tooling">A Brief History of ES6 Tooling</a>. Then, make your way through <a href="#es6-destructuring-in-depth">destructuring</a>, <a href="#es6-template-strings-in-depth">template literals</a>, <a href="#es6-arrow-functions-in-depth">arrow functions</a>, the <a href="#es6-spread-and-butter-in-depth">spread operator and rest parameters</a>, improvements coming to <a href="#es6-object-literal-features-in-depth">object literals</a>, the new <a href="#es6-classes-in-depth"><em>classes</em></a> sugar on top of prototypes, <a href="#es6-let-const-and-temporal-dead-zone-in-depth"><code class="md-code md-code-inline">let</code>, <code class="md-code md-code-inline">const</code>, and the <em>“Temporal Dead Zone”</em></a>, <a href="#es6-iterators-in-depth">iterators</a>, <a href="#es6-generators-in-depth">generators</a>, <a href="#es6-symbols-in-depth">Symbols</a>, <a href="#es6-maps-in-depth">Maps</a>, <a href="#es6-weakmaps-sets-and-weaksets-in-depth">WeakMaps, Sets, and WeakSets</a>, <a href="#es6-proxies-in-depth">proxies</a>, <a href="#es6-proxy-traps-in-depth">proxy traps</a>, <a href="#more-es6-proxy-traps-in-depth">more proxy traps</a>, <a href="#es6-reflection-in-depth">reflection</a>, <a href="#es6-number-improvements-in-depth"><code class="md-code md-code-inline">Number</code></a>, <a href="#es6-math-additions-in-depth"><code class="md-code md-code-inline">Math</code></a>, <a href="#es6-array-extensions-in-depth"><code class="md-code md-code-inline">Array</code></a>, and <a href="#es6-object-changes-in-depth"><code class="md-code md-code-inline">Object</code></a>. Today we’ll be serving updates to the <code class="md-code md-code-inline">String</code> object coming in ES6.</p></div></section>

<section class="at-container de-host"><div class="de-column">

<article itemscope="itemscope" itemtype="http://schema.org/BlogPosting" class="at-article ly-section">
<meta itemprop="dateCreated" content="2015-09-14T03:32:27+00:00" />
<meta itemprop="datePublished" content="2015-09-24T12:30:03+00:00" />
<meta itemprop="dateModified" content="2015-10-11T04:06:38+00:00" />
<meta itemprop="keywords" content="es6,string,unicode,es6-in-depth" />

<section itemprop="articleBody" class="at-corpus">

<section itemprop="about" class="md-markdown at-introduction"><blockquote>

<p>As I did in previous articles on the series, I would love to point out that you should probably <a href="#universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That’ll make it so much easier for you to <strong>internalize the concepts</strong> discussed in the series. If you aren’t the <em>“install things on my computer”</em> kind of human, you might prefer to hop on <a href="http://codepen.io/">CodePen</a> and then click on the gear icon for JavaScript — <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em> Another alternative that’s also quite useful is to use Babel’s <a href="http://babeljs.io/repl/">online REPL</a> <em>— it’ll show you compiled ES5 code to the right of your ES6 code for quick comparison.</em></p></blockquote>

<p>Before getting into it, let me <a href="https://www.patreon.com/bevacqua"><em>shamelessly ask for your support</em></a> if you’re enjoying my ES6 in Depth series. Your contributions will go towards helping me keep up with the schedule, server bills, keeping me fed, and maintaining <strong>Pony Foo</strong> as a veritable source of JavaScript goodies.</p>

<p>Thanks for reading that, and let’s go into updates to the <code class="md-code md-code-inline">String</code> object.</p></section>

<section class="md-markdown at-body">



<h1 id="updates-to-string"><span class="md-heading">Updates to <code class="md-code md-code-inline">String</code></span></h1>

<p>We’ve already covered <a href="#es6-template-strings-in-depth" aria-label="ES6 Template Literals in Depth">template literals</a> earlier in the series, and you may recall that those can be used to mix strings and variables to produce string output.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">greet</span> <span class="params">(name)</span> </span>{
  <span class="kw3">return</span> <span class="str">`hello ${name}!`</span>
}
<span class="fn">greet</span>(<span class="str">'ponyfoo'</span>)
<span class="com">// &lt;- 'hello ponyfoo!'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Besides template literals, strings are getting a numbre of new methods come ES6. These can be categorized as string manipulation methods and unicode related methods.</p><ul>
  <li>String Manipulation<ul>
  <li><a href="#stringprototypestartswith"><code class="md-code md-code-inline">String.prototype.startsWith</code></a></li>
  <li><a href="#stringprototypeendswith"><code class="md-code md-code-inline">String.prototype.endsWith</code></a></li>
  <li><a href="#stringprototypeincludes"><code class="md-code md-code-inline">String.prototype.includes</code></a></li>
  <li><a href="#stringprototyperepeat"><code class="md-code md-code-inline">String.prototype.repeat</code></a></li>
  <li><a href="#stringprototype-symboliterator"><code class="md-code md-code-inline">String.prototype[Symbol.iterator]</code></a></li></ul></li>
  <li><a href="#unicode">Unicode</a><ul>
  <li><a href="#stringprototypecodepointat"><code class="md-code md-code-inline">String.prototype.codePointAt</code></a></li>
  <li><a href="#stringfromcodepoint%60"><code class="md-code md-code-inline">String.fromCodePoint</code></a></li>
  <li><a href="#stringprototypenormalize"><code class="md-code md-code-inline">String.prototype.normalize</code></a></li></ul></li></ul>

<p>We’ll begin with the string manipulation methods and then we’ll take a look at the unicode related ones.</p>



<h1 id="stringprototypestartswith"><span class="md-heading"><code class="md-code md-code-inline">String.prototype.startsWith</code></span></h1>

<p>A very common question in our code is <em>“does this string start with this other string?”</em>. In ES5 we’d ask that question using the <code class="md-code md-code-inline">.indexOf</code> method.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="str">'ponyfoo'</span>.<span class="built_in">indexOf</span>(<span class="str">'foo'</span>)
<span class="com">// &lt;- 4</span>
<span class="str">'ponyfoo'</span>.<span class="built_in">indexOf</span>(<span class="str">'pony'</span>)
<span class="com">// &lt;- 0</span>
<span class="str">'ponyfoo'</span>.<span class="built_in">indexOf</span>(<span class="str">'horse'</span>)
<span class="com">// &lt;- -1</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>If you wanted to check if a string started with another one, you’d compare them with <code class="md-code md-code-inline">.indexOf</code> and check whether the <em>“needle”</em> starts at the <code class="md-code md-code-inline">0</code> position — the beginning of the string.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="str">'ponyfoo'</span>.<span class="built_in">indexOf</span>(<span class="str">'pony'</span>) <mark class="md-mark md-code-mark"><span class="op">===</span> <span class="num">0</span></mark>
<span class="com">// &lt;- true</span>
<span class="str">'ponyfoo'</span>.<span class="built_in">indexOf</span>(<span class="str">'foo'</span>) <span class="op">===</span> <span class="num">0</span>
<span class="com">// &lt;- false</span>
<span class="str">'ponyfoo'</span>.<span class="built_in">indexOf</span>(<span class="str">'horse'</span>) <span class="op">===</span> <span class="num">0</span>
<span class="com">// &lt;- false</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>You can now use the more descriptive and terse <code class="md-code md-code-inline">.startsWith</code> method instead.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="str">'ponyfoo'</span><mark class="md-mark md-code-mark">.<span class="built_in">startsWith</span></mark>(<span class="str">'pony'</span>)
<span class="com">// &lt;- true</span>
<span class="str">'ponyfoo'</span><mark class="md-mark md-code-mark">.<span class="built_in">startsWith</span></mark>(<span class="str">'foo'</span>)
<span class="com">// &lt;- false</span>
<span class="str">'ponyfoo'</span><mark class="md-mark md-code-mark">.<span class="built_in">startsWith</span></mark>(<span class="str">'horse'</span>)
<span class="com">// &lt;- false</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>If you wanted to figure out whether a string contains another one starting in a specific location, it would get quite verbose, as you’d need to grab a slice of that string first.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="str">'ponyfoo'</span><mark class="md-mark md-code-mark">.<span class="built_in">slice</span>(<span class="num">4</span>)</mark>.<span class="built_in">indexOf</span>(<span class="str">'foo'</span>) <span class="op">===</span> <span class="num">0</span>
<span class="com">// &lt;- true</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The reason why you can’t just ask <code class="md-code md-code-inline">=== 4</code> is that this would give you false negatives when the query is found before reaching that index.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="str">'foo,<mark class="md-mark md-code-mark">foo</mark>'</span>.<span class="built_in">indexOf</span>(<span class="str">'foo'</span>) <span class="op">===</span> <span class="num">4</span>
<span class="com">// &lt;- <mark class="md-mark md-code-mark">false</mark>, because result was <mark class="md-mark md-code-mark">0</mark></span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Of course, you could use the <code class="md-code md-code-inline">startIndex</code> parameter for <code class="md-code md-code-inline">indexOf</code> to get around that. Note that we’re still comparing against <code class="md-code md-code-inline">4</code> in this case, because the string wasn’t split into smaller parts.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="str">'foo,foo'</span>.<span class="built_in">indexOf</span>(<span class="str">'foo'</span>, <mark class="md-mark md-code-mark"><span class="num">4</span></mark>) <span class="op">===</span> <mark class="md-mark md-code-mark"><span class="num">4</span></mark>
<span class="com">// &lt;- true</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Instead of keeping all of these string searching implementation details in your head and writing code that worries too much about the how and not so much about the what, you could just use <code class="md-code md-code-inline">startsWith</code> passing in the optional <code class="md-code md-code-inline">startIndex</code> parameter as well.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="str">'foo,foo'</span><mark class="md-mark md-code-mark">.<span class="built_in">startsWith</span></mark>(<span class="str">'foo'</span>, <mark class="md-mark md-code-mark"><span class="num">4</span></mark>)
<span class="com">// &lt;- true</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Then again, it’s kind of confusing that the method is called <code class="md-code md-code-inline">.startsWith</code> but we’re starting at a non-zero index — that being said it sure beats using <code class="md-code md-code-inline">.indexOf</code> when we actually want a boolean result.</p>



<h1 id="stringprototypeendswith"><span class="md-heading"><code class="md-code md-code-inline">String.prototype.endsWith</code></span></h1>

<p>This method mirrors <code class="md-code md-code-inline">.startsWith</code> in the same way that <code class="md-code md-code-inline">.lastIndexOf</code> mirrors <code class="md-code md-code-inline">.indexOf</code>. It tells us whether a string ends with another string.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="str">'ponyfoo'</span>.<span class="built_in">endsWith</span>(<span class="str">'foo'</span>)
<span class="com">// &lt;- true</span>
<span class="str">'ponyfoo'</span>.<span class="built_in">endsWith</span>(<span class="str">'pony'</span>)
<span class="com">// &lt;- false</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Just like <code class="md-code md-code-inline">.startsWith</code>, we have a position index that indicates where the lookup should end. It defaults to the length of the string.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="str">'ponyfoo'</span>.<span class="built_in">endsWith</span>(<span class="str">'foo'</span>, <span class="num">7</span>)
<span class="com">// &lt;- true</span>
<span class="str">'ponyfoo'</span>.<span class="built_in">endsWith</span>(<span class="str">'pony'</span>, <span class="num">0</span>)
<span class="com">// &lt;- false</span>
<span class="str">'ponyfoo'</span>.<span class="built_in">endsWith</span>(<span class="str">'pony'</span>, <span class="num">4</span>)
<span class="com">// &lt;- true</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->

<p>Yet another method that simplifies a specific use case for <code class="md-code md-code-inline">.indexOf</code> is <code class="md-code md-code-inline">.includes</code>.</p>



<h1 id="stringprototypeincludes"><span class="md-heading"><code class="md-code md-code-inline">String.prototype.includes</code></span></h1>

<p>You can use <code class="md-code md-code-inline">.includes</code> to figure out whether a string contains another one.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="str">'ponyfoo'</span><mark class="md-mark md-code-mark">.<span class="built_in">includes</span></mark>(<span class="str">'ny'</span>)
<span class="com">// &lt;- true</span>
<span class="str">'ponyfoo'</span>.<span class="built_in">includes</span>(<span class="str">'sf'</span>)
<span class="com">// &lt;- false</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>This is equivalent to the ES5 use case of <code class="md-code md-code-inline">.indexOf</code> where we’d compare its results with <code class="md-code md-code-inline">-1</code> to see if the search string was anywhere to be found.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="str">'ponyfoo'</span><mark class="md-mark md-code-mark">.<span class="built_in">indexOf</span></mark>(<span class="str">'ny'</span>) <mark class="md-mark md-code-mark"><span class="op">!== -</span><span class="num">1</span></mark>
<span class="com">// &lt;- true</span>
<span class="str">'ponyfoo'</span><mark class="md-mark md-code-mark">.<span class="built_in">indexOf</span></mark>(<span class="str">'sf'</span>) <mark class="md-mark md-code-mark"><span class="op">!== -</span><span class="num"><span class="num">1</span></span></mark>
<span class="com">// &lt;- false</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Naturally you can also pass in a start index where the search should begin.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="str">'ponyfoo'</span>.<span class="built_in">includes</span>(<span class="str">'ny'</span>, <mark class="md-mark md-code-mark"><span class="num">3</span></mark>)
<span class="com">// &lt;- false</span>
<span class="str">'ponyfoo'</span>.<span class="built_in">includes</span>(<span class="str">'ny'</span>, <mark class="md-mark md-code-mark"><span class="num">2</span></mark>)
<span class="com">// &lt;- true</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->

<p>Let’s move onto something that’s not an <code class="md-code md-code-inline">.indexOf</code> replacement.</p>



<h1 id="stringprototyperepeat"><span class="md-heading"><code class="md-code md-code-inline">String.prototype.repeat</code></span></h1>

<p>This handy method allows you to repeat a string <code class="md-code md-code-inline">count</code> times.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="str">'na'</span><mark class="md-mark md-code-mark">.<span class="built_in">repeat</span></mark>(<span class="num">0</span>)
<span class="com">// &lt;- ''</span>
<span class="str">'na'</span>.<span class="built_in">repeat</span>(<span class="num">1</span>)
<span class="com">// &lt;- 'na'</span>
<span class="str">'na'</span>.<span class="built_in">repeat</span>(<span class="num">2</span>)
<span class="com">// &lt;- 'na<mark class="md-mark md-code-mark">na</mark>'</span>
<span class="str">'na'</span>.<span class="built_in">repeat</span>(<span class="num">5</span>)
<span class="com">// &lt;- 'na<mark class="md-mark md-code-mark">nananana</mark>'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The provided <code class="md-code md-code-inline">count</code> should be a positive finite number.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="str">'na'</span>.<span class="built_in">repeat</span>(<span class="num">Infinity</span>)
<span class="com">// &lt;- RangeError</span>
<span class="str">'na'</span>.<span class="built_in">repeat</span>(<span class="op">-</span><span class="num">1</span>)
<span class="com">// &lt;- RangeError</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Non-numeric values are coerced into numbers.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="str">'na'</span>.<span class="built_in">repeat</span>(<span class="str">'na'</span>)
<span class="com">// &lt;- ''</span>
<span class="str">'na'</span>.<span class="built_in">repeat</span>(<span class="str">'3'</span>)
<span class="com">// &lt;- 'nanana'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Using <code class="md-code md-code-inline">NaN</code> is as good as <code class="md-code md-code-inline">0</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="str">'na'</span>.<span class="built_in">repeat</span>(<span class="md-code-nan">NaN</span>)
<span class="com">// &lt;- ''</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Decimal values are floored.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="str">'na'</span>.<span class="built_in">repeat</span>(<span class="num">3.9</span>)
<span class="com">// &lt;- <mark class="md-mark md-code-mark">'nanana'</mark>, count was floored to 3</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Values in the <code class="md-code md-code-inline">(-1, 0)</code> range are rounded to <code class="md-code md-code-inline">-0</code> becase <code class="md-code md-code-inline">count</code> is passed through <a href="http://ecma-international.org/ecma-262/6.0/#sec-tointeger" aria-label="7.1.4 ToInteger in ECMAScript 6 Specification"><code class="md-code md-code-inline">ToInteger</code></a>, as documented by <a href="http://ecma-international.org/ecma-262/6.0/#sec-string.prototype.repeat" aria-label="21.1.3.13 String.prototype.repeat in ECMAScript 6 Specification">the specification</a>. That step in the specification dictates that <code class="md-code md-code-inline">count</code> be casted with a formula like the one below.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">ToInteger</span> <span class="params">(number)</span> </span>{
  <span class="kw3">return</span> <span class="cls">Math</span>.<span class="built_in">floor</span>(<span class="cls">Math</span>.<span class="built_in">abs</span>(<span class="param">number</span>)) <span class="op">*</span> <span class="cls">Math</span>.<span class="built_in">sign</span>(<span class="param">number</span>)
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The above translates to <code class="md-code md-code-inline">-0</code> for any values in the <code class="md-code md-code-inline">(-1, 0)</code> range. Numbers below that will throw, and numbers above that won’t behave surprisingly, as you can only take <code class="md-code md-code-inline">Math.floor</code> into account for positive values.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="str">'na'</span>.<span class="built_in">repeat</span>(<span class="op">-</span><span class="num">0.1</span>)
<span class="com">// &lt;- <mark class="md-mark md-code-mark">''</mark>, count was rounded to <mark class="md-mark md-code-mark">-0</mark></span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>A good example use case for <code class="md-code md-code-inline">.repeat</code> may be your typical <em>“padding”</em> method. The method shown below takes a multiline string and pads every line with as many <code class="md-code md-code-inline">spaces</code> as desired.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">pad</span> <span class="params">(text, spaces)</span> </span>{
  <span class="kw3">return</span> <span class="param">text</span>.<span class="built_in">split</span>(<span class="str">'\n'</span>).<span class="kw">map</span>(line <span class="op">=&gt;</span> <span class="str">' '</span><mark class="md-mark md-code-mark">.<span class="built_in">repeat</span>(<span class="param">spaces</span>)</mark> <span class="op">+</span> line).<span class="built_in">join</span>(<span class="str">'\n'</span>)
}
<span class="fn">pad</span>(<span class="str">'a\nb\nc'</span>, <span class="num">2</span>)
<span class="com">// &lt;- '  a\n  b\n  c'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>In ES6, strings adhere to the <a href="#es6-iterators-in-depth" aria-label="ES6 Iterators in Depth">iterable protocol</a>.</p>



<h1 id="stringprototype-symboliterator"><span class="md-heading"><code class="md-code md-code-inline">String.prototype[Symbol.iterator]</code></span></h1>

<p>Before ES6, you could access each <strong>code unit</strong> <em>(we’ll define these in a second)</em> in a string via indices — kind of like with arrays. That meant you could loop over <strong>code units</strong> in a string with a <code class="md-code md-code-inline">for</code> loop.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">text</span> <span class="op">=</span> <span class="str">'foo'</span>
<span class="kw3">for</span> (<span class="kw">let</span> <span class="var">i</span> <span class="op">=</span> <span class="num">0</span>; <span class="var">i</span> <span class="op">&lt;</span> <span class="var">text</span>.<span class="built_in">length</span>; <span class="var">i</span><span class="op">++</span>) {
  <span class="kw4">console.log</span>(<mark class="md-mark md-code-mark"><span class="var">text</span>[<span class="var">i</span>]</mark>)
  <span class="com">// &lt;- 'f'</span>
  <span class="com">// &lt;- 'o'</span>
  <span class="com">// &lt;- 'o'</span>
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>In ES6, you could loop over the <strong>code points</strong> <em>(not the same as <strong>code units</strong>)</em> of a string using a <code class="md-code md-code-inline">for..of</code> loop, because strings are <em>iterable</em>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw3">for</span> (<span class="kw">let</span> <mark class="md-mark md-code-mark"><span class="var">codePoint</span></mark> <span class="kw">of</span> <span class="str">'foo'</span>) {
  <span class="kw4">console.log</span>(<span class="var">codePoint</span>)
  <span class="com">// &lt;- 'f'</span>
  <span class="com">// &lt;- 'o'</span>
  <span class="com">// &lt;- 'o'</span>
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>What is this <code class="md-code md-code-inline">codePoint</code> variable? There is <em>a not-so-subtle distinction</em> between <strong>code units</strong> and <strong>code points</strong>. Let’s switch protocols and talk about <em>Unicode</em>.</p>



<h1 id="unicode"><span class="md-heading">Unicode</span></h1>

<p>JavaScript strings are represented using <a href="http://unicodebook.readthedocs.org/en/latest/unicode_encodings.html#ucs-2-ucs-4-utf-16-and-utf-32" aria-label="UCS-2, UCS-4, UTF-16 and UTF-32"><em>UTF-16 code units</em></a>. Each code unit can be used to represent a code point in the <code class="md-code md-code-inline">[U+0000, U+FFFF]</code> range — also known as the <em>“basic multilingual plane”</em> (BMP). You can represent individual code points in the BMP plane using the <code class="md-code md-code-inline">'\u3456'</code> syntax. You could also represent code units in the <code class="md-code md-code-inline">[U+0000, U+0255]</code> using the <code class="md-code md-code-inline">\x00..\xff</code> notation. For instance, <code class="md-code md-code-inline">'\xbb'</code> represents <code class="md-code md-code-inline">'»'</code>, the <code class="md-code md-code-inline">187</code> character, as you can verify by doing <code class="md-code md-code-inline">parseInt('bb', 16)</code> — or <code class="md-code md-code-inline">String.fromCharCode(187)</code>.</p>

<p>For code points beyond <code class="md-code md-code-inline">U+FFFF</code>, you’d represent them as a surrogate pair. That is to say, two contiguous code units. For instance, the horse emoji <code class="md-code md-code-inline">'🐎'</code> code point is represented with the <code class="md-code md-code-inline">'\ud83d\udc0e'</code> contiguous code units. In ES6 notation you can also represent code points using the <code class="md-code md-code-inline">'\u{1f40e}'</code> notation <em>(that example is also the horse emoji)</em>. Note that the internal representation hasn’t changed, so there’s <strong>still two code units</strong> behind that code point. In fact, <code class="md-code md-code-inline">'\u{1f40e}'.length</code> evaluates to <code class="md-code md-code-inline">2</code>.</p>

<p>The <code class="md-code md-code-inline">'\ud83d\udc0e\ud83d\udc71\u2764'</code> string found below evaluates to a few emoji.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="str">'\ud83d\udc0e\ud83d\udc71\u2764'</span>
<span class="com">// &lt;- '🐎👱❤'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>While that string consists of 5 code units, we know that the length should really be three — as there’s only three emoji.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="str">'\ud83d\udc0e\ud83d\udc71\u2764'</span>.<span class="built_in">length</span>
<span class="com">// &lt;- 5</span>
<span class="str">'🐎👱❤'</span>.<span class="built_in">length</span>
<span class="com">// &lt;- <mark class="md-mark md-code-mark">5</mark>, still</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Before ES6, JavaScript didn’t make any effort to figure out unicode quirks on your behalf — you were pretty much on your own when it came to counting cards <em>(err, code points)</em>. Take for instance <code class="md-code md-code-inline">Object.keys</code>, still five code units long.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw4">console.log</span>(<span class="cls">Object</span>.<span class="built_in">keys</span>(<span class="str">'<mark class="md-mark md-code-mark">🐎👱❤</mark>'</span>))
<span class="com">// &lt;- ['0', '1', '2', <mark class="md-mark md-code-mark">'3'</mark>, <mark class="md-mark md-code-mark">'4'</mark>]</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>If we now go back to our <code class="md-code md-code-inline">for</code> loop, we can observe how this is a problem. We actually wanted <code class="md-code md-code-inline">'🐎'</code>, <code class="md-code md-code-inline">'👱'</code>, <code class="md-code md-code-inline">'❤'</code>, but we didn’t get that.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">text</span> <span class="op">=</span> <span class="str">'<mark class="md-mark md-code-mark">🐎👱❤</mark>'</span>
<span class="kw3">for</span> (<span class="kw">let</span> <span class="var">i</span> <span class="op">=</span> <span class="num">0</span>; <span class="var">i</span> <span class="op">&lt;</span> <span class="var">text</span>.<span class="built_in">length</span>; <span class="var">i</span><span class="op">++</span>) {
  <span class="kw4">console.log</span>(<mark class="md-mark md-code-mark"><span class="var">text</span>[<span class="var">i</span>]</mark>)
  <span class="com">// &lt;- '<mark class="md-mark md-code-mark">?</mark>'</span>
  <span class="com">// &lt;- '<mark class="md-mark md-code-mark">?</mark>'</span>
  <span class="com">// &lt;- '<mark class="md-mark md-code-mark">?</mark>'</span>
  <span class="com">// &lt;- '<mark class="md-mark md-code-mark">?</mark>'</span>
  <span class="com">// &lt;- '❤'</span>
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Instead, we got some weird unicode boxes — and that’s if we were lucky and looking at Firefox.</p>

<p><img alt="Printing some emoji character by character on the Firefox console" class="js-only" src="auxi/emoji.png"></p>

<p>That didn’t turn out okay. In ES6 we can use the string iterator to go over the code points instead. The iterators produced by the string iterable are aware of this limitation of looping by code units, and so they <em>yield code points</em> instead.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw3">for</span> (<span class="kw">let</span> <span class="var">codePoint</span> <span class="kw">of</span> <span class="str">'<mark class="md-mark md-code-mark">🐎👱❤</mark>'</span>) {
  <span class="kw4">console.log</span>(<mark class="md-mark md-code-mark"><span class="var">codePoint</span></mark>)
  <span class="com">// &lt;- '<mark class="md-mark md-code-mark">🐎</mark>'</span>
  <span class="com">// &lt;- '<mark class="md-mark md-code-mark">👱</mark>'</span>
  <span class="com">// &lt;- '❤'</span>
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>If we want to measure the length, we’d have trouble with the <code class="md-code md-code-inline">.length</code> property, as we saw earlier. We can use the iterator to <strong>split the string into its code points</strong> <em>— as seen in the <code class="md-code md-code-inline">for..of</code> example we just went over.</em> That means the unicode-aware length of a string equals the length of the array that contains the sequence of code points produced by an iterator. We could use the <a href="#es6-spread-and-butter-in-depth" aria-label="ES6 Spread and Butter in Depth">spread operator</a> to place the code points in an array, and then pull that array’s <code class="md-code md-code-inline">.length</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">[<mark class="md-mark md-code-mark"><span class="op">...</span></mark><span class="str">'<mark class="md-mark md-code-mark">🐎👱❤</mark>'</span>]<mark class="md-mark md-code-mark">.<span class="built_in">length</span></mark>
<span class="com">// &lt;- 3</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Keep in mind that splitting strings into code points isn’t enough if you want to be <em>100% precise</em> about string length. Take for instance the <a href="http://www.fileformat.info/info/unicode/char/0305/index.htm" aria-label="Combining Overline Unicode Character Info"><em>“combining overline”</em> <code class="md-code md-code-inline">\u0305</code></a> unicode code unit. On its own, this code unit is just an overline.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="str">'\u0305'</span>
<span class="com">// &lt;- ' ̅'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>When preceded by another code unit, however, they are <strong>combined together</strong> into a single glyph.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="str">'_<mark class="md-mark md-code-mark">\u0305</mark>'</span>
<span class="com">// &lt;- '_̅'</span>
<span class="str">'foo<mark class="md-mark md-code-mark">\u0305</mark>'</span>
<span class="com">// &lt;- 'foo̅'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Attempts to figure out the actual length by counting code points prove <strong>insufficient</strong> — just like using <code class="md-code md-code-inline">.length</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="str">'foo<mark class="md-mark md-code-mark">\u0305</mark>'</span>.<span class="built_in">length</span>
<span class="com">// &lt;- 4</span>
<span class="str">'foo̅'</span>.<span class="built_in">length</span>
<span class="com">// &lt;- 4</span>
[<mark class="md-mark md-code-mark"><span class="op">...</span></mark><span class="str">'foo̅'</span>]<mark class="md-mark md-code-mark">.<span class="built_in">length</span></mark>
<span class="com">// &lt;- 4</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>I was confused about this one as I’m no expert when it comes to unicode. So I went to someone who <em>is</em> an expert — <a href="https://mathiasbynens.be" aria-label="You can visit him at mathiasbynens.be">Mathias Bynens</a>. He promptly pointed out that <em>— indeed –</em> splitting by code points isn’t enough. Unlike surrogate pairs like the emojis we’ve used in our earlier examples, other <em>grapheme clusters</em> aren’t taken into account by the string iterator.</p><blockquote class="twitter-tweet">

<p><a href="https://twitter.com/nzgb">@nzgb</a> Exactly. The string iterator iterates over code points, but not grapheme clusters. <a href="https://t.co/fTGQUOvMj8">https://t.co/fTGQUOvMj8</a></p>— Mathias Bynens (@mathias) <a href="https://twitter.com/mathias/status/643206231214161920">September 13, 2015</a></blockquote>

<p>In these cases we’re out of luck, and we simply have to <a href="https://mathiasbynens.be/notes/javascript-unicode#other-grapheme-clusters" aria-label="Accounting for Grapheme Clusters">fall back to regular expressions</a> to correctly calculate the string length. For a comprehensive discussion of the subject I suggest you read his excellent <a href="https://mathiasbynens.be/notes/javascript-unicode" aria-label="Read it on mathiasbynens.be">“JavaScript has a Unicode problem”</a> piece.</p>

<p>Let’s look at the other methods.</p>



<h1 id="stringprototypecodepointat"><span class="md-heading"><code class="md-code md-code-inline">String.prototype.codePointAt</code></span></h1>

<p>You can use <code class="md-code md-code-inline">.codePointAt</code> to get the base-10 numeric representation of a code point at a given position in a string. Note that the position is indexed by code unit, not by code point. In the example below we print the code points for each of the three emoji in our demo <code class="md-code md-code-inline">'🐎👱❤'</code> string.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="str">'\ud83d\udc0e\ud83d\udc71\u2764'</span><mark class="md-mark md-code-mark">.<span class="built_in">codePointAt</span>(<span class="num">0</span>)</mark>
<span class="com">// &lt;- 128014</span>
<span class="str">'\ud83d\udc0e\ud83d\udc71\u2764'</span>.<span class="built_in">codePointAt</span>(<mark class="md-mark md-code-mark"><span class="num">2</span></mark>)
<span class="com">// &lt;- 128113</span>
<span class="str">'\ud83d\udc0e\ud83d\udc71\u2764'</span>.<span class="built_in">codePointAt</span>(<mark class="md-mark md-code-mark"><span class="num">4</span></mark>)
<span class="com">// &lt;- 10084</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Figuring out the indices on your own may prove cumbersome, which is why you should just loop through the string iterator so that figures them out on your behalf. You can then just call <code class="md-code md-code-inline">.codePointAt(0)</code> for each code point in the sequence.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw3">for</span> (<span class="kw">let</span> <span class="var">codePoint</span> <span class="kw">of</span> <span class="str">'\ud83d\udc0e\ud83d\udc71\u2764'</span>) {
  <span class="kw4">console.log</span>(<span class="var">codePoint</span><mark class="md-mark md-code-mark">.<span class="built_in">codePointAt</span>(<span class="num">0</span>)</mark>)
  <span class="com">// &lt;- 128014</span>
  <span class="com">// &lt;- 128113</span>
  <span class="com">// &lt;- 10084</span>
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Or maybe just use a combination of <a href="#es6-spread-and-butter-in-depth" aria-label="ES6 Spread and Butter in Depth">spread</a> and <code class="md-code md-code-inline">.map</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">[<mark class="md-mark md-code-mark"><span class="op">...</span></mark><span class="str">'\ud83d\udc0e\ud83d\udc71\u2764'</span>].<span class="kw">map</span>(<mark class="md-mark md-code-mark">cp <span class="op">=&gt;</span> cp.<span class="built_in">codePointAt</span>(<span class="num">0</span>)</mark>)
<span class="com">// &lt;- [128014, 128113, 10084]</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>You could then take the hexadecimal <em>(base-16)</em> representation of those base-10 integers and render them on a string using the new unicode code point escape syntax of <code class="md-code md-code-inline">\u{codePoint}</code>. This syntax allows you to represent unicode code points that are beyond the <em>“basic multilingual plane”</em> (BMP) — i.e, code points outside the <code class="md-code md-code-inline">[U+0000, U+FFFF]</code> range that are typically represented using the <code class="md-code md-code-inline">\u1234</code> syntax.</p>

<p>Let’s start by updating our example to print the hexadecimal version of our code points.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw3">for</span> (<span class="kw">let</span> <span class="var">codePoint</span> <span class="kw">of</span> <span class="str">'\ud83d\udc0e\ud83d\udc71\u2764'</span>) {
  <span class="kw4">console.log</span>(<span class="var">codePoint</span>.<span class="built_in">codePointAt</span>(<span class="num">0</span>)<mark class="md-mark md-code-mark">.<span class="built_in">toString</span>(<span class="num">16</span>)</mark>)
  <span class="com">// &lt;- '1f40e'</span>
  <span class="com">// &lt;- '1f471'</span>
  <span class="com">// &lt;- '2764'</span>
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>You can wrap those in <code class="md-code md-code-inline">'\u{codePoint}'</code> and voilá <em>— you’ll get the emoji out of the string once again.</em></p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="str">'\u{1f40e}'</span>
<span class="com">// &lt;- '🐎'</span>
<span class="str">'\u{1f471}'</span>
<span class="com">// &lt;- '👱'</span>
<span class="str">'\u{2764}'</span>
<span class="com">// &lt;- '❤'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Yay!</p>



<h1 id="stringfromcodepoint"><span class="md-heading"><code class="md-code md-code-inline">String.fromCodePoint</code></span></h1>

<p>This method takes in a number and returns a code point. Note how I can use the <code class="md-code md-code-inline">0x</code> prefix with the terse base-16 code points we got from <code class="md-code md-code-inline">.codePointAt</code> moments ago.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">String</span>.<span class="built_in">fromCodePoint</span>(<mark class="md-mark md-code-mark"><span class="num">0x1f40e</span></mark>)
<span class="com">// &lt;- '🐎'</span>
<span class="kw">String</span>.<span class="built_in">fromCodePoint</span>(<mark class="md-mark md-code-mark"><span class="num">0x1f471</span></mark>)
<span class="com">// &lt;- '👱'</span>
<span class="kw">String</span>.<span class="built_in">fromCodePoint</span>(<mark class="md-mark md-code-mark"><span class="num">0x2764</span></mark>)
<span class="com">// &lt;- '❤'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Obviously, you can just as well use their base-10 counterparts to achieve the same results.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">String</span>.<span class="built_in">fromCodePoint</span>(<mark class="md-mark md-code-mark"><span class="num">128014</span></mark>)
<span class="com">// &lt;- '🐎'</span>
<span class="kw">String</span>.<span class="built_in">fromCodePoint</span>(<mark class="md-mark md-code-mark"><span class="num">128113</span></mark>)
<span class="com">// &lt;- '👱'</span>
<span class="kw">String</span>.<span class="built_in">fromCodePoint</span>(<mark class="md-mark md-code-mark"><span class="num">10084</span></mark>)
<span class="com">// &lt;- '❤'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>You can pass in as many code points as you’d like.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">String</span>.<span class="built_in">fromCodePoint</span>(<mark class="md-mark md-code-mark"><span class="num">128014</span></mark>, <mark class="md-mark md-code-mark"><span class="num">128113</span></mark>, <mark class="md-mark md-code-mark"><span class="num">10084</span></mark>)
<span class="com">// &lt;- '🐎👱❤'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>As an exercise in futility, we could map a string to their numeric representation of code points, and back to the code points themselves.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="op">...</span><span class="str">'\ud83d\udc0e\ud83d\udc71\u2764'</span>]
  .<span class="kw">map</span>(cp <span class="op">=&gt;</span> cp.<span class="built_in">codePointAt</span>(<span class="num">0</span>))
  .<span class="kw">map</span>(cp <span class="op">=&gt;</span> <span class="kw">String</span>.<span class="built_in">fromCodePoint</span>(cp))
  .<span class="built_in">join</span>(<span class="str">''</span>)
<span class="com">// &lt;- '🐎👱❤'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Maybe you’re feeling like playing a joke on your fellow inmates — <em>I mean, coworkers</em>. You can now stab them to death with this piece of code that doesn’t really do anything other than converting the string into code points and then spreading those code points as parameters to <code class="md-code md-code-inline">String.fromCodePoint</code>, which in turn restores the original string. <em>As amusing as it is useless!</em></p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">String</span>.<span class="built_in">fromCodePoint</span>(<mark class="md-mark md-code-mark"><span class="op">...</span></mark>[
  <mark class="md-mark md-code-mark"><span class="op">...</span></mark><span class="str">'\ud83d\udc0e\ud83d\udc71\u2764'</span>
]<mark class="md-mark md-code-mark">.<span class="kw">map</span></mark>(cp <span class="op">=&gt;</span> cp<mark class="md-mark md-code-mark">.<span class="built_in">codePointAt</span></mark>(<span class="num">0</span>)))
<span class="com">// &lt;- '🐎👱❤'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Since we’re on it, you may’ve noticed that reversing the string itself would cause issues.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="str">'\ud83d\udc0e\ud83d\udc71\u2764'</span><mark class="md-mark md-code-mark">.<span class="built_in">split</span>(<span class="str">''</span>)</mark>.<span class="built_in">reverse</span>().<span class="built_in">join</span>(<span class="str">''</span>)
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The problem is that you’re reversing individual code units as opposed to code points.</p>

<p><img alt="Reversing individual code units ends up breaking the code points" class="js-only" src="auxi/breaking_code_points.png"></p>

<p>If we were to use the spread operator to split the string by its code points, and then reverse that, the code points would be preserved and the string would be properly reversed.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">[<mark class="md-mark md-code-mark"><span class="op">...</span></mark><span class="str">'\ud83d\udc0e\ud83d\udc71\u2764'</span>].<span class="built_in">reverse</span>().<span class="built_in">join</span>(<span class="str">''</span>)
<span class="com">// &lt;- '❤👱🐎'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>This way we avoid breaking code points, but once again keep in mind that this won’t work for <em>all</em> grapheme clusters, as Mathias pointed out in his tweet.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="op">...</span><span class="str">'foo<mark class="md-mark md-code-mark">\u0305</mark>'</span>].<span class="built_in">reverse</span>().<span class="built_in">join</span>(<span class="str">''</span>)
<span class="com">// &lt;- <mark class="md-mark md-code-mark">' ̅oof'</mark></span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The last method we’ll cover today is <code class="md-code md-code-inline">.normalize</code>.</p>



<h1 id="stringprototypenormalize"><span class="md-heading"><code class="md-code md-code-inline">String.prototype.normalize</code></span></h1>

<p>There are different ways to represent strings that look identical to humans, even though their code points differ. Mathias gives an example as follows.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="str">'mañana'</span> <span class="op">===</span> <span class="str">'mañana'</span>  <span class="com">// E.g., entered as 'man&#x200b;̃ana'</span>
<span class="com">// &lt;- false</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>What’s going on here? We have a combining tilde <a href="https://codepoints.net/U+0303" aria-label="U+0303 COMBINING TILDE"><code class="md-code md-code-inline">̃</code></a> and an <a href="https://codepoints.net/U+006E" aria-label="U+006E LATIN SMALL LETTER N"><code class="md-code md-code-inline">n</code></a> on the right, while the left just has an <a href="https://codepoints.net/U+00F1" aria-label="U+00F1 LATIN SMALL LETTER N WITH TILDE"><code class="md-code md-code-inline">ñ</code></a>. These <a href="https://mathiasbynens.be/notes/javascript-unicode#accounting-for-lookalikes" aria-label="Accounting for lookalikes">look alike</a>, but if you look at the code points you’ll notice they’re different.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">[<span class="op">...</span><span class="str">'mañana'</span>].<span class="kw">map</span>(cp <span class="op">=&gt;</span> cp.<span class="built_in">codePointAt</span>(<span class="num">0</span>).<span class="built_in">toString</span>(<span class="num">16</span>))
<span class="com">// &lt;- ['6d', '61', <mark class="md-mark md-code-mark">'f1'</mark>, '61', '6e', '61']</span>
[<span class="op">...</span><span class="str">'mañana'</span>].<span class="kw">map</span>(cp <span class="op">=&gt;</span> cp.<span class="built_in">codePointAt</span>(<span class="num">0</span>).<span class="built_in">toString</span>(<span class="num">16</span>))  <span class="com">// E.g., 'man&#x200b;̃ana'</span>
<span class="com">// &lt;- ['6d', '61', <mark class="md-mark md-code-mark">'6e', '303'</mark>, '61', '6e', '61']</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Just like with the <code class="md-code md-code-inline">'foo̅'</code> example, the second string has a length of <code class="md-code md-code-inline">7</code>, even though it is <code class="md-code md-code-inline">6</code> glyphs long.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="str">'mañana'</span>.<span class="built_in">length</span>
<span class="com">// &lt;- 6</span>
<span class="str">'mañana'</span>.<span class="built_in">length</span>  <span class="com">// E.g., 'man&#x200b;̃ana'</span>
<span class="com">// &lt;- 7</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>If we normalize the second version, we’ll get back the same code points we had in the first version.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">normalized</span> <span class="op">=</span> <span class="str">'mañana'</span><mark class="md-mark md-code-mark">.<span class="built_in">normalize</span>()</mark>  <span class="com">// E.g., 'man&#x200b;̃ana'</span>
[<span class="op">...</span><span class="var">normalized</span>].<span class="kw">map</span>(cp <span class="op">=&gt;</span> cp.<span class="built_in">codePointAt</span>(<span class="num">0</span>).<span class="built_in">toString</span>(<span class="num">16</span>))
<span class="com">// &lt;- ['6d', '61', <mark class="md-mark md-code-mark">'f1'</mark>, '61', '6e', '61']</span>
<span class="var">normalized</span>.<span class="built_in">length</span>
<span class="com">// &lt;- 6</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Just for completeness’ sake, note that you can represent these code points using the <code class="md-code md-code-inline">'\x6d'</code> syntax.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="str">'\\x'</span> + [<span class="op">...</span><span class="str">'mañana'</span>].<span class="kw">map</span>(cp <span class="op">=&gt;</span> cp.<span class="built_in">codePointAt</span>(<span class="num">0</span>).<span class="built_in">toString</span>(<span class="num">16</span>)).<span class="built_in">join</span>(<span class="str">'\\x'</span>)
<span class="com">// &lt;- '\\x6d\\x61\\xf1\\x61\\x6e\\x61'</span>
<span class="str">'\x6d\x61\xf1\x61\x6e\x61'</span>
<span class="com">// &lt;- 'mañana'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>We could use <code class="md-code md-code-inline">.normalize</code> on both strings to see if they’re really equal.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">compare</span> <span class="params">(left, right)</span> </span>{
  <span class="kw3">return</span> <span class="param">left</span>.<span class="built_in">normalize</span>() <span class="op">===</span> <span class="param">right</span>.<span class="built_in">normalize</span>()
}
<span class="fn">compare</span>(<span class="str">'mañana'</span>, <span class="str">'mañana'</span>)  <span class="com">// E.g., compare 'mañana' with 'man&#x200b;̃ana'</span>
<span class="com">// &lt;- true</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Or, to prove the point in something that’s a bit more visible to human eyes, let’s use the <code class="md-code md-code-inline">\x</code> syntax. Note that you can only use <code class="md-code md-code-inline">\x</code> to represent code units with codes below 256 <em>(<code class="md-code md-code-inline">\xff</code> is <code class="md-code md-code-inline">255</code>)</em>. For anything larger than that we should use the <code class="md-code md-code-inline">\u</code> escape. Such is the case of the <a href="https://codepoints.net/U+006E" aria-label="U+006E LATIN SMALL LETTER N"><code class="md-code md-code-inline">U+0303</code></a> combining tilde.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="fn">compare</span>(
  <span class="str">'\x6d\x61<mark class="md-mark md-code-mark">\xf1</mark>\x61\x6e\x61'</span>,
  <span class="str">'\x6d\x61<mark class="md-mark md-code-mark">\x6e\u0303</mark>\x61\x6e\x61'</span>
)
<span class="com">// &lt;- true</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>See you tomorrow? <em>Modules are coming!</em></p><blockquote>

<p><em>Many thanks to Mathias for reviewing drafts of this article</em>, ❤!</p></blockquote></section></section>
</article>
</div>
<p><a href="#top" class="top"><img src="./auxi/glyphicons-214-up-arrow.png" alt="up-arrow" class="uparrow" /> <b>Back to top</b></a></p>
</section></main>

<!--  strings ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->
<!--  ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->









<!--  modules ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->

<main class="ly-main"><header class="at-header">



<h1 itemprop="headline" class="dc-title" id="es6-modules-in-depth">ES6 Modules in Depth</h1></header>

<section class="at-teaser"><div class="at-teaser-markdown md-markdown">

<p>Welcome back to ES6 — <em>“Oh, good. It’s not another article about Unicode”</em> — in Depth series. If you’ve never been around here before, start with <a href="#a-brief-history-of-es6-tooling">A Brief History of ES6 Tooling</a>. Then, make your way through <a href="#es6-destructuring-in-depth">destructuring</a>, <a href="#es6-template-strings-in-depth">template literals</a>, <a href="#es6-arrow-functions-in-depth">arrow functions</a>, the <a href="#es6-spread-and-butter-in-depth">spread operator and rest parameters</a>, improvements coming to <a href="#es6-object-literal-features-in-depth">object literals</a>, the new <a href="#es6-classes-in-depth"><em>classes</em></a> sugar on top of prototypes, <a href="#es6-let-const-and-temporal-dead-zone-in-depth"><code class="md-code md-code-inline">let</code>, <code class="md-code md-code-inline">const</code>, and the <em>“Temporal Dead Zone”</em></a>, <a href="#es6-iterators-in-depth">iterators</a>, <a href="#es6-generators-in-depth">generators</a>, <a href="#es6-symbols-in-depth">Symbols</a>, <a href="#es6-maps-in-depth">Maps</a>, <a href="#es6-weakmaps-sets-and-weaksets-in-depth">WeakMaps, Sets, and WeakSets</a>, <a href="#es6-proxies-in-depth">proxies</a>, <a href="#es6-proxy-traps-in-depth">proxy traps</a>, <a href="#more-es6-proxy-traps-in-depth">more proxy traps</a>, <a href="#es6-reflection-in-depth">reflection</a>, <a href="#es6-number-improvements-in-depth"><code class="md-code md-code-inline">Number</code></a>, <a href="#es6-math-additions-in-depth"><code class="md-code md-code-inline">Math</code></a>, <a href="#es6-array-extensions-in-depth"><code class="md-code md-code-inline">Array</code></a>, <a href="#es6-object-changes-in-depth"><code class="md-code md-code-inline">Object</code></a>, and <a href="#es6-strings-and-unicode-in-depth"><code class="md-code md-code-inline">String</code></a>. This morning is about the module system in ES6.</p></div></section>

<section class="at-container de-host"><div class="de-column">

<article itemscope="itemscope" itemtype="http://schema.org/BlogPosting" class="at-article ly-section">
<meta itemprop="dateCreated" content="2015-09-22T08:28:41+00:00" />
<meta itemprop="datePublished" content="2015-09-25T12:30:02+00:00" />
<meta itemprop="dateModified" content="2015-10-13T14:07:51+00:00" />
<meta itemprop="keywords" content="es6,modules,commonjs,es6-in-depth" />

<section itemprop="articleBody" class="at-corpus">

<section itemprop="about" class="md-markdown at-introduction"><blockquote>

<p>As I did in previous articles on the series, I would love to point out that you should probably <a href="#universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That’ll make it so much easier for you to <strong>internalize the concepts</strong> discussed in the series. If you aren’t the <em>“install things on my computer”</em> kind of human, you might prefer to hop on <a href="http://codepen.io/">CodePen</a> and then click on the gear icon for JavaScript — <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em> Another alternative that’s also quite useful is to use Babel’s <a href="http://babeljs.io/repl/">online REPL</a> <em>— it’ll show you compiled ES5 code to the right of your ES6 code for quick comparison.</em></p></blockquote>

<p>Before getting into it, let me <a href="https://www.patreon.com/bevacqua"><em>shamelessly ask for your support</em></a> if you’re enjoying my ES6 in Depth series. Your contributions will go towards helping me keep up with the schedule, server bills, keeping me fed, and maintaining <strong>Pony Foo</strong> as a veritable source of JavaScript goodies.</p>

<p>Thanks for reading that, and let’s dive deep into the ES6 module system.</p></section>

<section class="md-markdown at-body">



<h1 id="the-es6-module-system"><span class="md-heading">The ES6 Module System</span></h1>

<p>Before ES6 we really went out of our ways to obtain modules in JavaScript. Systems like RequireJS, Angular’s dependency injection mechanism, and CommonJS have been catering to our modular needs for a long time now <em>— alongside with helpful tools such as Browserify and Webpack</em>. Still, the year is 2015 and a standard module system was long overdue. As we’ll see in a minute, you’ll quickly notice that ES6 modules have been heavily influenced by CommonJS. We’ll look at <a href="#export"><code class="md-code md-code-inline">export</code></a> and <a href="#import"><code class="md-code md-code-inline">import</code></a> statements, and see how ES6 modules are compatible with CommonJS, as we’ll go over throughout this article.</p>

<p>Today we are going to cover a few areas of the ES6 module system.</p><ul>
  <li><a href="#strict-mode">Strict Mode</a></li>
  <li><a href="#export"><code class="md-code md-code-inline">export</code></a><ul>
  <li><a href="#exporting-a-default-binding">Exporting a Default Binding</a></li>
  <li><a href="#named-exports">Named Exports</a></li>
  <li><a href="#bindings-not-values">Bindings, Not Values</a></li>
  <li><a href="#exporting-lists">Exporting Lists</a></li></ul></li>
  <li><a href="#best-practices-and-export">Best Practices and <code class="md-code md-code-inline">export</code></a></li>
  <li><a href="#import"><code class="md-code md-code-inline">import</code></a><ul>
  <li><a href="#importing-default-exports">Importing Default Exports</a></li>
  <li><a href="#importing-named-exports">Importing Named Exports</a></li>
  <li><a href="#import-all-the-things"><code class="md-code md-code-inline">import</code> All The Things</a></li></ul></li></ul>



<h1 id="strict-mode"><span class="md-heading">Strict Mode</span></h1>

<p>In the ES6 module system, strict mode is turned on by default. In case you don’t know what strict mode is, it’s just a stricter version of the language that disallows lots of bad parts of the language. It enables compilers to perform better by disallowing non-sensical behavior in user code, too. The following is a summary extracted from changes documented in the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" aria-label="Strict Mode on MDN">strict mode article</a> on MDN.</p><ul>
  <li>Variables can’t be left undeclared</li>
  <li>Function parameters must have unique names <em>(or are considered syntax errors)</em></li>
  <li><code class="md-code md-code-inline">with</code> is forbidden</li>
  <li>Errors are thrown on assignment to <em>read-only</em> properties</li>
  <li>Octal numbers like <code class="md-code md-code-inline">00840</code> are syntax errors</li>
  <li>Attempts to <code class="md-code md-code-inline">delete</code> undeletable properties <code class="md-code md-code-inline">throw</code> an error</li>
  <li><code class="md-code md-code-inline">delete prop</code> is a syntax error, instead of assuming <code class="md-code md-code-inline">delete global[prop]</code></li>
  <li><code class="md-code md-code-inline">eval</code> doesn’t introduce <em>new</em> variables into its surrounding scope</li>
  <li><code class="md-code md-code-inline">eval</code> and <code class="md-code md-code-inline">arguments</code> can’t be bound or assigned to</li>
  <li><code class="md-code md-code-inline">arguments</code> doesn’t magically track changes to method parameters</li>
  <li><code class="md-code md-code-inline">arguments.callee</code> throws a <code class="md-code md-code-inline">TypeError</code>, no longer supported</li>
  <li><code class="md-code md-code-inline">arguments.caller</code> throws a <code class="md-code md-code-inline">TypeError</code>, no longer supported</li>
  <li>Context passed as <code class="md-code md-code-inline">this</code> in method invocations is not <em>“boxed” (forced)</em> into becoming an <code class="md-code md-code-inline">Object</code></li>
  <li>No longer able to use <code class="md-code md-code-inline">fn.caller</code> and <code class="md-code md-code-inline">fn.arguments</code> to access the JavaScript stack</li>
  <li>Reserved words <em>(e.g <code class="md-code md-code-inline">protected</code>, <code class="md-code md-code-inline">static</code>, <code class="md-code md-code-inline">interface</code>, etc)</em> cannot be bound</li></ul>

<p>In case it isn’t immediately obvious — you should <code class="md-code md-code-inline">'use strict'</code> in all the places. Even though it’s becoming de-facto in ES6, it’s still a good practice to use <code class="md-code md-code-inline">'use strict'</code> everywhere in ES6. I’ve been doing it for a long time and never looked back!</p>

<p>Let’s now get into <code class="md-code md-code-inline">export</code>, our first ES6 modules keyword of the day!</p>



<h1 id="export"><span class="md-heading"><code class="md-code md-code-inline">export</code></span></h1>

<p>In CommonJS, you export values by exposing them on <code class="md-code md-code-inline">module.exports</code>. As seen in the snippet below, you could expose anything from a value type to an object, an array, or a function.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><mark class="md-mark md-code-mark"><span class="built_in">module.exports</span> =</mark> <span class="num">1</span>
<span class="built_in">module.exports</span> <span class="op">=</span> <span class="md-code-nan">NaN</span>
<span class="built_in">module.exports</span> <span class="op">=</span> <span class="str">'foo'</span>
<span class="built_in">module.exports</span> <span class="op">=</span> { foo: <span class="str">'bar'</span> }
<span class="built_in">module.exports</span> <span class="op">=</span> [<span class="str">'foo'</span>, <span class="str">'bar'</span>]
<span class="built_in">module.exports</span> <span class="op">=</span> <span class="md-code-function"><span class="kw">function</span> <span class="fn">foo</span> <span class="params">()</span> </span>{}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>ES6 modules are files that <code class="md-code md-code-inline">export</code> an API — just like CommonJS modules. Declarations in ES6 modules are scoped to that module, just like with CommonJS. That means that any variables declared inside a module aren’t available to other modules unless they’re <em>explicitly exported</em> as part of the module’s API <em>(and then imported in the module that wants to access them)</em>.</p>



<h2 id="exporting-a-default-binding"><span class="md-heading">Exporting a Default Binding</span></h2>

<p>You can mimic the CommonJS code we just saw by changing <code class="md-code md-code-inline">module.exports =</code> into <code class="md-code md-code-inline">export default</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><mark class="md-mark md-code-mark"><span class="kw">export default</span></mark> <span class="num">1</span>
<span class="kw">export default</span> <span class="md-code-nan">NaN</span>
<span class="kw">export default</span> <span class="str">'foo'</span>
<span class="kw">export default</span> { foo: <span class="str">'bar'</span> }
<span class="kw">export default</span> [<span class="str">'foo'</span>, <span class="str">'bar'</span>]
<span class="kw">export default</span> <span class="md-code-function"><span class="kw">function</span> <span class="fn">foo</span> <span class="params">()</span> </span>{}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Contrary to CommonJS, <code class="md-code md-code-inline">export</code> statements can only be placed at the top level in ES6 modules — even if the method they’re in would be immediately invoked when loading the module. Presumably, this limitation exists to make it easier for compilers to interpret ES6 modules, but it’s also a good limitation to have as there aren’t that many good reasons to dynamically define and expose an API based on method calls.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">foo</span> <span class="params">()</span> </span>{
  <span class="kw">export default</span> <span class="str">'bar'</span> <span class="com">// SyntaxError</span>
}
foo()
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>There isn’t just <code class="md-code md-code-inline">export default</code>, you can also use <em>named exports</em>.</p>



<h2 id="named-exports"><span class="md-heading">Named Exports</span></h2>

<p>In CommonJS you don’t even have to assign an object to <code class="md-code md-code-inline">module.exports</code> first. You could just tack properties onto it. It’s still a single binding being exported <em>— whatever properties the <code class="md-code md-code-inline">module.exports</code> object ends up holding.</em></p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="built_in">module.exports</span>.foo <span class="op">=</span> <span class="str">'bar'</span>
<span class="built_in">module.exports</span>.baz <span class="op">=</span> <span class="str">'ponyfoo'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>We can replicate the above in ES6 modules by using the named exports syntax. Instead of assigning to <code class="md-code md-code-inline">module.exports</code> like with CommonJS, in ES6 you can declare bindings you want to <code class="md-code md-code-inline">export</code>. Note that the code below cannot be refactored to extract the variable declarations into standalone statements and then just <code class="md-code md-code-inline">export foo</code>, as that’d be a syntax error. Here again, we see how ES6 modules favor static analysis by being rigid in how the declarative module system API works.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">export</span> <span class="kw">var</span> <span class="var">foo</span> <span class="op">=</span> <span class="str">'bar'</span>
<span class="kw">export</span> <span class="kw">var</span> <span class="var">baz</span> <span class="op">=</span> <span class="str">'ponyfoo'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>It’s important to keep in mind that we are exporting <em>bindings</em>.</p>



<h2 id="bindings-not-values"><span class="md-heading">Bindings, Not Values</span></h2>

<p>An important point to make is that ES6 modules export bindings, not values or references. That means that a <code class="md-code md-code-inline">foo</code> variable you export would be bound into the <code class="md-code md-code-inline">foo</code> variable on the module, and its value would be subject to changes made to <code class="md-code md-code-inline">foo</code>. I’d advise against changing the public interface of a module after it has initially loaded, though.</p>

<p>If you had an <code class="md-code md-code-inline">./a</code> module like the one found below, the <code class="md-code md-code-inline">foo</code> export would be bound to <code class="md-code md-code-inline">'bar'</code> for 500ms and then change into <code class="md-code md-code-inline">'baz'</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">export</span> <span class="kw">var</span> <span class="var">foo</span> <span class="op">=</span> <span class="str">'bar'</span>
<span class="built_in">setTimeout</span>(() <span class="op">=&gt;</span> <span class="var">foo</span> <span class="op">=</span> <span class="str">'baz'</span>, <span class="num">500</span>)
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Besides a “default” binding and individual bindings, you could also export lists of bindings.</p>



<h2 id="exporting-lists"><span class="md-heading">Exporting Lists</span></h2>

<p>As seen in the snippet below, ES6 modules let you <code class="md-code md-code-inline">export</code> <em>lists</em> of named top-level members.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">foo</span> <span class="op">=</span> <span class="str">'ponyfoo'</span>
<span class="kw">var</span> <span class="var">bar</span> <span class="op">=</span> <span class="str">'baz'</span>
<span class="kw">export</span> <mark class="md-mark md-code-mark">{ <span class="var">foo</span>, <span class="var">bar</span> }</mark>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>If you’d like to export something with a different name, you can use the <code class="md-code md-code-inline">export { foo as bar }</code> syntax, as shown below.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">export</span> { foo <mark class="md-mark md-code-mark"><span class="kw">as</span> ponyfoo</mark> }
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>You could also specify <code class="md-code md-code-inline">as default</code> when using the named member list <code class="md-code md-code-inline">export</code> declaration flavor. The code below is the same as doing <code class="md-code md-code-inline">export default foo</code> and <code class="md-code md-code-inline">export bar</code> afterwards — but in a single statement.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">export</span> { foo <mark class="md-mark md-code-mark"><span class="kw">as</span> <span class="kw">default</span></mark>, bar }
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>There’s many benefits to using only <code class="md-code md-code-inline">export default</code>, and only at the bottom of your module files.</p>



<h1 id="best-practices-and-export"><span class="md-heading">Best Practices and <code class="md-code md-code-inline">export</code></span></h1>

<p>Having the ability to define named exports, exporting a list with aliases and whatnot, and also exposing a a <em>“default”</em> <code class="md-code md-code-inline">export</code> will mostly introduce confusion, and <em>for the most part</em> I’d encourage you to use <code class="md-code md-code-inline">export default</code> — and to do that at the end of your module files. You could just call your API object <code class="md-code md-code-inline">api</code> or name it after the module itself.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <mark class="md-mark md-code-mark"><span class="var">api</span></mark> <span class="op">=</span> {
  foo: <span class="str">'bar'</span>,
  baz: <span class="str">'ponyfoo'</span>
}
<span class="kw">export</span> <span class="kw">default</span> <mark class="md-mark md-code-mark"><span class="var">api</span></mark>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p><b>One</b>, the exported interface of a module becomes immediately obvious. Instead of having to crawl around the module and put the pieces together to figure out the API, you just scroll to the end. Having a clearly defined place where your API is exported also makes it easier to reason about the methods and properties your modules export.</p>

<p><b>Two</b>, you don’t introduce confusion as to whether <code class="md-code md-code-inline">export default</code> or a named export — or a list of named exports <em>(or a list of named exports with aliases…)</em> — should be used in any given module. There’s a guideline now — just use <code class="md-code md-code-inline">export default</code> everywhere and be done with it.</p>

<p><b>Three</b>, consistency. In the CommonJS world <em>it is usual</em> for us to export a single method from a module, and that’s it. Doing so with named exports is impossible as you’d effectively be exposing an object with the method in it, unless you were using the <code class="md-code md-code-inline">as default</code> decorator in the <code class="md-code md-code-inline">export</code> list flavor. The <code class="md-code md-code-inline">export default</code> approach is more versatile because it allows you to <code class="md-code md-code-inline">export</code> just one thing.</p>

<p><b>Four</b>, — and this is really a reduction of points made earlier — the <code class="md-code md-code-inline">export default</code> statement at the bottom of a module makes it immediately obvious what the exported API is, what its methods are, and generally easy for the module’s consumer to <code class="md-code md-code-inline">import</code> its API. When paired with the convention of <em>always using <code class="md-code md-code-inline">export default</code> and always doing it at the end of your modules</em>, you’ll note using the ES6 module system to be painless.</p>

<p>Now that we’ve covered the <code class="md-code md-code-inline">export</code> API and its caveats, let’s jump over to <code class="md-code md-code-inline">import</code> statements.</p>



<h1 id="import"><span class="md-heading"><code class="md-code md-code-inline">import</code></span></h1>

<p>These statements are the counterpart of <code class="md-code md-code-inline">export</code>, and they can be used to load a module from another one — first and foremost. The way modules are loaded is <em>implementation-specific</em>, and at the moment no browsers implement module loading. This way you can write spec-compliant ES6 code today while smart people figure out how to deal with module loading in browsers. Transpilers like Babel are able to concatenate modules with the aid of a module system like CommonJS. That means <code class="md-code md-code-inline">import</code> statements in Babel follow <em>mostly</em> the same semantics as <code class="md-code md-code-inline">require</code> statements in CommonJS.</p>

<p>Let’s take <a href="http://lodash.com/docs" aria-label="Lodash is a JavaScript 'utility belt' library"><code class="md-code md-code-inline">lodash</code></a> as an example for a minute. The following statement simply loads the Lodash module from our module. It doesn’t create any variables, though. It <strong>will execute</strong> any code in the top level of the <code class="md-code md-code-inline">lodash</code> module, though.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><mark class="md-mark md-code-mark"><span class="kw">import</span></mark> <span class="str">'lodash'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Before going into importing bindings, let’s also make a note of the fact that <code class="md-code md-code-inline">import</code> statements, — much like with <code class="md-code md-code-inline">export</code> — are only allowed in the top level of your module definitions. This can help transpilers implement their module loading capabilities, as well as help other static analysis tools parse your codebase.</p>



<h2 id="importing-default-exports"><span class="md-heading">Importing Default Exports</span></h2>

<p>In CommonJS you’d <code class="md-code md-code-inline">import</code> something using a <code class="md-code md-code-inline">require</code> statement, like so.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">_</span> <span class="op">=</span> <span class="built_in">require</span>(<span class="str">'lodash'</span>)
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>To import the default exported binding from an ES6 module, you just have to pick a name for it. The syntax is a bit different than declaring a variable because you’re importing a <em>binding</em>, and also to make it easier on static analysis tools.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">import</span> <mark class="md-mark md-code-mark"><span class="var">_</span></mark> <span class="kw">from</span> <span class="str">'lodash'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>You could also import named exports and alias them.</p>



<h2 id="importing-named-exports"><span class="md-heading">Importing Named Exports</span></h2>

<p>The syntax here is very similar to the one we just used for default exports, you just add some braces and pick any named exports you want. Note that this syntax is similar to the <a href="#es6-destructuring-in-depth" aria-label="ES6 JavaScript Destructuring in Depth">destructuring assignment syntax</a>, but also bit different.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">import</span> <mark class="md-mark md-code-mark">{map, reduce}</mark> <span class="kw">from</span> <span class="str">'lodash'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Another way in which it differs from destructuring is that you could use aliases to rename imported bindings. You can mix and match aliased and non-aliased named exports as you see fit.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">import</span> {cloneDeep <mark class="md-mark md-code-mark"><span class="kw">as</span> clone</mark>, map} <span class="kw">from</span> <span class="str">'lodash'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>You can also mix and match named exports and the default export. If you want it inside the brackets you’ll have to use the <code class="md-code md-code-inline">default</code> name, which you can alias; or you could also just mix the default import side-by-side with the named imports list.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">import</span> {<mark class="md-mark md-code-mark">default</mark>, map} <span class="kw">from</span> <span class="str">'lodash'</span>
<span class="kw">import</span> {<span class="kw">default</span> <mark class="md-mark md-code-mark"><span class="kw">as</span> _</mark>, map} <span class="kw">from</span> <span class="str">'lodash'</span>
<span class="kw">import</span> <mark class="md-mark md-code-mark">_</mark>, {map} <span class="kw">from</span> <span class="str">'lodash'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Lastly, there’s the <code class="md-code md-code-inline">import *</code> flavor.</p>



<h2 id="import-all-the-things"><span class="md-heading"><code class="md-code md-code-inline">import</code> All The Things</span></h2>

<p>You could also import the namespace object for a module. Instead of importing the named exports or the default value, it imports all the things. Note that the <code class="md-code md-code-inline">import *</code> syntax must be followed by an alias where all the bindings will be placed. If there was a default export, it’ll be placed in <code class="md-code md-code-inline">alias.default</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">import</span> <span class="op">*</span> <span class="kw">as</span> _ <span class="kw">from</span> <span class="str">'lodash'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>That’s about it!</p>



<h1 id="conclusions"><span class="md-heading">Conclusions</span></h1>

<p>Note that you can use ES6 modules today through the Babel compiler while leveraging CommonJS modules. What’s great about that is that you can actually interoperate between CommonJS and ES6 modules. That means that even if you <code class="md-code md-code-inline">import</code> a module that’s written in CommonJS it’ll actually work.</p>

<p>The ES6 module system looks great, and it’s one of the most important things that had been missing from JavaScript. I’m hoping they come up with a finalized module loading API and browser implementations soon. The many ways you can <code class="md-code md-code-inline">export</code> or <code class="md-code md-code-inline">import</code> bindings from a module don’t introduce as much versatility as they do added complexity for little gain, but time will tell whether all the extra API surface is as convenient as it is large.</p></section></section>
</article>
</div>
<p><a href="#top" class="top"><img src="./auxi/glyphicons-214-up-arrow.png" alt="up-arrow" class="uparrow" /> <b>Back to top</b></a></p>
</section></main>

<!--  modules ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->
<!--  ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->









<!--  promises ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->

<main class="ly-main"><header class="at-header">



<h1 itemprop="headline" class="dc-title" id="es6-promises-in-depth">ES6 Promises in Depth</h1></header>

<section class="at-teaser"><div class="at-teaser-markdown md-markdown">

<p>Welcome back to ES6 — <em>“Dude, we already had those!”</em> — in Depth series. If you’ve never been around here before, start with <a href="#a-brief-history-of-es6-tooling">A Brief History of ES6 Tooling</a>. Then, make your way through <a href="#es6-destructuring-in-depth">destructuring</a>, <a href="#es6-template-strings-in-depth">template literals</a>, <a href="#es6-arrow-functions-in-depth">arrow functions</a>, the <a href="#es6-spread-and-butter-in-depth">spread operator and rest parameters</a>, improvements coming to <a href="#es6-object-literal-features-in-depth">object literals</a>, the new <a href="#es6-classes-in-depth"><em>classes</em></a> sugar on top of prototypes, <a href="#es6-let-const-and-temporal-dead-zone-in-depth"><code class="md-code md-code-inline">let</code>, <code class="md-code md-code-inline">const</code>, and the <em>“Temporal Dead Zone”</em></a>, <a href="#es6-iterators-in-depth">iterators</a>, <a href="#es6-generators-in-depth">generators</a>, <a href="#es6-symbols-in-depth">Symbols</a>, <a href="#es6-maps-in-depth">Maps</a>, <a href="#es6-weakmaps-sets-and-weaksets-in-depth">WeakMaps, Sets, and WeakSets</a>, <a href="#es6-proxies-in-depth">proxies</a>, <a href="#es6-proxy-traps-in-depth">proxy traps</a>, <a href="#more-es6-proxy-traps-in-depth">more proxy traps</a>, <a href="#es6-reflection-in-depth">reflection</a>, <a href="#es6-number-improvements-in-depth"><code class="md-code md-code-inline">Number</code></a>, <a href="#es6-math-additions-in-depth"><code class="md-code md-code-inline">Math</code></a>, <a href="#es6-array-extensions-in-depth"><code class="md-code md-code-inline">Array</code></a>, <a href="#es6-object-changes-in-depth"><code class="md-code md-code-inline">Object</code></a>, <a href="#es6-strings-and-unicode-in-depth"><code class="md-code md-code-inline">String</code></a>, and <a href="#es6-modules-in-depth">the module system</a>. This morning is about the <code class="md-code md-code-inline">Promise</code> API in ES6.</p></div></section>

<p><em>PDF Note: Some of the graphics on the website are multi-part GIFs; each segment is included here for clarity, clumsy as it may appear in print.</em></p>


<section class="at-container de-host"><div class="de-column">

<article itemscope="itemscope" itemtype="http://schema.org/BlogPosting" class="at-article ly-section">
<meta itemprop="dateCreated" content="2015-09-24T18:59:46+00:00" />
<meta itemprop="datePublished" content="2015-09-28T12:00:04+00:00" />
<meta itemprop="dateModified" content="2015-10-11T04:06:39+00:00" />
<meta itemprop="keywords" content="es6,promise,es6-in-depth" />

<section itemprop="articleBody" class="at-corpus">

<section itemprop="about" class="md-markdown at-introduction"><blockquote>

<p>As I did in previous articles on the series, I would love to point out that you should probably <a href="#universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That’ll make it so much easier for you to <strong>internalize the concepts</strong> discussed in the series. If you aren’t the <em>“install things on my computer”</em> kind of human, you might prefer to hop on <a href="http://codepen.io/">CodePen</a> and then click on the gear icon for JavaScript — <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em> Another alternative that’s also quite useful is to use Babel’s <a href="http://babeljs.io/repl/">online REPL</a> <em>— it’ll show you compiled ES5 code to the right of your ES6 code for quick comparison.</em></p></blockquote>

<p>Before getting into it, let me <a href="https://www.patreon.com/bevacqua"><em>shamelessly ask for your support</em></a> if you’re enjoying my ES6 in Depth series. Your contributions will go towards helping me keep up with the schedule, server bills, keeping me fed, and maintaining <strong>Pony Foo</strong> as a veritable source of JavaScript goodies.</p>

<p>Thanks for reading that, and let’s go into <em>Promises</em> in ES6. Before reading this article you might want to read about <a href="#es6-arrow-functions-in-depth">arrow functions</a>, as they’re heavily used throughout the article; and <a href="#es6-generators-in-depth">generators</a>, as they’re somewhat related to the concepts discussed here.</p>

<p>I also wanted to mention <em>Promisees</em> — a <a href="http://buff.ly/1NyjC7k">promise visualization playground</a> I made last week. It offers in-browser visualizations of how promises unfold. You can run those visualizations step by step, displaying how promises in any piece of code work. You can also record a gif of those visualizations, a few of which I’ll be displaying here in the article. Hope it helps!</p>

<!--  p><a href="http://buff.ly/1NyjC7k"><img src="https://i.imgur.com/XiRxWop.gif" alt="An animation showing a complicated promises visualization"></a></p>

<img src="auxi/promises1.png" alt="stage 1 of diagram" />
<img src="auxi/promises2.png" alt="stage 2 of diagram" />
<img src="auxi/promises3.png" alt="stage 3 of diagram" />
<img src="auxi/promises4.png" alt="stage 4 of diagram" /  -->


<img src="auxi/01_frame_1.gif" alt="stage 1 - An animation showing a complicated promises visualization" />
<img src="auxi/01_frame_2.gif" alt="stage 2 - An animation showing a complicated promises visualization" />
<img src="auxi/01_frame_3.gif" alt="stage 3 - An animation showing a complicated promises visualization" />
<img src="auxi/01_frame_4.gif" alt="stage 4 - An animation showing a complicated promises visualization" />
<img src="auxi/01_frame_5.gif" alt="stage 5 - An animation showing a complicated promises visualization" />
<img src="auxi/01_frame_6.gif" alt="stage 6 - An animation showing a complicated promises visualization" />

<p>If that animation looks insanely complicated to you, read on!</p></section>

<section class="md-markdown at-body"><blockquote>

<p>Promises are a very involved paradigm, so we’ll take it slow.</p></blockquote>

<p>Here’s a table of contents with the topics we’ll cover in this article. Feel free to skip topics you’re comfortable about.</p><ul>
  <li><a href="#what-is-a-promise">What is a Promise?</a> — we define <code class="md-code md-code-inline">Promise</code> and look at a simple example in JavaScript<ul>
  <li><a href="#callbacks-and-events">Callbacks and Events</a> — alternative ways to handle asynchronous code flows</li>
  <li><a href="#gist-of-a-promise">Gist of a <code class="md-code md-code-inline">Promise</code></a> — a first glimpse at how promises work</li></ul></li>
  <li><a href="#promises-in-time">Promises in Time</a> — a brief history of promises</li>
  <li><a href="#then-again">Then, Again</a> — an analysis of <code class="md-code md-code-inline">.then</code> and <code class="md-code md-code-inline">.catch</code></li>
  <li><a href="#creating-a-promise-from-scratch">Creating a Promise From Scratch</a></li>
  <li><a href="#settling-a-promise">Settling a Promise</a> — discusses states of a <code class="md-code md-code-inline">Promise</code></li>
  <li><a href="#paying-a-promise-with-another-promise">Paying a Promise with another Promise</a> — explains promise chaining</li>
  <li><a href="#transforming-values-in-promises">Transforming Values in Promises</a> — shows how to turn a result into something else in the context of promises</li>
  <li><a href="#leveraging-promiseall-and-promiserace">Leveraging <code class="md-code md-code-inline">Promise.all</code> and <code class="md-code md-code-inline">Promise.race</code></a></li></ul>

<p>Shall we?</p>



<h1 id="what-is-a-promise"><span class="md-heading">What is a <code class="md-code md-code-inline">Promise</code>?</span></h1>

<p>Promises are usually vaguely defined as <em>“a proxy for a value that will eventually become available”</em>. They can be used for both synchronous and asynchronous code flows, although they make asynchronous flows easier to reason about — once you’ve mastered promises, that is.</p>

<p>Consider as an example the <em>upcoming</em> <a href="https://developer.mozilla.org/en-US/docs/Web/API/GlobalFetch/fetch#Syntax" aria-label="fetch() API on MDN"><code class="md-code md-code-inline">fetch</code></a> API. This API is a simplification of <code class="md-code md-code-inline">XMLHttpRequest</code>. It aims to be super simple to use for the most basic use cases: making a <code class="md-code md-code-inline">GET</code> request against a resource relative to the current page over <code class="md-code md-code-inline">http(s)</code> — it also provides a comprehensive API that caters to advanced use cases as well, but that’s not our focus for now. In its most basic incarnation, you can make a request for <code class="md-code md-code-inline">GET foo</code> like so.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="built_in">fetch</span>(<span class="str">'foo'</span>)
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The <code class="md-code md-code-inline">fetch('foo')</code> statement doesn’t seem <a href="http://buff.ly/1NRZf70" aria-label="See it on Promisees">all that exciting</a>. It makes a <em>“fire-and-forget”</em> <code class="md-code md-code-inline">GET</code> request against <code class="md-code md-code-inline">foo</code> relative to the resource we’re currently on. The <code class="md-code md-code-inline">fetch</code> method returns a <code class="md-code md-code-inline">Promise</code>. You can chain a <code class="md-code md-code-inline">.then</code> callback that will be executed once the <code class="md-code md-code-inline">foo</code> resource finishes loading.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="built_in">fetch</span>(<span class="str">'foo'</span>)<mark class="md-mark md-code-mark">.<span class="built_in">then</span></mark>(<span class="param">response</span> <span class="op">=&gt;</span> <span class="com">/* do something */</span>)
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Promises offer an alternative to callbacks and events.</p>



<h2 id="callbacks-and-events"><span class="md-heading">Callbacks and Events</span></h2>

<p>If the <code class="md-code md-code-inline">fetch</code> API used callbacks, you’d get one last parameter that then gets executed whenever fetching ends. Typical asynchronous code flow conventions dictate that we allocate the first parameter for errors <em>(that may or may not occur)</em> during the <em>fetching process</em>. The rest of the parameters can be used to pass in resulting data. Often, a single parameter is used.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="built_in">fetch</span>(<span class="str">'foo'</span>, <mark class="md-mark md-code-mark"><span class="params">(err, res)</span> <span class="op">=&gt;</span> {</mark>
  <mark class="md-mark md-code-mark"><span class="kw">if</span> (<span class="param">err</span>) {</mark>
    <span class="com">// handle error</span>
  <mark class="md-mark md-code-mark">}</mark>
  <span class="com">// handle response</span>
<mark class="md-mark md-code-mark">}</mark>)
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The callback wouldn’t be invoked until the <code class="md-code md-code-inline">foo</code> resource has been fetched, so its execution remains asynchronous and non-blocking. Note that in this model you could only specify <strong>a single callback</strong>, and that callback would be responsible for <em>all functionality</em> derived from the response.</p>

<p>Another option might have been to use an <em>event-driven</em> API model. In this model the object returned by <code class="md-code md-code-inline">fetch</code> would be able to listen <code class="md-code md-code-inline">.on</code> events, binding as many event handlers as needed for any events. Typically there’s an <code class="md-code md-code-inline">error</code> event for when things go awry and a <code class="md-code md-code-inline">data</code> event that’s called when the operation completes successfully.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="built_in">fetch</span>(<span class="str">'foo'</span>)
  <mark class="md-mark md-code-mark">.<span class="built_in">on</span></mark>(<span class="str">'error'</span>, <mark class="md-mark md-code-mark"><span class="param">err</span> <span class="op">=&gt;</span> {</mark>
    <span class="com">// handle error</span>
  <mark class="md-mark md-code-mark">}</mark>)
  <mark class="md-mark md-code-mark">.<span class="built_in">on</span></mark>(<span class="str">'data'</span>, <mark class="md-mark md-code-mark"><span class="param">res</span> <span class="op">=&gt;</span> {</mark>
    <span class="com">// handle response</span>
  <mark class="md-mark md-code-mark">}</mark>)
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>In this case, errors usually end up in hard exceptions if no event listener is attached — but that depends on what event emitter implementation is used. Promises are a bit different.</p>



<h2 id="gist-of-a-promise"><span class="md-heading">Gist of a <code class="md-code md-code-inline">Promise</code></span></h2>

<p>Instead of binding event listeners through <code class="md-code md-code-inline">.on</code>, promises offer a slightly different API. The snippet of code shown below displays the actual API of the <code class="md-code md-code-inline">fetch</code> method, which returns a <code class="md-code md-code-inline">Promise</code> object. Much like with events, you can bind as many listeners as you’d like with both <code class="md-code md-code-inline">.catch</code> and <code class="md-code md-code-inline">.then</code>. Note how there’s no need for an event type anymore with the declarative methods used by promises.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">p</span> <span class="op">=</span> <span class="built_in">fetch</span>(<span class="str">'foo'</span>)
<mark class="md-mark md-code-mark"><span class="var">p</span>.<span class="built_in">then</span></mark>(<mark class="md-mark md-code-mark"><span class="param">res</span> <span class="op">=&gt;</span> {</mark>
  <span class="com">// handle response</span>
<mark class="md-mark md-code-mark">}</mark>)
<mark class="md-mark md-code-mark"><span class="var">p</span>.<span class="built_in">catch</span></mark>(<mark class="md-mark md-code-mark"><span class="param">error</span> <span class="op">=&gt;</span> {</mark>
  <span class="com">// handle error</span>
<mark class="md-mark md-code-mark">}</mark>)
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p><sub>See [this example][(<a href="http://buff.ly/1KtWGUD">http://buff.ly/1KtWGUD</a>)] on Promisees</sub></p>

<p>Also note that <code class="md-code md-code-inline">.then</code> is able to register a reaction to rejections as its second argument. The above could be expressed as the following piece of code.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="built_in">fetch</span>(<span class="str">'foo'</span>)
  <mark class="md-mark md-code-mark">.<span class="built_in">then</span></mark>(
    <mark class="md-mark md-code-mark"><span class="param">res</span> <span class="op">=&gt;</span> {</mark>
      <span class="com">// handle response</span>
    <mark class="md-mark md-code-mark">}</mark>,
    <mark class="md-mark md-code-mark"><span class="param">err</span> <span class="op">=&gt;</span> {</mark>
      <span class="com">// handle error</span>
    <mark class="md-mark md-code-mark">}</mark>
  )
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p><sub>See [this example][(<a href="http://buff.ly/1V8xpHI">http://buff.ly/1V8xpHI</a>)] on Promisees</sub></p>

<p>Just like you can omit the error reaction in <code class="md-code md-code-inline">.then(fulfillment)</code>, you can also omit the reaction to <em>fulfillment</em>. Using <code class="md-code md-code-inline">.then(null, rejection)</code> is equivalent to <code class="md-code md-code-inline">.catch(rejection)</code>. Note that <code class="md-code md-code-inline">.then</code> and <code class="md-code md-code-inline">.catch</code> return <strong>a new promise every time</strong>. That’s important because chaining can have wildly different results depending on where you append a <code class="md-code md-code-inline">.then</code> or a <code class="md-code md-code-inline">.catch</code> call onto. See the <a href="http://buff.ly/1Pqh5ex">following example</a> to understand the difference.</p>

<p><a href="http://buff.ly/1Pqh5ex"><img alt="Differences when chaining promises" class="js-only" src="auxi/promises5.png"></a></p>

<p>We’ll get more in depth into these two methods in a bit. Let’s look at a brief history of promises before doing that.</p>



<h1 id="promises-in-time"><span class="md-heading">Promises in Time</span></h1>

<p>Promises aren’t all that new. Like <em>most things in computer science</em>, the earliest mention of Promises can be traced all the way back to the <a href="https://en.wikipedia.org/wiki/Futures_and_promises" aria-label="Futures and Promises on Wikipedia">late seventies</a>. According to the <em>Internet</em>, they made their first appearance in JavaScript in 2007 — in a library called <code class="md-code md-code-inline">MochiKit</code>. Then <code class="md-code md-code-inline">Dojo</code> adopted it, and <code class="md-code md-code-inline">jQuery</code> followed shortly after that.</p>

<p>Then the <a href="https://promisesaplus.com/" aria-label="An open standard for sound, interoperable JavaScript promises—by implementers, for implementers.">Promises/A+</a> specification came out from the CommonJS group <em>(now famous for their CommonJS module specification)</em>. In its earliest incarnations, Node.js shipped with promises. Some time later, they were removed from core and everyone switched over to callbacks. Now, promises ship with the ES6 standard and V8 has already implemented them a while back.</p><blockquote>

<p>The ES6 standard implements <strong>Promises/A+</strong> natively. In the latest versions of Node.js you can use promises without any libraries. They’re also available on Chrome 32+, Firefox 29+, and Safari 7.1+.</p></blockquote>

<p>Shall we go back to the <code class="md-code md-code-inline">Promise</code> API?</p>



<h1 id="then-again"><span class="md-heading">Then, Again</span></h1>

<p>Going back to our example — here’s some of the code we had. In the simplest use case, this is all we wanted.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="built_in">fetch</span>(<span class="str">'foo'</span>)<mark class="md-mark md-code-mark">.<span class="built_in">then</span></mark>(<mark class="md-mark md-code-mark"><span class="param">res</span> <span class="op">=&gt;</span> {</mark>
  <span class="com">// handle response</span>
<mark class="md-mark md-code-mark">}</mark>)
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>What if an error happens in one of the reactions passed to <code class="md-code md-code-inline">.then</code>? You can catch those with <code class="md-code md-code-inline">.catch</code>. The example in the snippet below <a href="http://buff.ly/1Jo8NyJ">logs the error</a> caught when trying to access <code class="md-code md-code-inline">prop</code> from the <em>undefined <code class="md-code md-code-inline">a</code> property</em> in <code class="md-code md-code-inline">res</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="built_in">fetch</span>(<span class="str">'foo'</span>)
  .<span class="built_in">then</span>(<span class="param">res</span> <span class="op">=&gt;</span> <span class="param">res</span>.a.prop.that.does.not.exist)
  .<span class="built_in">catch</span>(<span class="param">err</span> <span class="op">=&gt;</span> <mark class="md-mark md-code-mark"><span class="kw4">console.error</span>(<span class="param">err</span>.message)</mark>)
<span class="com">// &lt;- 'Cannot read property "prop" of undefined'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Note that <em>where</em> you tack your reactions onto matters. The following example <strong>won’t</strong> print the <code class="md-code md-code-inline">err.message</code> twice — only once. That’s because no errors happened in the first <code class="md-code md-code-inline">.catch</code>, so the rejection branch for that promise wasn’t executed. Check out <a href="http://buff.ly/1gLqKjU">the Promisee</a> for a visual explanation of the code below.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="built_in">fetch</span>(<span class="str">'foo'</span>)
  .<span class="built_in">then</span>(<span class="param">res</span> <span class="op">=&gt;</span> <span class="param">res</span>.a.prop.that.does.not.exist)
  .<span class="built_in">catch</span>(<span class="param">err</span> <span class="op">=&gt;</span> <span class="kw4">console.error</span>(<span class="param">err</span>.message))
  .<span class="built_in">catch</span>(<span class="param">err</span> <span class="op">=&gt;</span> <span class="kw4">console.error</span>(<span class="param">err</span>.message))
<span class="com">// &lt;- 'Cannot read property "prop" of undefined'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>In contrast, the snippet found below <em>will</em> <a href="http://buff.ly/1PqlHS2">print the <code class="md-code md-code-inline">err.message</code> twice</a>. It works by saving a reference to the promise returned by <code class="md-code md-code-inline">.then</code>, and then tacking two <code class="md-code md-code-inline">.catch</code> reactions onto it. The second <code class="md-code md-code-inline">.catch</code> in the previous example was capturing errors produced in the promise returned from the first <code class="md-code md-code-inline">.catch</code>, while in this case both <code class="md-code md-code-inline">.catch</code> branch off of <code class="md-code md-code-inline">p</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">p</span> <span class="op">=</span> <span class="built_in">fetch</span>(<span class="str">'foo'</span>).<span class="built_in">then</span>(<span class="param">res</span> <span class="op">=&gt;</span> <span class="param">res</span>.a.prop.that.does.not.exist)
<span class="var">p</span>.<span class="built_in">catch</span>(<span class="param">err</span> <span class="op">=&gt;</span> <span class="kw4">console.error</span>(<span class="param">err</span>.message))
<span class="var">p</span>.<span class="built_in">catch</span>(<span class="param">err</span> <span class="op">=&gt;</span> <span class="kw4">console.error</span>(<span class="param">err</span>.message))
<span class="com">// &lt;- 'Cannot read property "prop" of undefined'</span>
<span class="com">// &lt;- 'Cannot read property "prop" of undefined'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Here’s another example that puts that difference the spotlight. The second catch is triggered this time because it’s <a href="http://buff.ly/1Jo9KHf">bound to the rejection branch</a> on the first <code class="md-code md-code-inline">.catch</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="built_in">fetch</span>(<span class="str">'foo'</span>)
  .<span class="built_in">then</span>(<span class="param">res</span> <span class="op">=&gt;</span> <span class="param">res</span>.a.prop.that.does.not.exist)
  .<span class="built_in">catch</span>(<span class="param">err</span> <span class="op">=&gt;</span> { <mark class="md-mark md-code-mark"><span class="built_in">throw</span></mark> <span class="kw">new</span> <span class="md-code-error">Error</span>(<span class="param">err</span>.message) })
  .<span class="built_in">catch</span>(<span class="param">err</span> <span class="op">=&gt;</span> <span class="kw4">console.error</span>(<span class="param">err</span>.message))
<span class="com">// &lt;- 'Cannot read property "prop" of undefined'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>If the first <code class="md-code md-code-inline">.catch</code> call didn’t return anything, then <a href="http://buff.ly/1Jo9KHf">nothing would be printed</a>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="built_in">fetch</span>(<span class="str">'foo'</span>)
  .<span class="built_in">then</span>(<span class="param">res</span> <span class="op">=&gt;</span> <span class="param">res</span>.a.prop.that.does.not.exist)
  .<span class="built_in">catch</span>(<span class="param">err</span> <span class="op">=&gt;</span> <mark class="md-mark md-code-mark">{}</mark>)
  .<span class="built_in">catch</span>(<span class="param">err</span> <span class="op">=&gt;</span> <span class="kw4">console.error</span>(<span class="param">err</span>.message))
<span class="com">// nothing happens</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>We should observe, then, that promises can be chained “arbitrarily”, that is to say: as we just saw, you can save a reference to any point in the promise chain and then tack more promises on top of it. This is one of the fundamental points to understanding promises.</p><blockquote>

<p>You can save a reference to any point in the promise chain.</p></blockquote>

<p>In fact, the last example can be represented as shown below. This snippet makes it much easier to understand what we’ve discussed so far. Glance over it and then I’ll give you some bullet points.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <mark class="md-mark md-code-mark"><span class="var">p1</span></mark> <span class="op">=</span> <span class="built_in">fetch</span>(<span class="str">'foo'</span>)
<span class="kw">var</span> <mark class="md-mark md-code-mark"><span class="var">p2</span></mark> <span class="op">=</span> <span class="var">p1</span>.<span class="built_in">then</span>(<span class="param">res</span> <span class="op">=&gt;</span> <span class="param">res</span>.a.prop.that.does.not.exist)
<span class="kw">var</span> <mark class="md-mark md-code-mark"><span class="var">p3</span></mark> <span class="op">=</span> <span class="var">p2</span>.<span class="built_in">catch</span>(<span class="param">err</span> <span class="op">=&gt;</span> {})
<span class="kw">var</span> <mark class="md-mark md-code-mark"><span class="var">p4</span></mark> <span class="op">=</span> <span class="var">p3</span>.<span class="built_in">catch</span>(<span class="param">err</span> <span class="op">=&gt;</span> <span class="kw4">console.error</span>(<span class="param">err</span>.message))
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Good boy! Have some bullet points. Or you could just look at the <a href="http://buff.ly/1NS1Uxl">Promisees visualization</a>.</p><ol>
  <li><code class="md-code md-code-inline"><span class="built_in">fetch</span></code> returns a <strong>brand new</strong> <code class="md-code md-code-inline">p1</code> promise</li>
  <li><code class="md-code md-code-inline">p1.then</code> returns a <strong>brand new</strong> <code class="md-code md-code-inline">p2</code> promise</li>
  <li><code class="md-code md-code-inline">p2.catch</code> returns a <strong>brand new</strong> <code class="md-code md-code-inline">p3</code> promise</li>
  <li><code class="md-code md-code-inline">p3.catch</code> returns a <strong>brand new</strong> <code class="md-code md-code-inline">p4</code> promise</li>
  <li>When <code class="md-code md-code-inline">p1</code> is settled <em>(fulfilled)</em>, the <code class="md-code md-code-inline">p1.then</code> reaction is executed</li>
  <li>After that <code class="md-code md-code-inline">p2</code>, which is awaiting the pending result of <code class="md-code md-code-inline">p1.then</code> is settled</li>
  <li>Since <code class="md-code md-code-inline">p2</code> was <em>rejected</em>, <code class="md-code md-code-inline">p2.catch</code> reactions are executed <em>(instead of the <code class="md-code md-code-inline">p2.then</code> branch)</em></li>
  <li>The <code class="md-code md-code-inline">p3</code> promise from <code class="md-code md-code-inline">p2.catch</code> is <em>fulfilled</em>, even though it doesn’t produce any value nor an error</li>
  <li>Because <code class="md-code md-code-inline">p3</code> succeeded, <code class="md-code md-code-inline">p3.catch</code> is never executed — the <code class="md-code md-code-inline">p3.then</code> branch would’ve been used instead</li></ol>

<p>You should think of promises as <strong>a tree structure</strong>. It all starts with a single promise, which we’ll later see how to construct. You then add a branch with <code class="md-code md-code-inline">.then</code> or <code class="md-code md-code-inline">.catch</code>. You can tack as many <code class="md-code md-code-inline">.then</code> or <code class="md-code md-code-inline">.catch</code> calls as you want onto each branch, creating new branches, and so on.</p>



<h1 id="creating-a-promise-from-scratch"><span class="md-heading">Creating a Promise From Scratch</span></h1>

<p>You should now understand how promises work like a tree where you can add branches where you need them, as you need them. But how do you create a promise from scratch? Writing these kinds of <code class="md-code md-code-inline">Promise</code> tutorials is hard because its a chicken and egg situation. People hardly have a need to create a promise from scratch, since libraries usually take care of that. In this article, for instance, I purposely started explaining things using <code class="md-code md-code-inline">fetch</code>, which internally creates a new promise object. Then, each call to <code class="md-code md-code-inline">.then</code> or <code class="md-code md-code-inline">.catch</code> on the promise created by fetch also creates a promise internally, and those promises depend on their parent when it comes to deciding whether the fulfillment branch or the rejection branch should be executed.</p>

<p>Promises can be created from scratch by using <code class="md-code md-code-inline">new Promise(resolver)</code>. The <code class="md-code md-code-inline">resolver</code> parameter is a method that will be used to resolve the promise. It takes two arguments, a <code class="md-code md-code-inline">resolve</code> method and a <code class="md-code md-code-inline">reject</code> method. These promises are fulfilled and rejected, respectively, on the next tick — as <a href="http://buff.ly/1LzF6k8">seen on Promisees</a>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">new</span> <span class="prom">Promise</span>(<span class="param">resolve</span> <span class="op">=&gt;</span> <mark class="md-mark md-code-mark">resolve()</mark>) <span class="com">// promise is fulfilled</span>
<span class="kw">new</span> <span class="prom">Promise</span>(<span class="params">(resolve, reject)</span> <span class="op">=&gt;</span> <mark class="md-mark md-code-mark">reject()</mark>) <span class="com">// promise is rejected</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Resolving and rejecting promises without a value isn’t that useful, though. Usually promises will resolve to some <code class="md-code md-code-inline">result</code>, like the response from an AJAX call as we saw with <code class="md-code md-code-inline">fetch</code>. Similarly, you’ll probably want to state the <code class="md-code md-code-inline">reason</code> for your rejections — typically using an <code class="md-code md-code-inline">Error</code> object. The code below codifies what you’ve just read (see the <a href="http://buff.ly/1KxmM9p">visualization</a>, too).</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">new</span> <span class="prom">Promise</span>(<span class="param">resolve</span> <span class="op">=&gt;</span> resolve({ foo: <span class="str">'bar'</span> }))
  .<span class="built_in">then</span>(<span class="param">result</span> <span class="op">=&gt;</span> <span class="kw4">console.log</span>(<span class="param">result</span>))
  <span class="com">// &lt;- { foo: 'bar' }</span>

<span class="kw">new</span> <span class="prom">Promise</span>(<span class="params">(resolve, reject)</span> <span class="op">=&gt;</span>
  reject(<span class="kw">new</span> <span class="md-code-error">Error</span>(<span class="str">'failed to deliver on my promise to you'</span>)))
  .<span class="built_in">catch</span>(<span class="param">reason</span> <span class="op">=&gt;</span> <span class="kw4">console.log</span>(<span class="param">reason</span>))
  <span class="com">// &lt;- Error: failed to deliver on my promise to you</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>As you may have guessed, there’s nothing inherently synchronous about promises. Fulfillment and rejection can both be completely asynchronous. That’s the whole point of promises! The promise below is fulfilled <a href="http://buff.ly/1PxIwmX">after two seconds</a> elapse.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">new</span> <span class="prom">Promise</span>(<span class="param">resolve</span> <span class="op">=&gt;</span> <span class="built_in">setTimeout</span>(<span class="param">resolve</span>, <span class="num">2000</span>))
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>It’s important to note that only the first call made to either of these methods will have an impact — once a promise is settled, it’s result can’t change. The example below creates a promise that’s fulfilled in the alloted time or rejected after a generous timeout <a href="http://buff.ly/1Owr5po">(visualization)</a>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="kw">function</span> <span class="fn">resolveUnderThreeSeconds</span> <span class="params">(delay)</span> </span>{
  <span class="kw3">return</span> <span class="kw">new</span> <span class="prom">Promise</span>(<span class="md-code-function"><span class="kw">function</span> <span class="params">(resolve, reject)</span> </span>{
    <span class="built_in">setTimeout</span>(<span class="param">resolve</span>, <span class="param">delay</span>)
    <span class="built_in">setTimeout</span>(<span class="param">reject</span>, <span class="num">3000</span>)
  })
}
<span class="fn">resolveUnderThreeSeconds</span>(<span class="num">2000</span>) <span class="com">// resolves!</span>
<span class="fn">resolveUnderThreeSeconds</span>(<span class="num">7000</span>) <span class="com">// fulfillment took so long, it was rejected.</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<!--  p><a href="http://buff.ly/1Owr5po"><img alt="See the promises unfold with this animation." class="js-only" src="https://i.imgur.com/JiIrWWg.gif" /></a></p>

<img src="auxi/promises7.png" alt="stage 1" />
<img src="auxi/promises8.png" alt="stage 2" />
<img src="auxi/promises9.png" alt="stage 3" /  -->

<img src="auxi/06_frame_1.gif" alt="stage 1 - See the promises unfold with this animation" />
<img src="auxi/06_frame_2.gif" alt="stage 2 - See the promises unfold with this animation" />
<img src="auxi/06_frame_3.gif" alt="stage 3 - See the promises unfold with this animation" />


<p>Besides returning resolution values, you could also resolve with <em>another promise</em>. What happens in those cases? In the following snippet we create a promise <code class="md-code md-code-inline">p</code> that will be rejected in three seconds. We also create a promise <code class="md-code md-code-inline">p2</code> that will be resolved with <code class="md-code md-code-inline">p</code> in a second. Since <code class="md-code md-code-inline">p</code> is still two seconds out, resolving <code class="md-code md-code-inline">p2</code> won’t have an immediate effect. Two seconds later, when <code class="md-code md-code-inline">p</code> is rejected, <code class="md-code md-code-inline">p2</code> will be rejected as well, with the same rejection reason that was provided to <code class="md-code md-code-inline">p</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">p</span> <span class="op">=</span> <span class="kw">new</span> <span class="prom">Promise</span>(<span class="md-code-function"><span class="kw">function</span> <span class="params">(resolve, reject)</span> </span>{
  <span class="built_in">setTimeout</span>(() <span class="op">=&gt;</span> <span class="param">reject</span>(<span class="kw">new</span> <span class="md-code-error">Error</span>(<span class="str">'fail'</span>)), <span class="num">3000</span>)
})
<span class="kw">var</span> <span class="var">p2</span> <span class="op">=</span> <span class="kw">new</span> <span class="prom">Promise</span>(<span class="md-code-function"><span class="kw">function</span> <span class="params">(resolve, reject)</span> </span>{
  <span class="built_in">setTimeout</span>(() <span class="op">=&gt;</span> <span class="param">resolve</span>(<span class="var">p</span>), <span class="num">1000</span>)
})
<span class="var">p2</span>.<span class="built_in">then</span>(<span class="param">result</span> <span class="op">=&gt;</span> <span class="kw4">console.log</span>(<span class="param">result</span>))
<span class="var">p2</span>.<span class="built_in">catch</span>(<span class="param">error</span> <span class="op">=&gt;</span> <span class="kw4">console.log</span>(<span class="param">error</span>))
<span class="com">// &lt;- Error: fail</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>In the <a href="http://buff.ly/1KxtpIM">animation</a> shown below we can observe how <code class="md-code md-code-inline">p2</code> becomes blocked <em>— marked in yellow –</em> waiting for a settlement in <code class="md-code md-code-inline">p</code>.</p>

<!--  p><a href="http://buff.ly/1KxtpIM"><img alt="Animation of a promise blocking another one." class="js-only" src="https://i.imgur.com/dIdrAcK.gif" /></a></p  -->

<!--  img src="auxi/promises11.png" alt="stage 1" />
<img src="auxi/promises12.png" alt="stage 2" />
<img src="auxi/promises13.png" alt="stage 3" /  -->

<img src="auxi/10_frame_1.gif" alt="stage 1 - Animation of a promise blocking another one" />
<img src="auxi/10_frame_2.gif" alt="stage 2 - Animation of a promise blocking another one" />
<img src="auxi/10_frame_3.gif" alt="stage 3 - Animation of a promise blocking another one" />

<p>Note that you this behavior is only possible for fulfillment branches using <code class="md-code md-code-inline">resolve</code>. If you try to replicate the same behavior with <code class="md-code md-code-inline">reject</code> you’ll find that the <code class="md-code md-code-inline">p2</code> promise is just rejected with the <code class="md-code md-code-inline">p</code> promise as the rejection <code class="md-code md-code-inline">reason</code>.</p>



<h1 id="using-promiseresolve-and-promisereject"><span class="md-heading">Using <code class="md-code md-code-inline">Promise.resolve</code> and <code class="md-code md-code-inline">Promise.reject</code></span></h1>

<p>Sometimes you want to create a Promise but you don’t want to go through the trouble of using the constructor. The following statement creates a promise that’s fulfilled with a result of <code class="md-code md-code-inline">'foo'</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">new</span> <span class="prom">Promise</span>(<span class="param">resolve</span> <span class="op">=&gt;</span> resolve(<span class="str">'foo'</span>))
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>If you already know the value a promise should be fulfilled with, you can use <code class="md-code md-code-inline">Promise.resolve</code> instead. The following statement is equivalent to the previous one.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="prom">Promise</span>.resolve(<span class="str">'foo'</span>)
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Similarly, if you already know the rejection reason, you can use <code class="md-code md-code-inline">Promise.reject</code>. The next statement creates a promise that’s going to settle into a rejection, with <code class="md-code md-code-inline">reason</code>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="prom">Promise</span>.reject(reason)
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->

<p>What else should we know about settling a promise?</p>



<h1 id="settling-a-promise"><span class="md-heading">Settling a Promise</span></h1>

<p>Promises can exist in three states: pending, fulfilled, and rejected. Pending is the default state. From there, a promise can be <em>“settled”</em> into either fulfillment or rejection. Once a promise is settled, all reactions that are waiting on it are evaluated. Those on the correct branch <em>— <code class="md-code md-code-inline">.then</code> for fulfillment and <code class="md-code md-code-inline">.catch</code> for rejections –</em> are executed.</p>

<p>From this point on, the promise is <em>settled</em>. If at a later point in time another reaction is chained onto the settled promise, the appropriate branch for that reaction is executed in the next tick of the program. In the example below, <code class="md-code md-code-inline">p</code> is resolved with a value of <code class="md-code md-code-inline">100</code> after two seconds. Then, <code class="md-code md-code-inline">100</code> is printed onto the screen. Two seconds later, another <code class="md-code md-code-inline">.then</code> branch is added onto <code class="md-code md-code-inline">p</code>, but since <code class="md-code md-code-inline">p</code> has already fulfilled, the new branch gets executed right away.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">p</span> <span class="op">=</span> <span class="kw">new</span> <span class="prom">Promise</span>(<span class="md-code-function"><span class="kw">function</span> <span class="params">(resolve, reject)</span> </span>{
  <span class="built_in">setTimeout</span>(<span class="params">()</span> <span class="op">=&gt;</span> resolve(<span class="num">100</span>), <span class="num">2000</span>)
})
<span class="var">p</span>.<span class="built_in">then</span>(<span class="param">result</span> <span class="op">=&gt;</span> <span class="kw4">console.log</span>(<span class="param">result</span>))
<span class="com">// &lt;- 100</span>

<span class="built_in">setTimeout</span>(<span class="params">()</span> <span class="op">=&gt;</span> <span class="var">p</span>.<span class="built_in">then</span>(<span class="param">result</span> <span class="op">=&gt;</span> <span class="kw4">console.log</span>(<span class="param">result</span> <span class="op">*</span> <span class="num">20</span>)), <span class="num">4000</span>)
<span class="com">// &lt;- 2000</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->

<p>A promise can return another promise — this is what enables and powers most of their asynchronous behavior. In the <a href="#creating-a-promise-from-scratch">previous section</a>, when creating a promise from scratch, we saw that we can <code class="md-code md-code-inline">resolve</code> with another promise. We can also return promises when calling <code class="md-code md-code-inline">.then</code>.</p>



<h1 id="paying-a-promise-with-another-promise"><span class="md-heading">Paying a Promise with another Promise</span></h1>

<p>The example below shows how we use a promise and <code class="md-code md-code-inline">.then</code> another promise that will only be settled once the returned promise also settles. Once that happens, we get back the response from the wrapped promise, and we use the <code class="md-code md-code-inline">res.url</code> to figure out what random article we were graced with.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="built_in">fetch</span>(<span class="str">'foo'</span>)
  .<span class="built_in">then</span>(<span class="param">response</span> <span class="op">=&gt;</span> <span class="built_in">fetch</span>(<span class="str">'/articles/random'</span>))
  .<span class="built_in">then</span>(<span class="param">response</span> <span class="op">=&gt;</span> <span class="kw4">console.log</span>(<span class="param">response</span>.url))
<span class="com">// &lt;- 'http://ponyfoo.com/articles/es6-symbols-in-depth'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Obviously, in the real world, your second <code class="md-code md-code-inline">fetch</code> would probably depend on the response from the first one. Here’s another example of returning a promise, where we <a href="http://buff.ly/1VbxElo">randomly <code class="md-code md-code-inline">fulfill</code> or <code class="md-code md-code-inline">reject</code></a> after a second.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">p</span> <span class="op">=</span> <span class="prom">Promise</span>.<span class="param">resolve</span>()
  .<span class="built_in">then</span>(<span class="param">data</span> <span class="op">=&gt;</span> <span class="kw">new</span> <span class="prom">Promise</span>(<span class="kw">function</span> <span class="params">(resolve, reject)</span> {
    <span class="built_in">setTimeout</span>(<span class="cls">Math</span>.<span class="built_in">random</span>() <span class="op">&gt;</span>
<span class="num">0.5</span> <span class="op">?</span> <span class="param">resolve</span> <span class="op">:</span> <span class="param">reject</span>, <span class="num">1000</span>)
  }))

<span class="var">p</span>.<span class="built_in">then</span>(<span class="param">data</span> <span class="op">=&gt;</span> <span class="kw4">console.log</span>(<span class="str">'okay!'</span>))
<span class="var">p</span>.<span class="built_in">catch</span>(<span class="param">data</span> <span class="op">=&gt;</span> <span class="kw4">console.log</span>(<span class="str">'boo!'</span>))
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>The animation for this one is super fun!</p>

<!--  p><a href="http://buff.ly/1VbxElo"><img alt="Animation of the code shown right above" class="js-only" src="https://i.imgur.com/3NNoO38.gif"></a></p  -->

<img src="auxi/14_frame_1.gif" alt="stage 1 - Animation of the code shown right above" />
<img src="auxi/14_frame_2.gif" alt="stage 2 - Animation of the code shown right above" />

<p>Okay it’s <strong>not</strong> <em>that fun</em>. I did have fun making the Promisees tool itself!</p>



<h1 id="transforming-values-in-promises"><span class="md-heading">Transforming Values in Promises</span></h1>

<p>You’re not just limited to returning other promises from your <code class="md-code md-code-inline">.then</code> and <code class="md-code md-code-inline">.catch</code> callbacks. You could also return values, transforming what you had. The example below first creates a promise fulfilled with <code class="md-code md-code-inline">[1, 2, 3]</code> and then has a fulfillment branch on top of that which maps thoes values into <code class="md-code md-code-inline">[2, 4, 6]</code>. Calling <code class="md-code md-code-inline">.then</code> on that branch of the promise will produce the doubled values.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="prom">Promise</span>.resolve([<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>])
  .<span class="built_in">then</span>(<span class="param">values</span> <span class="op">=&gt;</span> values.<span class="kw">map</span>(<span class="param">value</span> <span class="op">=&gt;</span> <span class="param">value</span> <span class="op">*</span> <span class="num">2</span>))
  .<span class="built_in">then</span>(<span class="param">values</span> <span class="op">=&gt;</span> <span class="kw4">console.log</span>(<span class="param">values</span>))
  <span class="com">// &lt;- [2, 4, 6]</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Note that you can do the same thing in rejection branches. An interesting fact that may catch your eye is that if a <code class="md-code md-code-inline">.catch</code> branch goes smoothly without errors, then it will be fulfilled with the returned value. That means that if you still want to have an error for that branch, you should <code class="md-code md-code-inline">throw</code> again. The following piece of code takes an internal error and <strong>masks it</strong> behind a generic <em>“Internal Server Error”</em> message as to not leak off potentially dangerous information to its clients <a href="http://buff.ly/1LA2FcS">(visualization)</a>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="prom">Promise</span>.reject(<span class="kw">new</span> <span class="md-code-error">Error</span>(<span class="str">'Database ds.214.53.4.12 connection timeout!'</span>))
  .<span class="built_in">catch</span>(<span class="param">error</span> <span class="op">=&gt;</span> { <span class="kw">throw</span> <span class="kw">new</span> <span class="md-code-error">Error</span>(<span class="str">'Internal Server Error'</span>) })
  .<span class="built_in">catch</span>(<span class="param">error</span> <span class="op">=&gt;</span> <span class="built_in">console.info</span>(<span class="param">error</span>))
  <span class="com">// &lt;- Error: Internal Server Error</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->

<p>Mapping promise results is particularly useful when dealing with multiple concurrent promises. Let’s see how that looks like.</p>



<h1 id="leveraging-promiseall-and-promiserace"><span class="md-heading">Leveraging <code class="md-code md-code-inline">Promise.all</code> and <code class="md-code md-code-inline">Promise.race</code></span></h1>

<p>A tremendously common scenario — even more so for those used to Node.js — is to have a dependency on things A and B before being able to do thing C. I’ll proceed that lousy description of the scenario with multiple code snippets. Suppose you wanted to pull the homepage for both Google and Twitter, and then print out the length of each of their responses. Here’s how that looks in the most näive approach possible, with a hypothetical <code class="md-code md-code-inline">request(url, done)</code> method.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">request(<span class="str">'https://google.com'</span>, <span class="md-code-function"><span class="kw">function</span> <span class="params">(err, goog)</span> </span>{
  request(<span class="str">'https://twitter.com'</span>, <span class="md-code-function"><span class="kw">function</span> <span class="params">(err, twit)</span> </span>{
    <span class="kw4">console.log</span>(<span class="param">goog</span>.<span class="built_in">length</span>, <span class="param">twit</span>.<span class="built_in">length</span>)
  })
})
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Of course, that’s going to run in series you say! Why would we wait on Google’s response before pulling Twitter’s? The following piece fixes the problem. It’s also ridiculously long, though, right?</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">results</span> <span class="op">=</span> {}
request(<span class="str">'https://google.com'</span>, <span class="md-code-function"><span class="kw">function</span> <span class="params">(err, goog)</span> </span>{
  <span class="var">results</span>.<span class="param">goog</span> <span class="op">=</span> <span class="param">goog</span>
  done()
})
request(<span class="str">'https://twitter.com'</span>, <span class="md-code-function"><span class="kw">function</span> <span class="params">(err, twit)</span> </span>{
  <span class="var">results</span>.<span class="param">twit</span> <span class="op">=</span> <span class="param">twit</span>
  <span class="fn">done</span>()
})
<span class="md-code-function"><span class="kw">function</span> <span class="fn">done</span> <span class="params">()</span> </span>{
  <span class="kw">if</span> (<span class="cls">Object</span>.<span class="built_in">keys</span>(<span class="var">results</span>).<span class="built_in">length</span> &lt; <span class="num">2</span>) {
    <span class="kw3">return</span>
  }
  <span class="kw4">console.log</span>(<span class="var">results</span>.<span class="param">goog</span>.<span class="built_in">length</span>, <span class="var">results</span>.<span class="param">twit</span>.<span class="built_in">length</span>)
}
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Since nobody wants to be writing code like that, utility libraries like <code class="md-code md-code-inline">async</code> and <code class="md-code md-code-inline">contra</code> make this much shorter for you. You can use <code class="md-code md-code-inline">contra.concurrent</code> to run these methods at the same time and execute a callback once they all ended. Here’s how that’d look like.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">contra.concurrent({
  goog: <span class="md-code-function"><span class="kw">function</span> <span class="params">(<mark class="md-mark md-code-mark">next</mark>)</span> </span>{
    request(<span class="str">'https://google.com'</span>, <mark class="md-mark md-code-mark"><span class="param">next</span></mark>)
  }
  twit: <span class="md-code-function"><span class="kw">function</span> <span class="params">(next)</span> </span>{
    request(<span class="str">'https://twitter.com'</span>, <span class="param">next</span>)
  }
}, <span class="md-code-function"><span class="kw">function</span> <span class="params">(err, <mark class="md-mark md-code-mark">results</mark>)</span> </span>{
  <span class="kw4">console.log</span>(<span class="param">results</span>.goog.<span class="built_in">length</span>, <span class="param">results</span>.twit.<span class="built_in">length</span>)
})
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>For the very common <em>“I just want a method that appends that magical <code class="md-code md-code-inline">next</code> parameter at the end”</em> use case, there’s also <code class="md-code md-code-inline">contra.curry</code> <em>(equivalent of <code class="md-code md-code-inline">async.apply</code>)</em> to make the code even shorter.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript">contra.concurrent({
  goog: <mark class="md-mark md-code-mark">contra.curry</mark>(request, <span class="str">'https://google.com'</span>),
  twit: <mark class="md-mark md-code-mark">contra.curry</mark>(request, <span class="str">'https://twitter.com'</span>)
}, <span class="md-code-function"><span class="kw">function</span> <span class="params">(err, results)</span> </span>{
  <span class="kw4">console.log</span>(<span class="param">results</span>.goog.<span class="built_in">length</span>, <span class="param">results</span>.twit.<span class="built_in">length</span>)
})
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Promises already make the “run this after this other thing in series” use case very easy, using <code class="md-code md-code-inline">.then</code> as we saw in several examples earlier. For the <em>“run these things concurrently”</em> use case, we can use <code class="md-code md-code-inline">Promise.all</code> <a href="http://buff.ly/1Pyen6L">(visualization here)</a>.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="prom">Promise</span>.<span class="built_in">all</span>([
  <span class="built_in">fetch</span>(<span class="str">'/'</span>),
  <span class="built_in">fetch</span>(<span class="str">'foo'</span>)
])
  .<span class="built_in">then</span>(<span class="param">responses</span> <span class="op">=&gt;</span> <span class="param">responses</span>.<span class="kw">map</span>(<span class="param">response</span> <span class="op">=&gt;</span> <span class="param">response</span>.statusText))
  .<span class="built_in">then</span>(<span class="param">status</span> <span class="op">=&gt;</span> <span class="kw4">console.log</span>(<span class="param">status</span>.<span class="built_in">join</span>(<span class="str">', '</span>)))
  <span class="com">// &lt;- 'OK, Not Found'</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Note that even if a single dependency is rejected, the <code class="md-code md-code-inline">Promise.all</code> method will be rejected entirely as well.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="prom">Promise</span>.<span class="built_in">all</span>([
  <mark class="md-mark md-code-mark"><span class="prom">Promise</span>.<span class="built_in">reject</span>()</mark>,
  <span class="built_in">fetch</span>(<span class="str">'/'</span>),
  <span class="built_in">fetch</span>(<span class="str">'foo'</span>)
])
  .<span class="built_in">then</span>(<span class="param">responses</span> <span class="op">=&gt;</span> <span class="param">responses</span>.<span class="kw">map</span>(<span class="param">response</span> <span class="op">=&gt;</span> <span class="param">response</span>.statusText))
  .<span class="built_in">then</span>(<span class="param">status</span> <span class="op">=&gt;</span> <span class="kw4">console.log</span>(<span class="param">status</span>.<span class="built_in">join</span>(<span class="str">', '</span>)))
  <span class="com">// nothing happens</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>In summary, <code class="md-code md-code-inline">Promise.all</code> has two possible outcomes.</p><ul>
  <li>Settle with <em>a single</em> rejection <code class="md-code md-code-inline">reason</code> as soon as one of its dependencies is rejected</li>
  <li>Settle with <em>all</em> fulfillment <code class="md-code md-code-inline">results</code> as soon as all of its dependencies are fulfilled</li></ul>

<p>Then there’s <code class="md-code md-code-inline">Promise.race</code>. This is a similar method to <code class="md-code md-code-inline">Promise.all</code>, except the first promise to settle will “win” the race, and its value will be passed along to branches of the race. If you run the <a href="http://buff.ly/1gRYr3p">visualization</a> for the following piece of code a few times, you’ll notice that this race doesn’t have a clear winner. It depends on the server and the network!</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="prom">Promise</span>.race([
  <span class="built_in">fetch</span>(<span class="str">'/'</span>),
  <span class="built_in">fetch</span>(<span class="str">'foo'</span>)
])
  .<span class="built_in">then</span>(<span class="param">response</span> <span class="op">=&gt;</span> <span class="kw4">console.log</span>(<span class="param">response</span>.statusText))
  <span class="com">// &lt;- 'OK', or maybe 'Not Found'.</span>
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>Rejections will also finish the race, and the race promise will be rejected. As a closing note we may indicate that this could be useful for scenarios where we want to time out a promise we otherwise have no control over. For instance, the following race does make sense.</p>

<!--  pre  +++++++++++++++++++++++++++++++++++  -->
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="kw">var</span> <span class="var">p</span> <span class="op">=</span> <span class="prom">Promise</span>.race([
  <span class="built_in">fetch</span>(<span class="str">'/resource-that-may-take-a-while'</span>),
  <span class="kw">new</span> <span class="prom">Promise</span>(<span class="md-code-function"><span class="kw">function</span> <span class="params">(resolve, reject)</span> </span>{
    <span class="built_in">setTimeout</span>(() <span class="op">=&gt;</span> reject(<span class="kw">new</span> <span class="md-code-error">Error</span>(<span class="str">'request timeout'</span>)), <span class="num">5000</span>)
  })
])
p.<span class="built_in">then</span>(<span class="param">response</span> <span class="op">=&gt;</span> <span class="kw4">console.log</span>(<span class="param">response</span>))
p.<span class="built_in">catch</span>(<span class="param">error</span> <span class="op">=&gt;</span> <span class="kw4">console.log</span>(<span class="param">error</span>))
</code></pre>
<!--  ++++++++++++++++++++++++++++++++++++++++  -->


<p>To close this article, I’ll leave you with <a href="http://buff.ly/1PyhnQC">a visualization</a>. It shows the race between a resource and a timeout as shown in the code above.</p>

<!--  p><a href="http://buff.ly/1PyhnQC"><img alt="Race between a resource and a timeout" class="js-only" src="https://i.imgur.com/9OoMVfo.gif"></a></p  -->

<img src="auxi/17_frame_1.gif" alt="stage 1 - Race between a resource and a timeout" />
<img src="auxi/17_frame_2.gif" alt="stage 2 - Race between a resource and a timeout" />
<img src="auxi/17_frame_3.gif" alt="stage 3 - Race between a resource and a timeout" />

<p>Here’s hoping I didn’t make promises even harder to understand for you!</p></section></section>
</article>
</div>
<p><a href="#top" class="top"><img src="./auxi/glyphicons-214-up-arrow.png" alt="up-arrow" class="uparrow" /> <b>Back to top</b></a></p>
</section></main>


<!--  promises ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->
<!--  ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->









<!--  overview ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->


<main class="ly-main"><header class="at-header">



<h1 itemprop="headline" class="dc-title" id="es6-overview">ES6 Overview in 350 Bullet Points</h1></header>
<section class="at-teaser"><div class="at-teaser-markdown md-markdown">

<p>My ES6 in Depth series consists of 24 articles covering most syntax changes and features coming in ES6. This article aims to summarize all of those, providing you with practical insight into most of ES6, so that you can quickly get started. Links to the articleshere in ES6 in Depth are included so that you can easily go deeper on any topic you’re interested in.</p></div></section>

<section class="at-container de-host"><div class="de-column">

<article itemscope="itemscope" itemtype="http://schema.org/BlogPosting" class="at-article ly-section">
<meta itemprop="dateCreated" content="2015-10-12T18:47:49+00:00" />
<meta itemprop="datePublished" content="2015-10-15T13:12:01+00:00" />
<meta itemprop="dateModified" content="2015-10-17T14:48:27+00:00" />
<meta itemprop="keywords" content="es6,javascript,babel,es6-in-depth" />
<section itemprop="articleBody" class="at-corpus">
<section itemprop="about" class="md-markdown at-introduction">

<p>I heard you like bullet points, so I made an article containing hundreds of those bad boys. To kick things off, here’s a table of contents with all the topics covered. It has bullet points in it — <strong>obviously</strong>. Note that if you want these concepts to permeate your brain, you’ll have a much better time learning the subject by going through the in-depth series and playing around, experimenting with ES6 code yourself.</p>



<h1 id="table-of-contents"><span class="md-heading">Table of Contents for the Bullet Points</span></h1>

<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#tooling">Tooling</a></li>
  <li><a href="#assignment-destructuring">Assignment Destructuring</a></li>
  <li><a href="#spread-operator-and-rest-parameters">Spread Operator and Rest Parameters</a></li>
  <li><a href="#arrow-functions">Arrow Functions</a></li>
  <li><a href="#template-literals">Template Literals</a></li>
  <li><a href="#object-literals">Object Literals</a></li>
  <li><a href="#classes">Classes</a></li>
  <li><a href="#let-and-const">Let and Const</a></li>
  <li><a href="#symbols">Symbols</a></li>
  <li><a href="#iterators">Iterators</a></li>
  <li><a href="#generators">Generators</a></li>
  <li><a href="#promises">Promises</a></li>
  <li><a href="#maps">Maps</a></li>
  <li><a href="#weakmaps">WeakMaps</a></li>
  <li><a href="#sets">Sets</a></li>
  <li><a href="#weaksets">WeakSets</a></li>
  <li><a href="#proxies">Proxies</a></li>
  <li><a href="#reflection">Reflection</a></li>
  <li><a href="#number"><code class="md-code md-code-inline">Number</code></a></li>
  <li><a href="#math"><code class="md-code md-code-inline">Math</code></a></li>
  <li><a href="#array"><code class="md-code md-code-inline">Array</code></a></li>
  <li><a href="#object"><code class="md-code md-code-inline">Object</code></a></li>
  <li><a href="#strings-and-unicode">Strings and Unicode</a></li>
  <li><a href="#modules">Modules</a></li>
</ul></section>

<section class="md-markdown at-body">


<p>Apologies about that long table of contents, and here we go.</p>



<h1 id="introduction"><span class="md-heading">Introduction</span></h1>

<ul>
  <li>ES6 — also known as Harmony, <code class="md-code md-code-inline">es-next</code>, ES2015 — is the latest finalized specification of the language</li>
  <li>The ES6 specification was finalized in <strong>June 2015</strong>, <em>(hence ES2015)</em></li>
  <li>Future versions of the specification will follow the <code class="md-code md-code-inline">ES[YYYY]</code> pattern, e.g ES2016 for ES7

<ul>
  <li><strong>Yearly release schedule</strong>, features that don’t make the cut take the next train</li>
  <li>Since ES6 pre-dates that decision, most of us still call it ES6</li>
  <li>Starting with ES2016 (ES7), we should start using the <code class="md-code md-code-inline">ES[YYYY]</code> pattern to refer to newer versions</li>
  <li>Top reason for naming scheme is to pressure browser vendors into quickly implementing newest features</li>
</ul></li>
</ul>

<p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p>



<h1 id="tooling"><span class="md-heading">Tooling</span></h1>

<ul>
  <li>To get ES6 working today, you need a <strong>JavaScript-to-JavaScript</strong> <em>transpiler</em></li>
  <li>Transpilers are here to stay

<ul>
  <li>They allow you to compile code in the latest version into older versions of the language</li>
  <li>As browser support gets better, we’ll transpile ES2016 and ES2017 into ES6 and beyond</li>
  <li>We’ll need better source mapping functionality</li>
  <li>They’re the most reliable way to run ES6 source code in production today <em>(although browsers get ES5)</em></li>
</ul></li>
  <li>Babel <em>(a transpiler)</em> has a killer feature: <strong>human-readable output</strong></li>
  <li>Use <a href="http://babeljs.io/" aria-label="Babel JavaScript Compiler"><code class="md-code md-code-inline">babel</code></a> to transpile ES6 into ES5 for static builds</li>
  <li>Use <a href="https://github.com/babel/babelify" aria-label="babel/babelify on GitHub"><code class="md-code md-code-inline">babelify</code></a> to incorporate <code class="md-code md-code-inline">babel</code> into your <a href="#gulp-grunt-whatever" aria-label="Gulp, Grunt, Whatever on Pony Foo">Gulp, Grunt, or <code class="md-code md-code-inline">npm run</code></a> build process</li>
  <li>Use Node.js <code class="md-code md-code-inline">v4.x.x</code> or greater as they have decent ES6 support baked in, thanks to <code class="md-code md-code-inline">v8</code></li>
  <li>Use <code class="md-code md-code-inline">babel-node</code> with any version of <code class="md-code md-code-inline">node</code>, as it transpiles modules into ES5</li>
  <li>Babel has a thriving ecosystem that already supports some of ES2016 and has plugin support</li>
  <li>Read <a href="#a-brief-history-of-es6-tooling" aria-label="A Brief History of ES6 Tooling on Pony Foo">A Brief History of ES6 Tooling</a></li>
</ul>

<p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p>



<h1 id="assignment-destructuring"><span class="md-heading">Assignment Destructuring</span></h1>

<ul>
  <li><code class="md-code md-code-inline">var {foo} = pony</code> is equivalent to <code class="md-code md-code-inline">var foo = pony.foo</code></li>
  <li><code class="md-code md-code-inline">var {foo: baz} = pony</code> is equivalent to <code class="md-code md-code-inline">var baz = pony.foo</code></li>
  <li>You can provide default values, <code class="md-code md-code-inline">var {foo='bar'} = baz</code> yields <code class="md-code md-code-inline">foo: 'bar'</code> if <code class="md-code md-code-inline">baz.foo</code> is <code class="md-code md-code-inline">undefined</code></li>
  <li>You can pull as many properties as you like, aliased or not

<ul>
  <li><code class="md-code md-code-inline">var {foo, bar: baz} = {foo: 0, bar: 1}</code> gets you <code class="md-code md-code-inline">foo: 0</code> and <code class="md-code md-code-inline">baz: 1</code></li>
</ul></li>
  <li>You can go deeper. <code class="md-code md-code-inline">var {foo: {bar}} = { foo: { bar: 'baz' } }</code> gets you <code class="md-code md-code-inline">bar: 'baz'</code></li>
  <li>You can alias that too. <code class="md-code md-code-inline">var {foo: {bar: deep}} = { foo: { bar: 'baz' } }</code> gets you <code class="md-code md-code-inline">deep: 'baz'</code></li>
  <li>Properties that aren’t found yield <code class="md-code md-code-inline">undefined</code> as usual, e.g: <code class="md-code md-code-inline">var {foo} = {}</code></li>
  <li>Deeply nested properties that aren’t found yield an error, e.g: <code class="md-code md-code-inline">var {foo: {bar}} = {}</code></li>
  <li>It also works for arrays, <code class="md-code md-code-inline">[a, b] = [0, 1]</code> yields <code class="md-code md-code-inline">a: 0</code> and <code class="md-code md-code-inline">b: 1</code></li>
  <li>You can skip items in an array, <code class="md-code md-code-inline">[a, , b] = [0, 1, 2]</code>, getting <code class="md-code md-code-inline">a: 0</code> and <code class="md-code md-code-inline">b: 2</code></li>
  <li>You can swap without an <em>“aux”</em> variable, <code class="md-code md-code-inline">[a, b] = [b, a]</code></li>
  <li>You can also use destructuring in function parameters

<ul>
  <li>Assign default values like <code class="md-code md-code-inline">function foo (bar=2) {}</code></li>
  <li>Those defaults can be objects, too <code class="md-code md-code-inline">function foo (bar={ a: 1, b: 2 }) {}</code></li>
  <li>Destructure <code class="md-code md-code-inline">bar</code> completely, like <code class="md-code md-code-inline">function foo ({ a=1, b=2 }) {}</code></li>
  <li>Default to an empty object if nothing is provided, like <code class="md-code md-code-inline">function foo ({ a=1, b=2 } <mark class="md-mark md-code-mark">= {}</mark>) {}</code></li>
</ul></li>
  <li>Read <a href="#es6-destructuring-in-depth" aria-label="ES6 Destructuring in Depth">ES6 JavaScript Destructuring in Depth</a></li>
</ul>

<p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p>



<h1 id="spread-operator-and-rest-parameters"><span class="md-heading">Spread Operator and Rest Parameters</span></h1>

<ul>
  <li>Rest parameters is a better <code class="md-code md-code-inline">arguments</code>

<ul>
  <li>You declare it in the method signature like <code class="md-code md-code-inline">function foo (...everything) {}</code></li>
  <li><code class="md-code md-code-inline">everything</code> is an array with all parameters passed to <code class="md-code md-code-inline">foo</code></li>
  <li>You can name a few parameters before <code class="md-code md-code-inline">...everything</code>, like <code class="md-code md-code-inline">function foo (bar, ...rest) {}</code></li>
  <li>Named parameters are excluded from <code class="md-code md-code-inline">...rest</code></li>
  <li><code class="md-code md-code-inline">...rest</code> must be the last parameter in the list</li>
</ul></li>
  <li>Spread operator is better than magic, also denoted with <code class="md-code md-code-inline">...</code> syntax

<ul>
  <li>Avoids <code class="md-code md-code-inline">.apply</code> when calling methods, <code class="md-code md-code-inline">fn(...[1, 2, 3])</code> is equivalent to <code class="md-code md-code-inline">fn(1, 2, 3)</code></li>
  <li>Easier concatenation <code class="md-code md-code-inline">[1, 2, ...[3, 4, 5], 6, 7]</code></li>
  <li>Casts array-likes or iterables into an array, e.g <code class="md-code md-code-inline">[...document.querySelectorAll('img')]</code></li>
  <li>Useful when <a href="#assignment-destructuring">destructuring</a> too, <code class="md-code md-code-inline">[a, , ...rest] = [1, 2, 3, 4, 5]</code> yields <code class="md-code md-code-inline">a: 1</code> and <code class="md-code md-code-inline">rest: [3, 4, 5]</code></li>
  <li>Makes <code class="md-code md-code-inline">new</code> + <code class="md-code md-code-inline">.apply</code> effortless, <code class="md-code md-code-inline">new Date(...[2015, 31, 8])</code></li>
</ul></li>
  <li>Read <a href="#es6-spread-and-butter-in-depth" aria-label="ES6 Spread and Butter on Pony Foo">ES6 Spread and Butter in Depth</a></li>
</ul>

<p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p>



<h1 id="arrow-functions"><span class="md-heading">Arrow Functions</span></h1>

<ul>
  <li>Terse way to declare a function like <code class="md-code md-code-inline">param =&gt; returnValue</code></li>
  <li>Useful when doing functional stuff like <code class="md-code md-code-inline">[1, 2].map(x =&gt; x * 2)</code></li>
  <li>Several flavors are available, might take you some getting used to

<ul>
  <li><code class="md-code md-code-inline">p1 =&gt; expr</code> is okay for a single parameter</li>
  <li><code class="md-code md-code-inline">p1 =&gt; expr</code> has an implicit <code class="md-code md-code-inline">return</code> statement for the provided <code class="md-code md-code-inline">expr</code> expression</li>
  <li>To return an object implicitly, wrap it in parenthesis <code class="md-code md-code-inline">() =&gt; ({ foo: 'bar' })</code> or you’ll get <strong>an error</strong></li>
  <li>Parenthesis are demanded when you have zero, two, or more parameters, <code class="md-code md-code-inline">() =&gt; expr</code> or <code class="md-code md-code-inline">(p1, p2) =&gt; expr</code></li>
  <li>Brackets in the right-hand side represent a code block that can have multiple statements, <code class="md-code md-code-inline">() =&gt; {}</code></li>
  <li>When using a code block, there’s no implicit <code class="md-code md-code-inline">return</code>, you’ll have to provide it — <code class="md-code md-code-inline">() =&gt; { return 'foo' }</code></li>
</ul></li>
  <li>You can’t name arrow functions statically, but runtimes are now much better at inferring names for most methods</li>
  <li>Arrow functions are bound to their lexical scope

<ul>
  <li><code class="md-code md-code-inline">this</code> is the same <code class="md-code md-code-inline">this</code> context as in the parent scope</li>
  <li><code class="md-code md-code-inline">this</code> can’t be modified with <code class="md-code md-code-inline">.call</code>, <code class="md-code md-code-inline">.apply</code>, or similar <em>“reflection”-type</em> methods</li>
</ul></li>
  <li>Read <a href="#es6-arrow-functions-in-depth" aria-label="ES6 Arrow Functions on Pony Foo">ES6 Arrow Functions in Depth</a></li>
</ul>

<p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p>



<h1 id="template-literals"><span class="md-heading">Template Literals</span></h1>

<ul>
  <li>You can declare strings with <code class="md-code md-code-inline">`</code> (backticks), in addition to <code class="md-code md-code-inline">"</code> and <code class="md-code md-code-inline">'</code></li>
  <li>Strings wrapped in backticks are <em>template literals</em></li>
  <li>Template literals can be multiline</li>
  <li>Template literals allow interpolation like <code class="md-code md-code-inline">`ponyfoo.com is ${rating}`</code> where <code class="md-code md-code-inline">rating</code> is a variable</li>
  <li>You can use any valid JavaScript expressions in the interpolation, such as <code class="md-code md-code-inline">`${2 * 3}`</code> or <code class="md-code md-code-inline">`${foo()}`</code></li>
  <li>You can use tagged templates to change how expressions are interpolated

<ul>
  <li>Add a <code class="md-code md-code-inline">fn</code> prefix to <code class="md-code md-code-inline">fn`foo, ${bar} and ${baz}`</code></li>
  <li><code class="md-code md-code-inline">fn</code> is called once with <code class="md-code md-code-inline">template, ...expressions</code></li>
  <li><code class="md-code md-code-inline">template</code> is <code class="md-code md-code-inline">['foo, ', ' and ', '']</code> and <code class="md-code md-code-inline">expressions</code> is <code class="md-code md-code-inline">[bar, baz]</code></li>
  <li>The result of <code class="md-code md-code-inline">fn</code> becomes the value of the template literal</li>
  <li>Possible use cases include input sanitization of expressions, parameter parsing, etc.</li>
</ul></li>
  <li>Template literals are almost strictly better than strings wrapped in single or double quotes</li>
  <li>Read <a href="#es6-template-strings-in-depth" aria-label="ES6 Template Literals on Pony Foo">ES6 Template Literals in Depth</a></li>
</ul>

<p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p>



<h1 id="object-literals"><span class="md-heading">Object Literals</span></h1>

<ul>
  <li>Instead of <code class="md-code md-code-inline">{ foo: foo }</code>, you can just do <code class="md-code md-code-inline">{ foo }</code> — known as a <em>property value shorthand</em></li>
  <li>Computed property names, <code class="md-code md-code-inline">{ <mark class="md-mark md-code-mark">[prefix + 'Foo']</mark>: 'bar' }</code>, where <code class="md-code md-code-inline">prefix: 'moz'</code>, yields <code class="md-code md-code-inline">{ mozFoo: 'bar' }</code></li>
  <li>You can’t combine computed property names and property value shorthands, <code class="md-code md-code-inline">{ [foo] }</code> is invalid</li>
  <li>Method definitions in an object literal can be declared using an alternative, more terse syntax, <code class="md-code md-code-inline">{ foo () {} }</code></li>
  <li>See also <a href="#object"><code class="md-code md-code-inline">Object</code></a> section</li>
  <li>Read <a href="#es6-object-literal-features-in-depth" aria-label="ES6 Object Literal Features in Depth">ES6 Object Literal Features in Depth</a></li>
</ul>

<p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p>



<h1 id="classes" class=""><span class="md-heading">Classes</span></h1>

<ul>
  <li>Not <em>“traditional”</em> classes, syntax sugar on top of prototypal inheritance</li>
  <li>Syntax similar to declaring objects, <code class="md-code md-code-inline">class Foo {}</code></li>
  <li>Instance methods <em>— <code class="md-code md-code-inline">new Foo().bar</code> –</em> are declared using the short <a href="#object-literals">object literal</a> syntax, <code class="md-code md-code-inline">class Foo { bar () {} }</code></li>
  <li>Static methods <em>— <code class="md-code md-code-inline">Foo.isPonyFoo()</code> –</em> need a <code class="md-code md-code-inline">static</code> keyword prefix, <code class="md-code md-code-inline">class Foo { <mark class="md-mark md-code-mark">static</mark> isPonyFoo () {} }</code></li>
  <li>Constructor method <code class="md-code md-code-inline">class Foo { constructor () { /* initialize instance */ } }</code></li>
  <li>Prototypal inheritance with a simple syntax <code class="md-code md-code-inline">class PonyFoo <mark class="md-mark md-code-mark">extends</mark> Foo {}</code></li>
  <li>Read <a href="#es6-classes-in-depth" aria-label="ES6 Classes in Depth">ES6 Classes in Depth</a></li>
</ul>

<p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p>



<h1 id="let-and-const"><span class="md-heading">Let and Const</span></h1>

<ul>
  <li><code class="md-code md-code-inline">let</code> and <code class="md-code md-code-inline">const</code> are alternatives to <code class="md-code md-code-inline">var</code> when declaring variables</li>
  <li><code class="md-code md-code-inline">let</code> is block-scoped instead of lexically scoped to a <code class="md-code md-code-inline">function</code></li>
  <li><code class="md-code md-code-inline">let</code> is <a href="#javascript-variable-hoisting" aria-label="JavaScript Variable Hoisting on Pony Foo">hoisted</a> to the top of the block, while <code class="md-code md-code-inline">var</code> declarations are hoisted to top of the function</li>
  <li>“Temporal Dead Zone” — TDZ for short

<ul>
  <li>Starts at the beginning of the block where <code class="md-code md-code-inline">let foo</code> was declared</li>
  <li>Ends where the <code class="md-code md-code-inline">let foo</code> statement was placed in user code <em>(hoisiting is irrelevant here)</em></li>
  <li>Attempts to access or assign to <code class="md-code md-code-inline">foo</code> within the TDZ <em>(before the <code class="md-code md-code-inline">let foo</code> statement is reached)</em> result in an error</li>
  <li>Helps prevent mysterious bugs when a variable is manipulated before its declaration is reached</li>
</ul></li>
  <li><code class="md-code md-code-inline">const</code> is also block-scoped, hoisted, and constrained by TDZ semantics</li>
  <li><code class="md-code md-code-inline">const</code> variables must be declared using an initializer, <code class="md-code md-code-inline">const foo = 'bar'</code></li>
  <li>Assigning to <code class="md-code md-code-inline">const</code> after initialization fails silently (or <strong>loudly</strong> <em>— with an exception –</em> under strict mode)</li>
  <li><code class="md-code md-code-inline">const</code> variables don’t make the assigned value immutable

<ul>
  <li><code class="md-code md-code-inline">const foo = { bar: 'baz' }</code> means <code class="md-code md-code-inline">foo</code> will always reference the right-hand side object</li>
  <li><code class="md-code md-code-inline">const foo = { bar: 'baz' }; foo.bar = 'boo'</code> won’t throw</li>
</ul></li>
  <li>Declaration of a variable by the same name will throw</li>
  <li>Meant to fix mistakes where you reassign a variable and lose a reference that was passed along somewhere else</li>
  <li>In ES6, <strong>functions are block scoped</strong>

<ul>
  <li>Prevents leaking block-scoped secrets through hoisting, <code class="md-code md-code-inline">{ <mark class="md-mark md-code-mark">let</mark> _foo = 'secret', bar = <mark class="md-mark md-code-mark">() =&gt; _foo</mark>; }</code></li>
  <li>Doesn’t break user code in most situations, and typically what you wanted anyways</li>
</ul></li>
  <li>Read <a href="#es6-let-const-and-temporal-dead-zone-in-depth" aria-label="ES6 Let, Const, and the 'Temporal Dead Zone' (TDZ) in Depth">ES6 Let, Const and the “Temporal Dead Zone” (TDZ) in Depth</a></li>
</ul>

<p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p>



<h1 id="symbols"><span class="md-heading">Symbols</span></h1>

<ul>
  <li>A new primitive type in ES6</li>
  <li>You can create your own symbols using <code class="md-code md-code-inline">var symbol = Symbol()</code></li>
  <li>You can add a description for debugging purposes, like <code class="md-code md-code-inline">Symbol(<mark class="md-mark md-code-mark">'ponyfoo'</mark>)</code></li>
  <li>Symbols are immutable and unique. <code class="md-code md-code-inline">Symbol()</code>, <code class="md-code md-code-inline">Symbol()</code>, <code class="md-code md-code-inline">Symbol('foo')</code> and <code class="md-code md-code-inline">Symbol('foo')</code> are all different</li>
  <li>Symbols are of type <code class="md-code md-code-inline">symbol</code>, thus: <code class="md-code md-code-inline">typeof Symbol() === 'symbol'</code></li>
  <li>You can also create global symbols with <code class="md-code md-code-inline">Symbol.for(key)</code>

<ul>
  <li>If a symbol with the provided <code class="md-code md-code-inline">key</code> already existed, you get that one back</li>
  <li>Otherwise, a new symbol is created, using <code class="md-code md-code-inline">key</code> as its description as well</li>
  <li><code class="md-code md-code-inline">Symbol.keyFor(symbol)</code> is the inverse function, taking a <code class="md-code md-code-inline">symbol</code> and returning its <code class="md-code md-code-inline">key</code></li>
  <li>Global symbols are <strong>as global as it gets</strong>, or <em>cross-realm</em>. Single registry used to look up these symbols across the runtime

<ul>
  <li><code class="md-code md-code-inline">window</code> context</li>
  <li><code class="md-code md-code-inline">eval</code> context</li>
  <li><code class="md-code md-code-inline">&lt;iframe&gt;</code> context, <code class="md-code md-code-inline">Symbol.for('foo') === iframe.contentWindow.Symbol.for('foo')</code></li>
</ul></li>
</ul></li>
  <li>There’s also “well-known” symbols

<ul>
  <li>Not on the global registry, accessible through <code class="md-code md-code-inline">Symbol[name]</code>, e.g: <code class="md-code md-code-inline">Symbol.iterator</code></li>
  <li>Cross-realm, meaning <code class="md-code md-code-inline">Symbol.iterator === iframe.contentWindow.Symbol.iterator</code></li>
  <li>Used by specification to define protocols, such as the <a href="#iterators"><em>iterable</em> protocol</a> over <code class="md-code md-code-inline">Symbol.iterator</code></li>
  <li>They’re not <strong>actually well-known</strong> — in colloquial terms</li>
</ul></li>
  <li>Iterating over symbol properties is hard, but not impossible and definitely not private

<ul>
  <li>Symbols are hidden to all pre-ES6 “reflection” methods</li>
  <li>Symbols are accessible through <code class="md-code md-code-inline">Object.getOwnPropertySymbols</code></li>
  <li>You won’t stumble upon them but you <strong>will</strong> find them if <em>actively looking</em></li>
</ul></li>
  <li>Read <a href="#es6-symbols-in-depth" aria-label="ES6 Symbols in Depth">ES6 Symbols in Depth</a></li>
</ul>

<p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p>



<h1 id="iterators"><span class="md-heading">Iterators</span></h1>

<ul>
  <li>Iterator and iterable protocol define how to iterate over any object, not just arrays and array-likes</li>
  <li>A well-known <code class="md-code md-code-inline">Symbol</code> is used to assign an iterator to any object</li>
  <li><code class="md-code md-code-inline">var foo = { [<mark class="md-mark md-code-mark">Symbol.iterator</mark>]: iterable}</code>, or <code class="md-code md-code-inline">foo[<mark class="md-mark md-code-mark">Symbol.iterator</mark>] = iterable</code></li>
  <li>The <code class="md-code md-code-inline">iterable</code> is a method that returns an <code class="md-code md-code-inline">iterator</code> object that has a <code class="md-code md-code-inline">next</code> method</li>
  <li>The <code class="md-code md-code-inline">next</code> method returns objects with two properties, <code class="md-code md-code-inline">value</code> and <code class="md-code md-code-inline">done</code>

<ul>
  <li>The <code class="md-code md-code-inline">value</code> property indicates the current value in the sequence being iterated</li>
  <li>The <code class="md-code md-code-inline">done</code> property indicates whether there are any more items to iterate</li>
</ul></li>
  <li>Objects that have a <code class="md-code md-code-inline">[Symbol.iterator]</code> value are <em>iterable</em>, because they subscribe to the iterable protocol</li>
  <li>Some built-ins like <code class="md-code md-code-inline">Array</code>, <code class="md-code md-code-inline">String</code>, or <code class="md-code md-code-inline">arguments</code> — and <code class="md-code md-code-inline">NodeList</code> in browsers — are iterable by default in ES6</li>
  <li>Iterable objects can be looped over with <code class="md-code md-code-inline">for..of</code>, such as <code class="md-code md-code-inline">for (let el of document.querySelectorAll('a'))</code></li>
  <li>Iterable objects can be synthesized using the spread operator, like <code class="md-code md-code-inline">[...document.querySelectorAll('a')]</code></li>
  <li>You can also use <code class="md-code md-code-inline">Array.from(document.querySelectorAll('a'))</code> to synthesize an iterable sequence into an array</li>
  <li>Iterators are <em>lazy</em>, and those that produce an infinite sequence still can lead to valid programs</li>
  <li>Be careful not to attempt to synthesize an infinite sequence with <code class="md-code md-code-inline">...</code> or <code class="md-code md-code-inline">Array.from</code> as that <strong>will</strong> cause an infinite loop</li>
  <li>Read <a href="#es6-iterators-in-depth" aria-label="ES6 Iterators in Depth">ES6 Iterators in Depth</a></li>
</ul>

<p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p>



<h1 id="generators"><span class="md-heading">Generators</span></h1>

<ul>
  <li>Generator functions are a special kind of <em>iterator</em> that can be declared using the <code class="md-code md-code-inline"><mark class="md-mark md-code-mark">function*</mark> generator () {}</code> syntax</li>
  <li>Generator functions use <code class="md-code md-code-inline">yield</code> to emit an element sequence</li>
  <li>Generator functions can also use <code class="md-code md-code-inline">yield*</code> to delegate to another generator function <em>— or any iterable object</em></li>
  <li>Generator functions return a generator object that’s adheres to both the <em>iterable</em> and <em>iterator</em> protocols

<ul>
  <li>Given <code class="md-code md-code-inline">g = generator()</code>, <code class="md-code md-code-inline">g</code> adheres to the iterable protocol because <code class="md-code md-code-inline">g[Symbol.iterator]</code> is a method</li>
  <li>Given <code class="md-code md-code-inline">g = generator()</code>, <code class="md-code md-code-inline">g</code> adheres to the iterator protocol because <code class="md-code md-code-inline">g.next</code> is a method</li>
  <li>The iterator for a generator object <code class="md-code md-code-inline">g</code> is the generator itself: <code class="md-code md-code-inline">g[Symbol.iterator]() === g</code></li>
</ul></li>
  <li>Pull values using <code class="md-code md-code-inline">Array.from(g)</code>, <code class="md-code md-code-inline">[...g]</code>, <code class="md-code md-code-inline">for (let item of g)</code>, or just calling <code class="md-code md-code-inline">g.next()</code></li>
  <li>Generator function execution is suspended, remembering the last position, in four different cases

<ul>
  <li>A <code class="md-code md-code-inline">yield</code> expression returning the next value in the sequence</li>
  <li>A <code class="md-code md-code-inline">return</code> statement returning the last value in the sequence</li>
  <li>A <code class="md-code md-code-inline">throw</code> statement halts execution in the generator entirely</li>
  <li>Reaching the end of the generator function signals <code class="md-code md-code-inline">{ done: true }</code></li>
</ul></li>
  <li>Once the <code class="md-code md-code-inline">g</code> sequence has ended, <code class="md-code md-code-inline">g.next()</code> simply returns <code class="md-code md-code-inline">{ done: true }</code> and has no effect</li>
  <li>It’s easy to make asynchronous flows feel synchronous

<ul>
  <li>Take user-provided generator function</li>
  <li>User code is suspended while asynchronous operations take place</li>
  <li>Call <code class="md-code md-code-inline">g.next()</code>, unsuspending execution in user code</li>
</ul></li>
  <li>Read <a href="#es6-generators-in-depth" aria-label="ES6 Generators in Depth">ES6 Generators in Depth</a></li>
</ul>

<p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p>



<h1 id="promises"><span class="md-heading">Promises</span></h1>

<ul>
  <li>Follows the <a href="https://promisesaplus.com/" aria-label="An open standard for sound, interoperable JavaScript promises"><code class="md-code md-code-inline">Promises/A+</code></a> specification, was widely implemented in the wild before ES6 was standarized <em>(e.g <a href="https://github.com/petkaantonov/bluebird" aria-label="petkaantonov/bluebird on GitHub"><code class="md-code md-code-inline">bluebird</code></a>)</em></li>
  <li>Promises behave like a tree. Add branches with <code class="md-code md-code-inline">p.then(handler)</code> and <code class="md-code md-code-inline">p.catch(handler)</code></li>
  <li>Create new <code class="md-code md-code-inline">p</code> promises with <code class="md-code md-code-inline">new Promise(<mark class="md-mark md-code-mark">(resolve, reject) =&gt; { /* resolver */ }</mark>)</code>

<ul>
  <li>The <code class="md-code md-code-inline">resolve(value)</code> callback will fulfill the promise with the provided <code class="md-code md-code-inline">value</code></li>
  <li>The <code class="md-code md-code-inline">reject(reason)</code> callback will reject <code class="md-code md-code-inline">p</code> with a <code class="md-code md-code-inline">reason</code> error</li>
  <li>You can call those methods asynchronously, blocking deeper branches of the promise tree</li>
</ul></li>
  <li>Each call to <code class="md-code md-code-inline">p.then</code> and <code class="md-code md-code-inline">p.catch</code> creates another promise that’s blocked on <code class="md-code md-code-inline">p</code> being settled</li>
  <li>Promises start out in <em>pending</em> state and are <strong>settled</strong> when they’re either <em>fulfilled</em> or <em>rejected</em></li>
  <li>Promises can only be settled once, and then they’re settled. Settled promises unblock deeper branches</li>
  <li>You can tack as many promises as you want onto as many branches as you need</li>
  <li>Each branch will execute either <code class="md-code md-code-inline">.then</code> handlers or <code class="md-code md-code-inline">.catch</code> handlers, never both</li>
  <li>A <code class="md-code md-code-inline">.then</code> callback can transform the result of the previous branch by returning a value</li>
  <li>A <code class="md-code md-code-inline">.then</code> callback can block on another promise by returning it</li>
  <li><code class="md-code md-code-inline">p.catch(fn).catch(fn)</code> won’t do what you want — unless what you wanted is to catch errors in the error handler</li>
  <li><a href="#es6-promises-in-depth#using-promiseresolve-and-promisereject"><code class="md-code md-code-inline">Promise.resolve(value)</code></a> creates a promise that’s fulfilled with the provided <code class="md-code md-code-inline">value</code></li>
  <li><a href="#es6-promises-in-depth#using-promiseresolve-and-promisereject"><code class="md-code md-code-inline">Promise.reject(reason)</code></a> creates a promise that’s rejected with the provided <code class="md-code md-code-inline">reason</code></li>
  <li><a href="#es6-promises-in-depth#leveraging-promiseall-and-promiserace"><code class="md-code md-code-inline">Promise.all(...promises)</code></a> creates a promise that settles when all <code class="md-code md-code-inline">...promises</code> are fulfilled or 1 of them is rejected</li>
  <li><a href="#es6-promises-in-depth#leveraging-promiseall-and-promiserace"><code class="md-code md-code-inline">Promise.race(...promises)</code></a> creates a promise that settles as soon as 1 of <code class="md-code md-code-inline">...promises</code> is settled</li>
  <li>Use <a href="http://bevacqua.github.io/promisees/" aria-label="Promisees — Promise visualization playground for the adventurous">Promisees</a> — the promise visualization playground — to better understand promises</li>
  <li>Read <a href="#es6-promises-in-depth" aria-label="ES6 Promises in Depth">ES6 Promises in Depth</a></li>
</ul>

<p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p>



<h1 id="maps"><span class="md-heading">Maps</span></h1>

<ul>
  <li>A replacement to the common pattern of creating a hash-map using plain JavaScript objects

<ul>
  <li>Avoids security issues with user-provided keys</li>
  <li>Allows keys to be arbitrary values, you can even use DOM elements or functions as the <code class="md-code md-code-inline">key</code> to an entry</li>
</ul></li>
  <li><code class="md-code md-code-inline">Map</code> adheres to <em><a href="#iterators">iterable</a></em> protocol</li>
  <li>Create a <code class="md-code md-code-inline">map</code> using <code class="md-code md-code-inline">new Map()</code></li>
  <li>Initialize a map with an <code class="md-code md-code-inline">iterable</code> like <code class="md-code md-code-inline">[[key1, value1], [key2, value2]]</code> in <code class="md-code md-code-inline">new Map(iterable)</code></li>
  <li>Use <code class="md-code md-code-inline">map.set(key, value)</code> to add entries</li>
  <li>Use <code class="md-code md-code-inline">map.get(key)</code> to get an entry</li>
  <li>Check for a <code class="md-code md-code-inline">key</code> using <code class="md-code md-code-inline">map.has(key)</code></li>
  <li>Remove entries with <code class="md-code md-code-inline">map.delete(key)</code></li>
  <li>Iterate over <code class="md-code md-code-inline">map</code> with <code class="md-code md-code-inline">for (let [key, value] of map)</code>, the spread operator, <code class="md-code md-code-inline">Array.from</code>, etc</li>
  <li>Read <a href="#es6-maps-in-depth" aria-label="ES6 Maps in Depth">ES6 Maps in Depth</a></li>
</ul>

<p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p>



<h1 id="weakmaps"><span class="md-heading">WeakMaps</span></h1>

<ul>
  <li>Similar to <code class="md-code md-code-inline">Map</code>, but not quite the same</li>
  <li><code class="md-code md-code-inline">WeakMap</code> isn’t iterable, so you don’t get enumeration methods like <code class="md-code md-code-inline">.forEach</code>, <code class="md-code md-code-inline">.clear</code>, and others you had in <code class="md-code md-code-inline">Map</code></li>
  <li><code class="md-code md-code-inline">WeakMap</code> keys must be reference types. You can’t use value types like symbols, numbers, or strings as keys</li>
  <li><code class="md-code md-code-inline">WeakMap</code> entries with a <code class="md-code md-code-inline">key</code> that’s the only reference to the referenced variable are subject to garbage collection</li>
  <li>That last point means <code class="md-code md-code-inline">WeakMap</code> is great at keeping around metadata for objects, while those objects are still in use</li>
  <li>You avoid memory leaks, without manual reference counting — think of <code class="md-code md-code-inline">WeakMap</code> as <a href="https://msdn.microsoft.com/en-us/library/system.idisposable%28v=vs.110%29.aspx?f=255&amp;MSPPError=-2147217396" aria-label="IDisposable on MSDN"><code class="md-code md-code-inline">IDisposable</code></a> in .NET</li>
  <li>Read <a href="#es6-weakmaps-sets-and-weaksets-in-depth#es6-weakmaps" aria-label="ES6 WeakMaps, Sets, and WeakSets in Depth">ES6 WeakMaps in Depth</a></li>
</ul>

<p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p>



<h1 id="sets"><span class="md-heading">Sets</span></h1>

<ul>
  <li>Similar to <code class="md-code md-code-inline">Map</code>, but not quite the same</li>
  <li><code class="md-code md-code-inline">Set</code> doesn’t have keys, there’s only values</li>
  <li><code class="md-code md-code-inline">set.set(value)</code> doesn’t look right, so we have <code class="md-code md-code-inline">set.add(value)</code> instead</li>
  <li>Sets can’t have duplicate values because the values are also used as keys</li>
  <li>Read <a href="#es6-weakmaps-sets-and-weaksets-in-depth#es6-sets" aria-label="ES6 WeakMaps, Sets, and WeakSets in Depth">ES6 Sets in Depth</a></li>
</ul>

<p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p>



<h1 id="weaksets"><span class="md-heading">WeakSets</span></h1>

<ul>
  <li><code class="md-code md-code-inline">WeakSet</code> is sort of a cross-breed between <code class="md-code md-code-inline">Set</code> and <code class="md-code md-code-inline">WeakMap</code></li>
  <li>A <code class="md-code md-code-inline">WeakSet</code> is a set that can’t be iterated and doesn’t have enumeration methods</li>
  <li><code class="md-code md-code-inline">WeakSet</code> values must be reference types</li>
  <li><code class="md-code md-code-inline">WeakSet</code> may be useful for a metadata table indicating whether a reference is actively in use or not</li>
  <li>Read <a href="#es6-weakmaps-sets-and-weaksets-in-depth#es6-weaksets" aria-label="ES6 WeakMaps, Sets, and WeakSets in Depth">ES6 WeakSets in Depth</a></li>
</ul>

<p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p>



<h1 id="proxies"><span class="md-heading">Proxies</span></h1>

<ul>
  <li>Proxies are created with <code class="md-code md-code-inline">new Proxy(target, handler)</code>, where <code class="md-code md-code-inline">target</code> is any object and <code class="md-code md-code-inline">handler</code> is configuration</li>
  <li>The default behavior of a <code class="md-code md-code-inline">proxy</code> acts as a passthrough to the underlying <code class="md-code md-code-inline">target</code> object</li>
  <li>Handlers determine how the underlying <code class="md-code md-code-inline">target</code> object is accessed on top of regular object property access semantics</li>
  <li>You pass off references to <code class="md-code md-code-inline">proxy</code> and retain strict control over how <code class="md-code md-code-inline">target</code> can be interacted with</li>
  <li>Handlers are also known as traps, these terms are used interchangeably</li>
  <li>You can create <strong>revocable</strong> proxies with <code class="md-code md-code-inline">Proxy.revocable(target, handler)</code>

<ul>
  <li>That method returns an object with <code class="md-code md-code-inline">proxy</code> and <code class="md-code md-code-inline">revoke</code> properties</li>
  <li>You could <a href="#destructuring">destructure</a> <code class="md-code md-code-inline">var <mark class="md-mark md-code-mark">{proxy, revoke}</mark> = Proxy.revocable(target, handler)</code> for convenience</li>
  <li>You can configure the <code class="md-code md-code-inline">proxy</code> all the same as with <code class="md-code md-code-inline">new Proxy(target, handler)</code></li>
  <li>After <code class="md-code md-code-inline">revoke()</code> is called, the <code class="md-code md-code-inline">proxy</code> will <strong>throw</strong> on <em>any operation</em>, making it convenient when you can’t trust consumers</li>
</ul></li>
  <li><a href="#es6-proxies-in-depth#get"><code class="md-code md-code-inline">get</code></a> — traps <code class="md-code md-code-inline">proxy.prop</code> and <code class="md-code md-code-inline">proxy['prop']</code></li>
  <li><a href="#es6-proxies-in-depth#set"><code class="md-code md-code-inline">set</code></a> — traps <code class="md-code md-code-inline">proxy.prop = value</code> and <code class="md-code md-code-inline">proxy['prop'] = value</code></li>
  <li><a href="#es6-proxy-traps-in-depth#has"><code class="md-code md-code-inline">has</code></a> — traps <code class="md-code md-code-inline">in</code> operator</li>
  <li><a href="#es6-proxy-traps-in-depth#deleteproperty"><code class="md-code md-code-inline">deleteProperty</code></a> — traps <code class="md-code md-code-inline">delete</code> operator</li>
  <li><a href="#es6-proxy-traps-in-depth#defineproperty"><code class="md-code md-code-inline">defineProperty</code></a> — traps <code class="md-code md-code-inline">Object.defineProperty</code> and declarative alternatives</li>
  <li><a href="#es6-proxy-traps-in-depth#enumerate"><code class="md-code md-code-inline">enumerate</code></a> — traps <code class="md-code md-code-inline">for..in</code> loops</li>
  <li><a href="#es6-proxy-traps-in-depth#ownkeys"><code class="md-code md-code-inline">ownKeys</code></a> — traps <code class="md-code md-code-inline">Object.keys</code> and related methods</li>
  <li><a href="#es6-proxy-traps-in-depth#apply"><code class="md-code md-code-inline">apply</code></a> — traps <em>function calls</em></li>
  <li><a href="#morees6-proxy-traps-in-depth#construct"><code class="md-code md-code-inline">construct</code></a> — traps usage of the <code class="md-code md-code-inline">new</code> operator</li>
  <li><a href="#morees6-proxy-traps-in-depth#getprototypeof"><code class="md-code md-code-inline">getPrototypeOf</code></a> — traps internal calls to <code class="md-code md-code-inline">[[GetPrototypeOf]]</code></li>
  <li><a href="#morees6-proxy-traps-in-depth#setprototypeof"><code class="md-code md-code-inline">setPrototypeOf</code></a> — traps calls to <code class="md-code md-code-inline">Object.setPrototypeOf</code></li>
  <li><a href="#morees6-proxy-traps-in-depth#isextensible"><code class="md-code md-code-inline">isExtensible</code></a> — traps calls to <code class="md-code md-code-inline">Object.isExtensible</code></li>
  <li><a href="#morees6-proxy-traps-in-depth#preventextensions"><code class="md-code md-code-inline">preventExtensions</code></a> — traps calls to <code class="md-code md-code-inline">Object.preventExtensions</code></li>
  <li><a href="#morees6-proxy-traps-in-depth#getownpropertydescriptor"><code class="md-code md-code-inline">getOwnPropertyDescriptor</code></a> — traps calls to <code class="md-code md-code-inline">Object.getOwnPropertyDescriptor</code></li>
  <li>Read <a href="#es6-proxies-in-depth" aria-label="ES6 Proxies in Depth">ES6 Proxies in Depth</a></li>
  <li>Read <a href="#es6-proxy-traps-in-depth" aria-label="ES6 Proxy Traps in Depth">ES6 Proxy Traps in Depth</a></li>
  <li>Read <a href="#more-es6-proxy-traps-in-depth" aria-label="More ES6 Proxy Traps in Depth">More ES6 Proxy Traps in Depth</a></li>
</ul>

<p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p>



<h1 id="reflection"><span class="md-heading">Reflection</span></h1>

<ul>
  <li><code class="md-code md-code-inline">Reflection</code> is a new static built-in (think of <code class="md-code md-code-inline">Math</code>) in ES6</li>
  <li><code class="md-code md-code-inline">Reflection</code> methods have sensible internals, e.g <code class="md-code md-code-inline">Reflect.defineProperty</code> returns a boolean instead of throwing</li>
  <li>There’s a <code class="md-code md-code-inline">Reflection</code> method for each proxy trap handler, and they represent the default behavior of each trap</li>
  <li>Going forward, new reflection methods in the same vein as <code class="md-code md-code-inline">Object.keys</code> will be placed in the <code class="md-code md-code-inline">Reflection</code> namespace</li>
  <li>Read <a href="#es6-reflection-in-depth" aria-label="ES6 Reflection in Depth">ES6 Reflection in Depth</a></li>
</ul>

<p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p>



<h1 id="number"><span class="md-heading"><code class="md-code md-code-inline">Number</code></span></h1>

<ul>
  <li>Use <code class="md-code md-code-inline">0b</code> prefix for binary, and <code class="md-code md-code-inline">0o</code> prefix for octal integer literals</li>
  <li><code class="md-code md-code-inline">Number.isNaN</code> and <code class="md-code md-code-inline">Number.isFinite</code> are like their global namesakes, except that they <em>don’t</em> coerce input to <code class="md-code md-code-inline">Number</code></li>
  <li><code class="md-code md-code-inline">Number.parseInt</code> and <code class="md-code md-code-inline">Number.parseFloat</code> are exactly the same as their global namesakes</li>
  <li><code class="md-code md-code-inline">Number.isInteger</code> checks if input is a <code class="md-code md-code-inline">Number</code> value that doesn’t have a decimal part</li>
  <li><code class="md-code md-code-inline">Number.EPSILON</code> helps figure out negligible differences between two numbers — e.g. <code class="md-code md-code-inline">0.1 + 0.2</code> and <code class="md-code md-code-inline">0.3</code></li>
  <li><code class="md-code md-code-inline">Number.MAX_SAFE_INTEGER</code> is the largest integer that can be safely and precisely represented in JavaScript</li>
  <li><code class="md-code md-code-inline">Number.MIN_SAFE_INTEGER</code> is the smallest integer that can be safely and precisely represented in JavaScript</li>
  <li><code class="md-code md-code-inline">Number.isSafeInteger</code> checks whether an integer is within those bounds, able to be represented safely and precisely</li>
  <li>Read <a href="#es6-number-improvements-in-depth" aria-label="ES6 Number Improvements in Depth">ES6 <code class="md-code md-code-inline">Number</code> Improvements in Depth</a></li>
</ul>

<p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p>



<h1 id="math"><span class="md-heading"><code class="md-code md-code-inline">Math</code></span></h1>

<ul>
  <li><a href="#es6-math-additions-in-depth#mathsign"><code class="md-code md-code-inline">Math.sign</code></a> — sign function of a number</li>
  <li><a href="#es6-math-additions-in-depth#mathtrunc"><code class="md-code md-code-inline">Math.trunc</code></a> — integer part of a number</li>
  <li><a href="#es6-math-additions-in-depth#mathcbrt"><code class="md-code md-code-inline">Math.cbrt</code></a> — cubic root of value, or <code class="md-code md-code-inline">∛‾value</code></li>
  <li><a href="#es6-math-additions-in-depth#mathexpm1"><code class="md-code md-code-inline">Math.expm1</code></a> — <code class="md-code md-code-inline">e</code> to the <code class="md-code md-code-inline">value</code> minus <code class="md-code md-code-inline">1</code>, or <code class="md-code md-code-inline">e<sup>value</sup> - 1</code></li>
  <li><a href="#es6-math-additions-in-depth#mathlog1p"><code class="md-code md-code-inline">Math.log1p</code></a> — natural logarithm of <code class="md-code md-code-inline">value + 1</code>, or <code class="md-code md-code-inline"><em>ln</em>(value + 1)</code></li>
  <li><a href="#es6-math-additions-in-depth#mathlog10"><code class="md-code md-code-inline">Math.log10</code></a> — base 10 logarithm of <code class="md-code md-code-inline">value</code>, or <code class="md-code md-code-inline"><em>log</em><sub>10</sub>(value)</code></li>
  <li><a href="#es6-math-additions-in-depth#mathlog2"><code class="md-code md-code-inline">Math.log2</code></a> — base 2 logarithm of <code class="md-code md-code-inline">value</code>, or <code class="md-code md-code-inline"><em>log</em><sub>2</sub>(value)</code></li>
  <li><a href="#es6-math-additions-in-depth#mathsinh"><code class="md-code md-code-inline">Math.sinh</code></a> — hyperbolic sine of a number</li>
  <li><a href="#es6-math-additions-in-depth#mathcosh"><code class="md-code md-code-inline">Math.cosh</code></a> — hyperbolic cosine of a number</li>
  <li><a href="#es6-math-additions-in-depth#mathtanh"><code class="md-code md-code-inline">Math.tanh</code></a> — hyperbolic tangent of a number</li>
  <li><a href="#es6-math-additions-in-depth#mathasinh"><code class="md-code md-code-inline">Math.asinh</code></a> — hyperbolic arc-sine of a number</li>
  <li><a href="#es6-math-additions-in-depth#mathacosh"><code class="md-code md-code-inline">Math.acosh</code></a> — hyperbolic arc-cosine of a number</li>
  <li><a href="#es6-math-additions-in-depth#mathatanh"><code class="md-code md-code-inline">Math.atanh</code></a> — hyperbolic arc-tangent of a number</li>
  <li><a href="#es6-math-additions-in-depth#mathhypot"><code class="md-code md-code-inline">Math.hypot</code></a> — square root of the sum of squares</li>
  <li><a href="#es6-math-additions-in-depth#mathclz32"><code class="md-code md-code-inline">Math.clz32</code></a> — leading zero bits in the 32-bit representation of a number</li>
  <li><a href="#es6-math-additions-in-depth#mathimul"><code class="md-code md-code-inline">Math.imul</code></a> — <em>C-like</em> 32-bit multiplication</li>
  <li><a href="#es6-math-additions-in-depth#mathfround"><code class="md-code md-code-inline">Math.fround</code></a> — nearest single-precision float representation of a number</li>
  <li>Read <a href="#es6-math-additions-in-depth" aria-label="ES6 Math Additions in Depth">ES6 <code class="md-code md-code-inline">Math</code> Additions in Depth</a></li>
</ul>

<p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p>



<h1 id="array"><span class="md-heading"><code class="md-code md-code-inline">Array</code></span></h1>

<ul>
  <li><a href="#es6-array-extensions-in-depth#arrayfrom"><code class="md-code md-code-inline">Array.from</code></a> — create <code class="md-code md-code-inline">Array</code> instances from arraylike objects like <code class="md-code md-code-inline">arguments</code> or iterables</li>
  <li><a href="#es6-array-extensions-in-depth#arrayof"><code class="md-code md-code-inline">Array.of</code></a> — similar to <code class="md-code md-code-inline">new Array(...items)</code>, but without special cases</li>
  <li><a href="#es6-array-extensions-in-depth#arrayprototypecopywithin"><code class="md-code md-code-inline">Array.prototype.copyWithin</code></a> — copies a sequence of array elements into somewhere else in the array</li>
  <li><a href="#es6-array-extensions-in-depth#arrayprototypefill"><code class="md-code md-code-inline">Array.prototype.fill</code></a> — fills all elements of an existing array with the provided value</li>
  <li><a href="#es6-array-extensions-in-depth#arrayprototypefind"><code class="md-code md-code-inline">Array.prototype.find</code></a> — returns the first item to satisfy a callback</li>
  <li><a href="#es6-array-extensions-in-depth#arrayprototypefindindex"><code class="md-code md-code-inline">Array.prototype.findIndex</code></a> — returns the index of the first item to satisfy a callback</li>
  <li><a href="#es6-array-extensions-in-depth#arrayprototypekeys"><code class="md-code md-code-inline">Array.prototype.keys</code></a> — returns an iterator that yields a sequence holding the keys for the array</li>
  <li><a href="#es6-array-extensions-in-depth#arrayprototypevalues"><code class="md-code md-code-inline">Array.prototype.values</code></a> — returns an iterator that yields a sequence holding the values for the array</li>
  <li><a href="#es6-array-extensions-in-depth#arrayprototypeentries"><code class="md-code md-code-inline">Array.prototype.entries</code></a> — returns an iterator that yields a sequence holding key value pairs for the array</li>
  <li><a href="#es6-array-extensions-in-depth#arrayprototype-symboliterator"><code class="md-code md-code-inline">Array.prototype[Symbol.iterator]</code></a> — exactly the same as the <a href="#es6-array-extensions-in-depth#arrayprototypevalues"><code class="md-code md-code-inline">Array.prototype.values</code></a> method</li>
  <li>Read <a href="#es6-array-extensions-in-depth" aria-label="ES6 Array Extensions in Depth">ES6 <code class="md-code md-code-inline">Array</code> Extensions in Depth</a></li>
</ul>

<p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p>



<h1 id="object"><span class="md-heading"><code class="md-code md-code-inline">Object</code></span></h1>

<ul>
  <li><a href="#es6-object-changes-in-depth#objectassign"><code class="md-code md-code-inline">Object.assign</code></a> — recursive shallow overwrite for properties from <code class="md-code md-code-inline">target, ...objects</code></li>
  <li><a href="#es6-object-changes-in-depth#objectis"><code class="md-code md-code-inline">Object.is</code></a> — like using the <code class="md-code md-code-inline">===</code> operator programmatically, but also <code class="md-code md-code-inline">true</code> for <code class="md-code md-code-inline">NaN</code> vs <code class="md-code md-code-inline">NaN</code> and <code class="md-code md-code-inline">+0</code> vs <code class="md-code md-code-inline">-0</code></li>
  <li><a href="#es6-object-changes-in-depth#objectgetownpropertysymbols"><code class="md-code md-code-inline">Object.getOwnPropertySymbols</code></a> — returns all own property symbols found on an object</li>
  <li><a href="#es6-object-changes-in-depth#objectsetprototypeof"><code class="md-code md-code-inline">Object.setPrototypeOf</code></a> — changes prototype. Equivalent to <code class="md-code md-code-inline">target.__proto__</code> setter</li>
  <li>See also <a href="#object-literals">Object Literals</a> section</li>
  <li>Read <a href="#es6-object-changes-in-depth" aria-label="ES6 Object Changes in Depth">ES6 <code class="md-code md-code-inline">Object</code> Changes in Depth</a></li>
</ul>

<p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p>



<h1 id="strings-and-unicode"><span class="md-heading">Strings and Unicode</span></h1>

<ul>
  <li>String Manipulation

<ul>
  <li><a href="#es6-strings-and-unicode-in-depth#stringprototypestartswith"><code class="md-code md-code-inline">String.prototype.startsWith</code></a> — whether the string starts with <code class="md-code md-code-inline">value</code></li>
  <li><a href="#es6-strings-and-unicode-in-depth#stringprototypeendswith"><code class="md-code md-code-inline">String.prototype.endsWith</code></a> — whether the string ends in <code class="md-code md-code-inline">value</code></li>
  <li><a href="#es6-strings-and-unicode-in-depth#stringprototypeincludes"><code class="md-code md-code-inline">String.prototype.includes</code></a> — whether the string contains <code class="md-code md-code-inline">value</code> anywhere</li>
  <li><a href="#es6-strings-and-unicode-in-depth#stringprototyperepeat"><code class="md-code md-code-inline">String.prototype.repeat</code></a> — returns the string repeated <code class="md-code md-code-inline">amount</code> times</li>
  <li><a href="#es6-strings-and-unicode-in-depth#stringprototype-symboliterator"><code class="md-code md-code-inline">String.prototype[Symbol.iterator]</code></a> — lets you iterate over a sequence of unicode code points <em>(not characters)</em></li>
</ul></li>
  <li><a href="#es6-strings-and-unicode-in-depth#unicode">Unicode</a>

<ul>
  <li><a href="#es6-strings-and-unicode-in-depth#stringprototypecodepointat"><code class="md-code md-code-inline">String.prototype.codePointAt</code></a> — base-10 numeric representation of a code point at a given position in string</li>
  <li><a href="#es6-strings-and-unicode-in-depth#stringfromcodepoint%60"><code class="md-code md-code-inline">String.fromCodePoint</code></a> — given <code class="md-code md-code-inline">...codepoints</code>, returns a string made of their unicode representations</li>
  <li><a href="#es6-strings-and-unicode-in-depth#stringprototypenormalize"><code class="md-code md-code-inline">String.prototype.normalize</code></a> — returns a normalized version of the string’s unicode representation</li>
</ul></li>
  <li>Read <a href="#es6-strings-and-unicode-in-depth" aria-label="ES6 Strings (and Unicode, ❤) in Depth">ES6 Strings and Unicode Additions in Depth</a></li>
</ul>

<p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p>



<h1 id="modules"><span class="md-heading">Modules</span></h1>

<ul>
  <li><a href="#es6-modules-in-depth#strict-mode">Strict Mode</a> is turned on by default in the ES6 module system</li>
  <li>ES6 modules are files that <a href="#es6-modules-in-depth#export"><code class="md-code md-code-inline">export</code></a> an API</li>
  <li><a href="#es6-modules-in-depth#exporting-a-default-binding"><code class="md-code md-code-inline">export default value</code></a> exports a default binding</li>
  <li><a href="#es6-modules-in-depth#named-exports"><code class="md-code md-code-inline">export var foo = 'bar'</code></a> exports a named binding</li>
  <li>Named exports are bindings that <a href="#es6-modules-in-depth#bindings-not-values">can be changed</a> at any time from the module that’s exporting them</li>
  <li><code class="md-code md-code-inline">export { foo, bar }</code> exports <a href="#es6-modules-in-depth#exporting-lists">a list of named exports</a></li>
  <li><code class="md-code md-code-inline">export { foo <mark class="md-mark md-code-mark">as ponyfoo</mark> }</code> aliases the export to be referenced as <code class="md-code md-code-inline">ponyfoo</code> instead</li>
  <li><code class="md-code md-code-inline">export { foo <mark class="md-mark md-code-mark">as default</mark> }</code> marks the named export as the default export</li>
  <li>As <a href="#es6-modules-in-depth#best-practices-and-export">a best practice</a>, <code class="md-code md-code-inline">export default api</code> at the end of all your modules, where <code class="md-code md-code-inline">api</code> is an object, avoids confusion</li>
  <li>Module loading is implementation-specific, allows interoperation with CommonJS</li>
  <li><a href="#es6-modules-in-depth#import"><code class="md-code md-code-inline">import 'foo'</code></a> loads the <code class="md-code md-code-inline">foo</code> module into the current module</li>
  <li><a href="#es6-modules-in-depth#importing-default-exports"><code class="md-code md-code-inline">import <mark class="md-mark md-code-mark">foo from</mark> 'ponyfoo'</code></a> assigns the default export of <code class="md-code md-code-inline">ponyfoo</code> to a local <code class="md-code md-code-inline">foo</code> variable</li>
  <li><a href="#es6-modules-in-depth#importing-named-exports"><code class="md-code md-code-inline">import {foo, bar} from 'baz'</code></a> imports named exports <code class="md-code md-code-inline">foo</code> and <code class="md-code md-code-inline">bar</code> from the <code class="md-code md-code-inline">baz</code> module</li>
  <li><code class="md-code md-code-inline">import {foo <mark class="md-mark md-code-mark">as bar</mark>} from 'baz'</code> imports named export <code class="md-code md-code-inline">foo</code> but aliased as a <code class="md-code md-code-inline">bar</code> variable</li>
  <li><code class="md-code md-code-inline">import {default} from 'foo'</code> also imports the default export</li>
  <li><code class="md-code md-code-inline">import {default <mark class="md-mark md-code-mark">as bar</mark>} from 'foo'</code> imports the default export aliased as <code class="md-code md-code-inline">bar</code></li>
  <li><code class="md-code md-code-inline">import foo, {bar, baz} from 'foo'</code> mixes default <code class="md-code md-code-inline">foo</code> with named exports <code class="md-code md-code-inline">bar</code> and <code class="md-code md-code-inline">baz</code> in one declaration</li>
  <li><a href="#es6-modules-in-depth#import-all-the-things"><code class="md-code md-code-inline">import * as foo from 'foo'</code></a> imports the namespace object

<ul>
  <li>Contains all named exports in <code class="md-code md-code-inline">foo[name]</code></li>
  <li>Contains the default export in <code class="md-code md-code-inline">foo.default</code>, if a default export was declared in the module</li>
</ul></li>
  <li>Read <a href="#es6-modules-in-depth" aria-label="ES6 Modules in Depth">ES6 Modules Additions in Depth</a></li>
</ul>

<p><sup><a href="#table-of-contents">(back to table of contents)</a></sup></p>

<p>Time for a bullet point detox. Then again, I <em>did warn you</em> to read the article series instead. Also, did you try the <a href="https://en.wikipedia.org/wiki/Konami_Code">Konami code</a> just yet?</p></section></section>
</article>
</div>
<p><a href="#top" class="top"><img src="./auxi/glyphicons-214-up-arrow.png" alt="up-arrow" class="uparrow" /> <b>Back to top</b></a></p>
</section></main>

<!--  overview ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->
<!--  ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->




<!--  about the author ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->

<main class="ly-main">
<header class="at-header">
<h1 itemprop="headline" class="dc-title" id="es6-about-the-author">About the Author</h1>
</header>

<section class="at-teaser"><div class="at-teaser-markdown md-markdown">

<p></p></div></section>




<main class="ly-main" data-reactid=".259f4fd5x4w.1.1">
<article class="ly-content ly-section" data-reactid=".ya18e8tukg" data-react-checksum="1894111093">
<h1 class="ly-header hm-name" data-reactid=".ya18e8tukg.0">Nicolas Bevacqua
</h1>
<h2 class="hm-role" data-reactid=".ya18e8tukg.1">JavaScript and Web Performance Consultant
</h2>
<section class="hm-section" data-reactid=".ya18e8tukg.2">
<p class="hm-about" data-reactid=".ya18e8tukg.2.0">
<span data-reactid=".ya18e8tukg.2.0.0">I</span><span class="c-pink" data-reactid=".ya18e8tukg.2.0.1">❤</span><span data-reactid=".ya18e8tukg.2.0.2">️ the web. I am a </span><a href="/consulting" target="_blank" data-reactid=".ya18e8tukg.2.0.3">consultant</a><span data-reactid=".ya18e8tukg.2.0.4">, a conference </span><a href="/talks" data-reactid=".ya18e8tukg.2.0.5">speaker</a><span data-reactid=".ya18e8tukg.2.0.6">, the author of </span><a href="/buildfirst" data-reactid=".ya18e8tukg.2.0.7">JavaScript Application Design</a><span data-reactid=".ya18e8tukg.2.0.8">, an </span><a href="/blog" data-reactid=".ya18e8tukg.2.0.9">opinionated blogger</a><span data-reactid=".ya18e8tukg.2.0.a">, and an </span><a href="/opensource" data-reactid=".ya18e8tukg.2.0.b">open-source</a><span data-reactid=".ya18e8tukg.2.0.c"> evangelist. I participate actively in the online JavaScript </span><a href="/twitter" data-reactid=".ya18e8tukg.2.0.d">community</a><span data-reactid=".ya18e8tukg.2.0.e"> — as well as </span><em data-reactid=".ya18e8tukg.2.0.f">offline</em><span data-reactid=".ya18e8tukg.2.0.g"> in beautiful Buenos Aires.</span></p>

<p data-reactid=".ya18e8tukg.2.1"><span data-reactid=".ya18e8tukg.2.1.0">I like writing about the current </span><a href="https://ponyfoo.com/articles/stop-breaking-the-web" title="Stop Breaking the Web" target="_blank" data-reactid=".ya18e8tukg.2.1.1">state of the web</a><span data-reactid=".ya18e8tukg.2.1.2">, new features coming our way in </span><a href="https://ponyfoo.com/articles/tagged/es6-in-depth" title="ES6 in Depth" data-reactid=".ya18e8tukg.2.1.3">ES6</a><span data-reactid=".ya18e8tukg.2.1.4">, leveraging </span><a href="https://ponyfoo.com/articles/talk-about-web-performance" title="Let's talk about Web Performance" target="_blank" data-reactid=".ya18e8tukg.2.1.5">web performance</a><span data-reactid=".ya18e8tukg.2.1.6"> optimization to make our sites much faster, the importance of </span><a href="https://ponyfoo.com/articles/progressive-web" title="The Progressive Web" target="_blank" data-reactid=".ya18e8tukg.2.1.7">progressive enhancement</a><span data-reactid=".ya18e8tukg.2.1.8">, sane </span><a href="https://ponyfoo.com/articles/gulp-grunt-whatever" title="Gulp, Grunt, Whatever" target="_blank" data-reactid=".ya18e8tukg.2.1.9">build processes</a><span data-reactid=".ya18e8tukg.2.1.a"> and improving quality in your applications with </span><a href="https://ponyfoo.com/articles/why-i-write-plain-javascript-modules" title="Why I Write Plain JavaScript Modules" target="_blank" data-reactid=".ya18e8tukg.2.1.b">modular design</a><span data-reactid=".ya18e8tukg.2.1.c">. I used to spend a lot of my time answering questions on </span><a href="/stackoverflow" target="_blank" data-reactid=".ya18e8tukg.2.1.d">Stack Overflow</a><span data-reactid=".ya18e8tukg.2.1.e">, but now I spend most that time doing open-source work instead.</span></p>

<p data-reactid=".ya18e8tukg.2.2"><span data-reactid=".ya18e8tukg.2.2.0">I really enjoy developing small open-source modules that I publish to </span><code data-reactid=".ya18e8tukg.2.2.1">npm</code><span data-reactid=".ya18e8tukg.2.2.2"> and </span><a href="/code" target="_blank" data-reactid=".ya18e8tukg.2.2.3">GitHub</a><span data-reactid=".ya18e8tukg.2.2.4">. Some of these are small utilities that work well in both Node.js and the browser, and some others are front-end components that make it easier to use certain parts of the web. My favorite approach to open-source is developing small modules because that way you can </span><em data-reactid=".ya18e8tukg.2.2.5">compose</em><span data-reactid=".ya18e8tukg.2.2.6"> them in interesting ways and it also fosters </span><em data-reactid=".ya18e8tukg.2.2.7">reusability</em><span data-reactid=".ya18e8tukg.2.2.8">. Learning how to write modular code is one of the most valuable things you can do to improve your skills as a JavaScript developer.</span></p>

<p data-reactid=".ya18e8tukg.2.3"><span data-reactid=".ya18e8tukg.2.3.0">I've used a variety of tools when it comes to development. Trying out many different tools, </span><em data-reactid=".ya18e8tukg.2.3.1">creating some of your own</em><span data-reactid=".ya18e8tukg.2.3.2">, and experimenting are the best ways to really understand how they work and the tradeoffs between all the different tools and frameworks out there. If it's up to me, I like simple solutions. That's why I prefer to use </span><code data-reactid=".ya18e8tukg.2.3.3">npm run</code><span data-reactid=".ya18e8tukg.2.3.4"> and Bash in my builds. I also like </span><a href="http://facebook.github.io/react/" title="Facebook React" target="_blank" data-reactid=".ya18e8tukg.2.3.5">React</a><span data-reactid=".ya18e8tukg.2.3.6"> and </span><a href="http://taunus.io" title="Taunus Universal MVC" target="_blank" data-reactid=".ya18e8tukg.2.3.7">Taunus</a><span data-reactid=".ya18e8tukg.2.3.8"> when it comes to view rendering, because they're </span><strong data-reactid=".ya18e8tukg.2.3.9">simpler and more performant</strong><span data-reactid=".ya18e8tukg.2.3.a"> than anything else in the JavaScript framework landscape. I use AWS for deployments because I like having fine-grained control, but I've also experimented with other providers like Heroku and Digital Ocean.</span></p>

<p data-reactid=".ya18e8tukg.2.4"><span data-reactid=".ya18e8tukg.2.4.0">Re-inventing the wheel is </span><strong data-reactid=".ya18e8tukg.2.4.1">a necessary evil</strong><span data-reactid=".ya18e8tukg.2.4.2"> if we want to learn from mistakes made in the past </span><em data-reactid=".ya18e8tukg.2.4.3">(regardless of who made them)</em><span data-reactid=".ya18e8tukg.2.4.4">.</span></p>
</section>

<section class="hm-section hm-photo-section" data-reactid=".ya18e8tukg.3"><a href="/blog" title="Pony Foo" target="_blank" data-reactid=".ya18e8tukg.3.0"><img class="hm-photo" src="./auxi/nicolas_bevacqua.jpg" alt="Pony Foo" data-reactid=".ya18e8tukg.3.0.0"></a>

<p>Disclaimer: it might be possible that I don't look this good anymore.</p>
</section>

<section>
<p><em>(This biographical note was taken from https://bevacqua.io/ and may not be covered by the CC BY-NC 2.5 license that the rest of the text at Pony Foo is.)</em></p>

<p><em>On the Pony Foo home page, this note appears:</em></p>


<p>You can support my writing and <a href="https://bevacqua.io/opensource" aria-label="My Open Source Contributions">open-source</a> work through <a href="http://patreon.com/bevacqua" aria-label="Contribute to my writing!">Patreon</a> or <a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&amp;hosted_button_id=29CRFXW53HRP2" aria-label="Contribute to Pony Foo on PayPal">PayPal</a>.<br><strong>Looking for a consultant?</strong> Have a conference talk opportunity? <em><a href="mailto:hello@ponyfoo.com" aria-label="Send me an email">Contact me!</a></em></p>

<p><a href="https://bevacqua.io/buildfirst" aria-label="JavaScript Application Design: A Build First Approach"><img alt="JavaScript Application Design" class="js-only" src="./auxi/javascript-application-design-cover.jpg"></a></p>

<ul><li><a href="https://twitter.com/nzgb" aria-label="@nzgb on Twitter">@nzgb</a> on Twitter</li><li><a href="https://github.com/bevacqua" aria-label="@bevacqua on GitHub">@bevacqua</a> on GitHub</li><li><a href="http://patreon.com/bevacqua" aria-label="Contribute to my writing!">@bevacqua</a> on Patreon</li><li><a href="http://lanyrd.com/profile/bevacqua/" aria-label="My conference speaking experience">@bevacqua</a> on Lanyrd</li><li><a href="https://bevacqua.io" aria-label="My consulting minisite">bevacqua.io</a></li></ul>

<p>Pony Foo is on <a href="https://twitter.com/ponyfoo">Twitter</a> and <a href="https://www.facebook.com/ponyfoo">Facebook</a>.</p>

</article>
</main>

<!--  about the author ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->
<!--  ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->





<!--  ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->
<hr class="style8" />
<p><b>NOTE:</b> <em>You can comment on any of these articles at <a href="https://ponyfoo.com/articles/tagged/es6-in-depth" title="link to Pony Foo page listing all the ES6 in Depth articles">Pony Foo</a>, and that’s where any factual errors should be noted. </em></p>
<!--  ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->




<!--  ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->
<hr class="style8" />
<p>This PDF was created (and styled) by <a href="https://github.com/rsperberg" title="link to Roger Sperberg github page">Roger Sperberg</a>. Any typographical or grammar errors or any issues with the PDF itself can be posted on the <a href="https://github.com/rsperberg/es6-info/issues" title="link to ES6-info issues page on github">issues page</a> of the <a href="https://github.com/rsperberg/es6-info" title="link to ES6-info repository on github">ES6-info repository</a> on GitHub.</p>
<p>The <a href="https://github.com/rsperberg/es6-info/blob/master/ES6%20Whats%20new%20(smashing).pdf">latest version of this PDF</a> can be downloaded from the <a href="https://github.com/rsperberg/es6-info" title="link to ES6-info repository on github">ES6-info repository</a>.</p>
<p><b>NOTE:</b> <em>This PDF was last revised on 2015-11-11</em></p>
<hr class="style8" />

<!--  ++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++  -->


<p><a href="#top" class="top"><img src="./auxi/glyphicons-214-up-arrow.png" alt="up-arrow" class="uparrow" /> <b>Back to top</b></a></p>














<footer class="ly-footer">

<p>
 <a href="https://creativecommons.org/licenses/by-nc/2.5/" target="_blank" class="ly-license">Creative Commons Attribution-NonCommercial 2.5 License</a>
<span>.
</span></p>
</footer>
<script>~function(a,n,t){function e(a){var t=n.createElement("script");t.src=a,n.body.appendChild(t)}function d(){var a=t.search,n=a?"&"+a.substr(1):"",d="?json&callback=taunusReady"+n;e(t.pathname+d),e("/js/all.f0ef5aac.js")}a.taunusReady=function(n){a.taunusReady=n},a.addEventListener?a.addEventListener("load",d,!1):a.attachEvent?a.attachEvent("onload",d):a.onload=d}(window,document,location);
</script>
<script type="text/javascript">
/*
<![CDATA[ */
(function(){try{var s,a,i,j,r,c,l=document.getElementsByTagName("a"),t=document.createElement("textarea");for(i=0;l.length-i;i++){try{a=l[i].getAttribute("href");if(a&&a.<span class="built_in">indexOf</span>("/cdn-cgi/l/email-protection") > -1  && (a.length > 28)){s='';j=27+ 1 + a.<span class="built_in">indexOf</span>("/cdn-cgi/l/email-protection");if (a.length > j) {r=parseInt(a.substr(j,2),16);for(j+=2;a.length>j&&a.substr(j,1)!='X';j+=2){c=parseInt(a.substr(j,2),16)^r;s+=String.fromCharCode(c);}j+=1;s+=a.substr(j,a.length-j);}t.innerHTML=s.replace(/
</g,"&lt;").replace(/>/g,"&gt;");l[i].setAttribute("href","mailto:"+t.value);}}catch(e){}}}catch(e){}})();
/* ]]> */

</script>


<!--  script src="./01_A Brief History of ES6 Tooling_files/all.f0ef5aac.js">
</script  -->
<iframe id="rdbIndicator" width="100%" height="270" border="0" src="./auxi/indicator.html" style="display: none; border: 0; position: fixed; left: 0; top: 0; z-index: 2147483647">
</iframe>



<img src="./auxi/ponyfoo.png" class="ponyfoo" alt="Pony Foo" />


</body>
</html>
